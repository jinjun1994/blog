(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{319:function(e,t,o){"use strict";o.r(t),t.default=[{title:"异步编程全传",path:"/posts/JavaScript/async.html",strippedContent:' [[toc]]    ## 异步编程全传    各种技术方案的涌现是为了解决实践中遇到的各种问题，本文将从这个角度带你梳理并掌握异步编程的核心内容。    首先对单线程异步的原理进行解读，接着按照发展历程分析JavaScript异步解决方案，详述Callback、Promise、Generator、Async/Await的特性和使用原理。        ## 一、同步异步、阻塞非阻塞    **1.同步与异步**  同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)  所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。  换句话说，就是**由调用者主动等待这个调用的结果**。    而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，**被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用**。    典型的异步编程模型比如Node.js    举个通俗的例子：  你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。  而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。    **2.阻塞与非阻塞**  阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态.**    阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。  非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。    还是上面的例子，  你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。  在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。[原文链接](https://www.zhihu.com/question/19732473/answer/20851256)    "同步或异步"要从调用方来判断。    同步函数返回表示工作已完成或发生异常，接下来依赖此结果的的代码被调用方继续执行。    异步函数返回表示工作已发布出去，什么时候完成不知道，接下来的代码无法依赖一个未知的结果，所以要传入一个回调在完成后处理。    js 的异步其更多的是为了和界面UI 的分时，所以尽量将任务切割为细粒度的小任务，每次执行完一段小任务只耗费一段足够小的时间然后让出时间给UI，这样UI就不会卡死。如果任务切割得不好，任务段仍然耗时长，那么无论使什么花样，一样卡死UI。因为js的异步实现不了真正并行。    其实这样的异步仅仅是推迟了某些代码的执行，对于一段需要长时间来执行的代码来说，异步只是将其的执行顺序移到后面，然后不阻塞其他的逻辑代码，等到其他代码执行完成，然后再执行这段代码，但是这段代码在执行的时候仍然还是会阻塞UI和其他业务代码的。        JavaScript其中一个基本的特性就是单线程：比如，浏览器无法同时运行两个事件处理程序，同时更新应用状态和文档状态根本是不可能的。之所以设计成单线程的原因就是，客户端的JavaScript函数必须不能运行太长时间：否则会导致循环事件，Web浏览器无法对用户输入作出响应。这也是为什么Ajax的API都是异步的    对于JavaScript这样单线程的东西唯一的解耦方法就是提供异步API。    ## 二、任务队列    单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。    于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。    具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）    > （1）所有同步任务都在主线程上执行，形成一个[执行栈](http://www.ruanyifeng.com/blog/2013/11/stack.html)（execution context stack）。  >  > （2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。  >  > （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。  >  > （4）主线程不断重复上面的第三步。    下图就是主线程和任务队列的示意图。    ![任务队列](https://img.dubiqc.com/201903/06021643.png-sign)    只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。        ## 三、事件处理    客户端Web 应用是一种GUI应用，也就是说这种应用会对不同类型的事件作响应，如鼠标移动、单击和键盘按压等。因此，在页面构建阶段执行的JavaScript代码，除了会影响全局应用状态和修改DOM外，还会注册事件监听器（或处理器）。这类监听器会在事件发生时，由浏览器调用执行。有了这些事件处理器，我们的应用也就有了交互能力。在详细探讨注册事件处理器之前，让我们先从头到尾看一遍事件处理器的总体思想。    浏览器执行环境的核心思想基于：同一时刻只能执行一个代码片段，即所谓的单线程执行模型。想象一下在银行柜台前排队，每个人进入一支队伍等待叫号并“处理”。但JavaScript则只开启了一个营业柜台。每当轮到某个顾客时（某个事件），只能处理该位顾客。    当一个事件抵达后，浏览器需要执行相应的事件处理函数。这里不保证用户总会极富耐心地等待很长时间，直到下一个事件触发。所以，浏览器需要一种方式来跟踪已经发生但尚未处理的事件。为实现这个目标，浏览器使用了事件队列，如图所示。    ![事件处理](https://img.dubiqc.com/201903/06040715.png-sign)    所有已生成的事件（无论是用户生成的，例如鼠标移动或键盘按压，还是服务器生成的，例如Ajax事件）都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。事件处理的过程可以描述为一个简单的流程图。    -  浏览器检查事件队列头；   -  如果浏览器没有在队列中检测到事件，则继续检查；   -  如果浏览器在队列头中检测到了事件，则取出该事件并执行相应的事件处理器（如果存在）。在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理。    事件处理背后的的主要思想是：当事件发生时，浏览器调用相应的事件处理器。    ## 回调函数    广义上回调函数的定义为：一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。    在JavaScript中，回调函数具体的定义为：函数A作为参数（函数引用）传递到另一个函数B中，并且这个函数B执行函数A，我们就说函数A叫做回调函数。如果没有名称（函数表达式），就叫做匿名回调函数。因此callback不一定用于异步，一般同步（阻塞）的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。    浏览器最早内置的setTimeout与setInteval就是基于回调的思想实现的，Node.js的异步API，都是通过回调实现。       回调是实现异步最朴素的方式。回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。    回调本质上是一种设计模式。回调函数本质上提供了一种与常规的上层调用下层代码相反的模式，使得底层代码也有机会反调高层的代码，这大大提升了代码的能力，也同时给工程化项目带来了新的问题和挑战。    编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写**库**；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是**应用**例如编写JavaScript网页程序。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口）例如浏览器提供的各种web API，以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。    当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为**回调函数**（callback function）。    打个比方，有一家旅馆提供叫醒服务API，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为**登记回调函数**（to register a callback function）。如下图所示（图片来源：维基百科）：    ![img](https://img.dubiqc.com/201903/07105851.png-sign)        可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再**回**过头来**调**用高层的过程。这应该是回调最早的应用之处，也是其得名如此的原因。    回调函数也是事件驱动式编程的基础，使得程序不必像传统的流程驱动式编程那样亦步亦趋的向下进行，而是可以被动性的由外来事件来触发进行，这几乎是所有图形化编程最基础和标准的实现方式。JavaScript可以说是基于回调的事件驱动程序设计模型。    ### **回调机制的优势**    一个典型的回调函数的例子就是在各个语言中都很常见的排序接口（比如 JavaScript 中 sort 函数），它们几乎都允许用户自己提供一个定制化的「比较函数」，这个比较函数就是典型的回调函数，它将会在排序接口的内部被执行。正是由于这样的回调函数的存在，使得排序接口不再仅仅局限于自然排序，**大大提高了代码和接口的重用性**。    回调函数分为两种，一种是同步回调函数，另一种是异步回调函数。上述排序接口的回调函数就是同步回调函数，而在 Node.js 中常见的回调函数是异步回调函数。同步回调和异步回调都可以使得调用者（caller）不再简单依赖于被调用者（callee），使得二者在代码空间分布上解耦，而异步回调函数更是在运行时从时间上将二者解耦。    回调函数背后其实隐藏着「[控制反转](https://en.wikipedia.org/wiki/Inversion_of_control)（IoC，Inversion of Control ）」的编程哲学，或者说回调函数是实现 IoC 的最常见的手段。IoC 的核心思想是 “Don’t call me, I’ll call you”，也被叫作「好莱坞原则」，据说是好莱坞经纪人的口头禅。控制反转其实也很常见，一般的库（library）中有回调函数的地方就有控制反转，这种控制反转可能还是局部的，而 Web 开发中几乎肯定会用的框架（framework）则是把控制反转作用到了全局，它使得基于上的更高层开发者不用像命题作文一样从零开始创作，而是把它变成了一道填空题，你只需要在约定好的地方按照具体的业务需求填入相应的内容即可，整个程序的运转流程被牢牢地把控在框架手中。用vue.js框架进行开发相当于往函数里面填写参数。    ### **易被忽略的主程序**    通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为**起始函数**。    之所以特意强调这个，是因为，很多人把它简单地理解为两个个体之间的来回调用。很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。    ### 回调存在的问题    #### 一、无法完美表达复杂异步代码逻辑     在异步中如果你总是依赖回调的话，很容易就写出大家都看不懂， 甚至自己过段时间也看不懂的代码来。    常见的异步场景回调也没办法用足够简洁优雅的方式去处理：    这些场景包括但不限于：多个异步回调的串行处理（链式），多个异步回调的并行处理（门）和异步任务竞赛    ##### 回调嵌套（异步回调的串行处理）    JS从一开始就使用事件轮询的并发模型。我们一直以来都在写异步的程序。直到最近，我们仍然在用简单的回调函数来处理异步的问题。    ```javascript  makeAjaxRequest(url,function(respnose){      alert("Response:" + response) ;  }) ;  ```    当我们只有一个异步任务的时候使用回调函数看起来还不会有什么问题。但是，实际是我们完成一个任务通常需要多个异步操作。例如：    ```javascript  btn.addEventListener("click",function(evt){      makeAjaxRequest(url,function(response){          makeAjaxRequest(anotherURL + "?resp=" + response,function(response2){              alert("Response2:" + response) ;          })      }) ;  },false) ;  ```    把一系列异步操作链接在一起最自然的方式就是使用回调嵌套，步骤2嵌套在步骤1中然后步骤3嵌套在步骤2中，等等。**我们的代码风格应该是“链式”风格， 但却因为回调的原因被硬生生折腾成了难懂的“嵌套”风格 。**    ##### 回调地狱    你使用越多的回调，就会有越多的嵌套，不断缩进意大利面条似的代码。很显然，这种代码难以编写，难以理解而且难以维护。如果我们花点时间来理清这些代码往往会让我们事半功倍。 这类嵌套/缩进经常被叫做"回调地狱"。有时也被叫做"回调金字塔"，专指由于代码不断缩进所形成的金字塔形状，缩进越多金字塔形状越明显。    我们认真思考的时候很少是以事件的形式进行的。取而代之的是，我们按照顺序（A，然后 B，然后 C）仔细计划着，并且会假定有某种形式的临时阻塞来保证 B 会等待 A 完成，C 会等待 B 完成。开发者编写代码的时候是在计划一系列动作的发生。优秀的开发者会认真计划。“我需要把 z 设为 x 的值，然后把 x 设为 y 的值”，等等。编写同步代码的时候，语句是一条接一条执行的，其工作方式非常类似于待办任务清单。    ````javascript  // 交换x和y（通过临时变量z）  z = x;   x = y;   y = z;   ````    这三条语句是同步执行的，所以 x = y 会等待 z = x 执行完毕，然后 y = z 等待 x = y 执行完毕。换个说法就是，这三条语句临时绑定按照特定顺序一个接一个地执行。这里我们不需要处理异步事件的细节。如果需要的话，代码马上就会变得复杂得多！  所以，如果说同步的大脑计划能够很好地映射到同步代码语句，那么我们的大脑在规划异步代码方面又是怎样的呢？  答案是代码（通过回调）表达异步的方式并不能很好地映射到同步的大脑计划行为。    这才是回调地狱的真正问题所在！嵌套和缩进基本上只是转移注意力的枝节而已。我们的顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码。这就是回调方式最主要的缺陷：对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。    对程序员来说，编写异步事件代码，特别是当回调是唯一的实现手段时，困难之处就在于这种思考 / 计划的意识流对我们中的绝大多数来说是不自然的。我们的思考方式是一步一步的，但是从同步转换到异步之后，可用的工具（回调）却不是按照一步一步的方式来表达的。这就是为什么精确编写和追踪使用回调的异步 JavaScript 代码如此之难：因为这并不是我们大脑进行计划的运作方式。    ##### 异步回调的并行处理（门）    在经典的编程术语中，门（gate）是这样一种机制要等待两个或更多并行 / 并发的任务都完成才能继续。它们的完成顺序并不重要，但是必须都要完成，门才能打开并让流程控制继续。     只有所有的异步操作都完成了， 我们才认为它整体完成了，才能进行下一步操作    下面这个例子里， 我们试图通过两个异步请求操作，分别取得a和b的值并将它们以 a + b的形式    **（前提： 我们希望当a和b的取值都到达的时候才输出）**    ```js  var a, b;  function foo(x) {     a = x * 2;     if (a && b) {          baz();      }  }  function bar(y) {      b = y * 2;      if (a && b) {             baz();      }  }  function baz() {       console.log( a + b );  }  // ajax(..)是某个库中的某个Ajax函数  ajax( "http://some.url.1", foo );  ajax( "http://some.url.2", bar );  ```    这段代码比前面那段“链式”里的回调地狱好懂多了，但是却依然存在这一些问题：    我们使用了两个  if (a && b) { }  去分别保证baz是在a和b都到达后才执行的，试着思考一下：    **两个  if (a && b) { }  的判断条件是否可以合并到一起呢，因为这两个判断条件都试图表达同一种语意： a 和 b都到达， 能合并成一条语句的话岂不是更加简洁优雅 ？**     ##### **竞态**    这种模式传统上称为门闩，但在 JavaScript中称为竞态。    **一组异步操作，其中一个完成了， 这组异步操作便算是整体完成了**    在下面，我们希望通过异步请求的方式，取得x的值，然后执行foo或者bar，但希望只把foo或者bar其中一个函数执行一次    ```javascript  var flag = true;  function foo(x) {      if (flag) {          x = x + 1          baz(x);          flag = false       }  }  function bar(x) {       if (flag) {           x = x*2           baz(x);           flag = false       }  }  function baz( x ) {         console.log( x );  }  // ajax(..)是某个库中的某个Ajax函数  ajax( "http://some.url.1", foo );  ajax( "http://some.url.2", bar );  ```    **在这里，我们设置了一个flag， 设它的初始值为true, 这时候foo或者bar在第一次执行的时候， 是可以进入if内部的代码块并且执行baz函数的， 但在if内部的代码块结束的时候， 我们把flag的值置为false,这个时候下一个函数就无法进入代码块执行了**， 这就是回调对于竞态的处理。    #### 二、信任问题和控制反转    如上文所说，JavaScript中调用ajax API的主程序    ```javascript  //A  ajax( "..", function(..){    //C  } );  //B  ```    // A 和 // B ，以及对ajax的调用发生于现在，这在 JavaScript 主程序的直接控制之下。**但ajax里的回调C会延迟到将来发生，并且是在第三方（而不是我们的主程序）的控制下——在本例中就是函数 ajax(..) 。这种控制权的转移， 被叫做“控制反转”**，也就是把自己程序一部分的执行控制交给某个第三方。    移交控制权，后你必须默认相信`ajax(..)`会做到下面这些：    1. 不会太早调用我的回调函数    2. 不会太迟调用我的回调函数(1,2就是说会在适当的时候调用回调函数)    3. 不会调用我的回调太少次(不会少于实际应该调用的次数，比如不会漏掉函数调用)    4. 不会调用我的回调太多次(不会多于实际应该调用的次数，比如重复调用)    5. 会给我的回调提供必要的参数    6. 在我的回调失败的时候会提醒我       ......    **然而很多时候这个不确定的函数来源于它人之手，甚至来源于完全无法核实的第三方代码**，并不能确信第三方api会做到这些。    **1.调用函数过早**    我们有可能会写出一个既可能同步， 又可能异步的函数    例如下面这个极简的例子：    我试图用这段代码检查一个输入框内输入的账号是否为空， 如果不为空就用它发起请求。（注：callback无论账号是否为空都会被调用）    ```  // 注: 这是一个相当乌托邦,且省略诸多内容的函数  function login (callback) {          // 当取得的账号变量name的值为空时， 立即调用函数，此时callback同步调用）         if(!name) {             callback();             return   // name为空时在这里结束函数          }         // 当取得的账号变量name的值不为空时， 在请求成功后调用函数（此时callback异步调用）        request(\'post\', name, callback)  }  ```    **的确，这种函数的编写是公认的需要杜绝的，在英语世界里， 这种可能同步也可能异步调用的回调以及包裹它的函数， 被称作是 “Zalgo” （一种都市传说中的魔鬼）， 而编写这种函数的行为， 被称作是"release Zalgo" (将Zalgo释放了出来)**    为什么它如此可怕？ **因为函数的调用时间是不确定的，难以预料的。 没有人会喜欢这样难以掌控的代码**。    **2.调用次数过多**    《你不知道的javascript（中卷）》的例子：    作为一个公司的员工， **你需要开发一个网上商城， payWithYourMoney是你在确认购买后执行的扣费的函数， 由于公司需要对购买的数据做追踪分析， 这里需要用到一个做数据分析的第三方公司提供的analytics对象中的purchase函数。** 代码看起来像这样         ```  analytics.purchase( purchaseData, function  () {        payWithYourMoney ()  } );  ```        在这情况下**，可能我们会忽略的一个事实是： 我们已经把payWithYourMoney 的控制权完全交给了analytics.purchase函数了，这让我们的回调“任人宰割”**    然后上线后的一天， **数据分析公司的一个隐蔽的bug终于显露出来， 让其中一个原本只执行一次的payWithYourMoney执行了5次**， 这让那个网上商城的客户极为恼怒， 并投诉了你们公司。    可**你们公司也很无奈， 这个时候惊奇的发现：   payWithYourMoney的控制完全不在自己的手里 。**    后来， **为了保证只支付一次， 代码改成了这样：**    ```js  var analysisFlag  = true // 判断是否已经分析（支付）过一次了  analytics.purchase( purchaseData, function(){       if (！analysisFlag) {             payWithYourMoney ()              analysisFlag = false       }  } );  ```    但是， 这种方式虽然巧妙， **但却仍不够简洁优雅**（后文提到的Promise将改变这一点）    **而且， 在回调函数的无数“痛点”中， 它只能规避掉一个**， 如果你尝试规避掉所有的“痛点”，代码将比上面更加复杂而混乱。    **3.太晚调用或根本没有调用**    因为你失去了对回调的控制权， 你的回调可能会出现预期之外的过晚调用或者不调用的情况**（为了处理这个“痛点”你又将混入一些复杂的代码逻辑）**    **4.吞掉报错**    回调内的报错是可能被包裹回调的外部函数捕捉而不报错，**（为了处理这个“痛点”你又又又将混入一些复杂的代码逻辑）**    **5.回调根本没有被调用**    回调最大的问题是控制反转，它会导致信任链的完全断裂。正因为回调很多缺陷，ES6引入了Promise的机制。    #### 回调设计变体    回调设计存在几个变体，意在解决前面讨论的一些信任问题（不是全部）。这种试图从回调模式内部挽救它的意图是勇敢的，但却注定要失败。    有些 API 设计提供了分离回调（一个用于成功通知，一个用于出错通知）：    ````javascript  function success(data) {    console.log( data );   }   function failure(err) {    console.error( err );   }   ajax( "http://some.url.1", success, failure );   ````    在这种设计下，API 的出错处理函数 failure() 常常是可选的，如果没有提供的话，就是  假定这个错误可以吞掉。    还有一种常见的回调模式叫作“error-first 风格”（有时候也称为“Node 风格”，因为几乎所有 Node.js API 都采用这种风格）,其中回调的第一个参数保留用作错误对象（如果有的话）。如果成功的话，这个参数就会被清空 / 置假（后续的参数就是成功数据）。不过，如果产生了错误结果，那么第一个参数就会被置起 / 置真（通常就不会再传递其他结果）：    ````javascript  function response(err,data) {    // 出错？   if (err) {    console.error( err );    }    // 否则认为成功   else {    console.log( data );    }   }   ajax( "http://some.url.1", response );   ````    这两种情况下，这并没有像表面看上去那样真正解决主要的信任问题。并没有涉及阻止或过滤不想要的重复调用回调的问题。事情更糟了，因为现在你可能同时得到成功或者失败的结果，或者都没有，并且你还是不得不编码处理所有这些情况。    ## promise    “回调地狱”不是真的关于函数嵌套和它们在代码编辑器中产生的缩进。从回调函数一节我们可以知道通过回调表达程序异步和管理并发的两个主要缺陷：缺乏顺序性和可信任性。**也就是无法完美表达复杂异步代码逻辑，以及控制反转导致的可靠性问题**。    promise解决信任性问题的做法：`控制反转再反转`。它不是简单地把程序将要执行的回调传给调用方，而是希望调用方向程序自身提供调用任务何时结束的能力，然后由程序自身来决定下一步的行为。应验了 CS 的名言【所有问题都可以通过加一层中间层来解决】。Promise 就充当了一个中间层，用来【把回调造成的控制反转再反转回去】。在使用 Promise 的例子中，控制流分为了两个部分：触发异步前的逻辑通过 new传入 Promise，而异步操作完成后的逻辑则传入 Promise 的 then 接口中。通过这种方式，第一方业务和第三方库的相应逻辑都由Promise 来调用，进而在 Promise 中解决异步编程中可能出现的各种问题。    Promises逆转了这个情况，它使得我们重新获得控制权。相比传递回调给第三方函数，函数返回一个promise对象，我们可以使用它来监听函数的成功或失败。Promise 这种模式通过可信任的语义把回调作为参数传递，使得这种行为更可靠更合理。通过把回调的控制反转反转回来，我们把控制权放在了一个可信任的系统（Promise）中，这种系统的设计目的就是为了使异步编码更清晰。    在promise我们仍然使用回调，但是重要的是标准的promise机制使我们可以信任它们行为的正确性。我们不需要想办法来处理这些可靠性问题。一个promises可靠性机制中很特别的部分：一个promise的状态必须是可靠并且不可变的。        ### 什么是promise    未来值    **promise对象用于作为异步任务结果的占位符**。它代表了一个我们暂时还没获得但在未来有希望获得的未来值。Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝，所以Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成（组合），而不用关心时序或底层的结果。  另外，一旦 Promise 决议，它就永远保持在这个状态。此时它就成为了不变值（immutable   value），可以根据需求多次查看。**Promise 是一种封装和组合未来值的易于复用的机制。**    完成事件    单独的 Promise 展示了未来值的特性。但是，也可以从另外一个角度看待Promise 的决议：**一种在异步任务中作为两个或更多步骤的流程控制机制**，时序上的 this-then-that。    假定要调用一个函数 foo(..) 执行某个任务。我们不知道也不关心它的任何细节。这个函数可能立即完成任务，也可能需要一段时间才能完成。我们只需要知道 foo(..) 什么时候结束，这样就可以进行下一个任务。换句话说，我们想要通过某种方式在 foo(..) 完成的时候得到通知，以便可以继续下一步。  在典型的 JavaScript 风格中，如果需要侦听某个通知，你可能就会想到事件。因此，可以把对通知的需求重新组织为对 foo(..) 发出的一个完成事件（completion event，或continuation 事件）的侦听。    下面我们将介绍promise是如何解决回调的两个主要问题的。    ### Promise 解决信任问题    回顾一下只用回调处理异步的信任问题。把一个回调传入工具 foo(..) 时可能出现如下问题：    • 调用回调过早；    • 调用回调过晚（或不被调用）；    • 调用回调次数过少或过多；    • 未能传递所需的环境和参数；    • 吞掉可能出现的错误和异常。    Promise 的特性就是专门用来为这些问题提供一个有效的可复用的答案。    #### 调用过早    这个问题主要就是担心代码是否会引入类似 Zalgo 这样的副作用（参见上文）。在这类问题中，一个任务有时同步完成，有时异步完成，这可能会导致竞态条件。根据定义，Promise 就不必担心这种问题，因为即使是立即完成的 Promise（类似于 new Promise(function(resolve){ resolve(42); })）也无法被同步观察到。  也就是说，对一个 Promise 调用 then(..) 的时候，即使这个 Promise 已经决议，提供给then(..) 的回调也总会被异步调用。不再需要插入你自己的 setTimeout(..,0) hack，Promise 会自动防止 Zalgo 出现。    #### 调用过晚    和前面一点类似，Promise 创建对象调用 resolve(..) 或 reject(..) 时，这个 Promise 的then(..) 注册的观察回调就会被自动调度。可以确信，这些被调度的回调在下一个事件循环tick上一定会被触发。  同步查看是不可能的，所以一个同步任务链无法以这种方式运行来实现按照预期有效延迟另一个回调的发生。也就是说，一个 Promise 决议后，这个 Promise 上所有的通过then(..) 注册的回调都会在下一个事件循环上依次被立即调用。这些回调中的任意一个都无法影响或延误对其他回调的调用。    #### 回调未调用    这个问题很常见，Promise 可以通过几种途径解决。首先，没有任何东西（甚至 JavaScript 错误）能阻止 Promise 向你通知它的决议（如果它决议了的话）。如果你对一个 Promise 注册了一个完成回调和一个拒绝回调，那么 Promise在决议时总是会调用其中的一个。  当然，如果你的回调函数本身包含 JavaScript 错误，那可能就会看不到你期望的结果，但实际上回调还是被调用了。后面我们会介绍如何在回调出错时得到通知，因为就连这些错误也不会被吞掉。  但是，如果 Promise 本身永远不被决议呢？即使这样，Promise 也提供了解决方案，其使用了一种称为竞态的高级抽象机制：    ````javascript  // 用于超时一个Promise的工具  function timeoutPromise(delay) {    return new Promise( function(resolve,reject){    setTimeout( function(){    reject( "Timeout!" );    }, delay );    } );   }   // 设置foo()超时  Promise.race( [    foo(), // 试着开始foo()    timeoutPromise( 3000 ) // 给它3秒钟  ] )   .then(    function(){    // foo(..)及时完成！   },   function(err){    // 或者foo()被拒绝，或者只是没能按时完成   // 查看err来了解是哪种情况,   }   );   ````    我们可以保证一个 foo() 有一个输出信号，防止其永久挂住程序。    #### 调用次数过少或过多    根据定义，回调被调用的正确次数应该是 1。“过少”的情况就是调用 0 次，和前面解释过的“未被”调用是同一种情况。  “过多”的情况很容易解释。Promise 的定义方式使得它只能被决议一次。如果出于某种原因，Promise 创建代码试图调用 resolve(..) 或 reject(..) 多次，或者试图两者都调用，那么这个 Promise 将只会接受第一次决议，并默默地忽略任何后续调用。由于 Promise 只能被决议一次，所以任何通过 then(..) 注册的（每个）回调就只会被调  用一次。  当然，如果你把同一个回调注册了不止一次（比如 p.then(f); p.then(f);），那它被调用的次数就会和注册次数相同。    #### 未能传递参数 / 环境值    Promise 至多只能有一个决议值（完成或拒绝）。如果你没有用任何值显式决议，那么这个值就是 undefined，这是 JavaScript 常见的处理方式。但不管这个值是什么，无论当前或未来，它都会被传给所有注册的（且适当的完成或拒绝）回调。  还有一点需要清楚：如果使用多个参数调用 resovle(..) 或者 reject(..)，第一个参数之后的所有参数都会被默默忽略。如果要传递多个值，必须把它们封装在单个值中传递，比如通过一个数组或对象。    #### 吞掉错误或异常    如果拒绝一个 Promise 并给出一个理由（也就是一个出错消息），这个值就会被传给拒绝回调。不过在这里还有更多的细节。如果在 Promise 的创建过程中或在查看其决议结果过程中的任何时间点上出现了一个 JavaScript 异常错误，比如一个 TypeError 或ReferenceError，那这个异常就会被捕捉，并且会使这个 Promise 被拒绝。    举例来说：    ````javascript  var p = new Promise( function(resolve,reject){    foo.bar(); // foo未定义，所以会出错！   resolve( 42 ); // 永远不会到达这里 :(   } );   p.then(    function fulfilled(){    // 永远不会到达这里 :(    },    function rejected(err){    // err将会是一个TypeError异常对象来自foo.bar()这一行   }   );   ````    foo.bar() 中发生的 JavaScript 异常导致了 Promise 拒绝，你可以捕捉并对其作出响应。    如果 Promise 完成后在查看结果时（then(..) 注册的回调中）出现了 JavaScript 异常错误会怎样呢？即使这些异常不会被丢弃，但你会发现，对它们的处理方式还是有点出乎意料：    ````javascript  var p = new Promise( function(resolve,reject){    resolve( 42 );   } );   p.then(    function fulfilled(msg){    foo.bar();    console.log( msg ); // 永远不会到达这里 :(    },    function rejected(err){       // 永远也不会到达这里 :(    }   );   ````    这看起来像是 foo.bar() 产生的异常真的被吞掉了。别担心，实际上并不是这样。但是这里有一个深藏的问题，就是我们没有侦听到它。p.then(..) 调用本身返回了另外一个 promise，正是这个 promise 将会因 TypeError 异常而被拒绝。  为什么它不是简单地调用我们定义的错误处理函数呢？如果这样的话就违背了 Promise 的一条基本原则，即 Promise 一旦决议就不可再变。p 已经完成为值 42，所以之后查看 p 的决议时，并不能因为出错就把 p 再变为一个拒绝。    **Promise链中的错误捕捉**    当处理一连串异步任务步骤的时候，任何一步都可能出现错误。我们已经知道，既可以通过then方法传递第二个回调函数，也可以链式地调用一个catch方法并向其中传入错误处理回调函数。当我们仅关心整个序列步骤的成功/失败时，为每一步都指定错误处理函数就显得很冗长乏味。所以我们可以利用catch方法：    ```javascript  ...catch(error => fail("An error has occurred:" + err));  ```    如果错误在前面的任何一个promise中产生，catch方法就会捕捉到它。如果没发生任何错误，则程序流程只会无障碍地继续通过。    ### promise解决复杂异步逻辑    #### 链式调用、异步回调的串行处理    处理一连串相互关联步骤导致的金字塔噩梦，嵌套太深将形成难以维护的回调函数序列。由于promise可以链式调用，故它也是用于解决该问题的重要一步。    这种方式可以实现的关键在于以下两个 Promise 固有行为特性：    • 每次你对 Promise 调用 then(..)，它都会创建并返回一个新的 Promise，我们可以将其链接起来；    • 在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的（可链接的）Promise 就相应地决议。    • 如果完成或拒绝处理函数返回一个 Promise，它将会被展开，这样一来，不管它的决议值是什么，都会成为当前 then(..) 返回的链接 Promise 的决议值。    如果这个 Promise 链中的某个步骤出错了怎么办？错误和异常是基于每个 Promise 的，这意味着可能在链的任意位置捕捉到这样的错误，而这个捕捉动作在某种程度上就相当于在这一位置将整条链“重置”回了正常运作：    ````javascript  // 步骤1：  request( "http://some.url.1/" )   // 步骤2：  .then( function(response1){    foo.bar(); // undefined，出错！   // 永远不会到达这里   return request( "http://some.url.2/?v=" + response1 );   } )   // 步骤3：  .then(    function fulfilled(response2){    // 永远不会到达这里   },    // 捕捉错误的拒绝处理函数   function rejected(err){    console.log( err );    // 来自foo.bar()的错误TypeError    return 42;    }   )   // 步骤4：  .then( function(msg){    console.log( msg ); // 42   } );   ````    第 2 步出错后，第 3 步的拒绝处理函数会捕捉到这个错误。拒绝处理函数的返回值（这段代码中是 42），如果有的话，会用来完成交给下一个步骤（第 4 步）的 promise，这样，这个链现在就回到了完成状态。    #### 异步回调的并行处理    在异步序列中（Promise 链），任意时刻都只能有一个异步任务正在执行——按步骤执行。但是，如果想要同时执行两个或更多步骤（也就是“并行执行”），要怎么实现呢？    **使用 Promise.all等待多个promise**    通过使用内置方法Promise.all 可以等待多个promise。这个方法将一个promise数组作为参数，然后创建一个新的promise对象，一旦数组中的promise全部被解决，这个返回的promise就会被解决，而一旦其中有一个promise失败了，那么整个新promise对象也会立刻被拒绝，并丢弃来自其他所有 promise 的全部结果。后续的回调函数接收成功值组成的数组，数组中的每一项都对应promise数组中的对应项。    #### promise竞态    Promise.all 方法等待列表中的所有promise。但如果我们只关心第一个成功（或失败）的promise，可以认识一下Promise.race方法。    Promise.race([ .. ]) 也接受单个数组参数。这个数组由一个或多个 Promise、thenable 或立即值组成。立即值之间的竞争在实践中没有太大意义，因为显然列表中的第一个会获胜，就像赛跑中有一个选手是从终点开始比赛一样！  与 Promise.all([ .. ]) 类似，一旦有任何一个 Promise 决议为完成，Promise.race([ .. ])就会完成；一旦有任何一个 Promise 决议为拒绝，它就会拒绝。    ### promise详解    语法上来说Promise是一个包含传递信息与状态的对象，拥有以下两个特点.    （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有3种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。    （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。    then() 方法在所有的 Promise 上都存在，并且接受两个参数。第一个参数是 Promise 被完成时要调用的函数，与异步操作关联的任何附加数据都会被传入这个完成函数。第二个参数则是 Promise 被拒绝时要调用的函数，与完成函数相似，拒绝函数会被传入与拒绝相关联的任何附加数据。  用这种方式实现 then() 方法的任何对象都被称为一个 thenable 。所有的 Promise 都是thenable ，反之则未必成立。  传递给 then() 的两个参数都是可选的，因此你可以监听完成与拒绝的任意组合形式。例如，研究这组 then() 调用：    ````javascript  let promise = readFile("example.txt");  promise.then(function(contents) {  // 完成  console.log(contents);  }, function(err) {  // 拒绝  console.error(err.message);  });  promise.then(function(contents) {  // 完成  console.log(contents);  });  promise.then(null, function(err) {  // 拒绝  console.error(err.message);  });  ````    这三个 then() 调用都操作在同一个 Promise 上。第一个调用同时监听了完成与失败；第二个调用只监听了完成，错误不会被报告；第三个则只监听了拒绝，并不报告成功信息。Promis 也具有一个 catch() 方法，其行为等同于只传递拒绝处理函数给 then() 。例如，以下的 catch() 与 then() 调用是功能等效的。    ````javascript  promise.catch(function(err) {  // 拒绝  console.error(err.message);  });  // 等同于：  promise.then(null, function(err) {  // 拒绝  console.error(err.message);  });  ````    #### 创建未决的 Promise    新的 Promise 使用 Promise 构造器来创建。此构造器接受单个参数：一个被称为执行器（executor ）的函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 resolve()与 reject() 的函数作为参数。 resolve() 函数在执行器成功结束时被调用，用于示意该Promise 已经准备好被决议（ resolved ），而 reject() 函数则表明执行器的操作已失败。    promise 对象的构造语法是：    ```javascript  let promise = new Promise(function(resolve, reject) {    // executor ()  });  ```    传递给 `new Promise`的函数称之为 **executor**。当 promise 被创建时，它会被自动调用。    `promise` 对象有内部属性：    - `state` —— 最初是 “pending”，然后被改为 “fulfilled” 或 “rejected”，  - `result` —— 一个任意值，最初是 `undefined`。    当 executor 完成任务时，应调用下列之一：    - `resolve(value)` —— 说明任务已经完成：    - 将 `state` 设置为 `"fulfilled"`，    - sets `result` to `value`。  - `reject(error)`—— 表明有错误发生：    - 将 `state` 设置为 `"rejected"`，    - 将 `result` 设置为 `error`。    ![](https://img.dubiqc.com/201903/07105126.png-sign)    ### promise的局限性    1： 顺序错误处理  一般情况下，我们都会忽略promise 的错误。  由于一个 Promise 链仅仅是连接到一起的成员 Promise，没有把整个链标识为一个个体的实体，这意味着没有外部方法可以用于观察可能发生的错误    2：单一值  根据定义，Promise 只能有一个完成值或一个拒绝理由。在简单的例子中，这不是什么问  题，但是在更复杂的场景中，你可能就会发现这是一种局限了    3：单决议    Promise 最本质的一个特征是：Promise 只能被决议一次（完成或拒绝）。在许多异步情况中，你只会获取一个值一次，所以这可以工作良好。但是，还有很多异步的情况适合另一种模式——一种类似于事件和 / 或数据流的模式。    > 支持多个异步值和多次决议的 方案有 rx.js ，下文将介绍。    4：惯性  假如你的代码都是基于回调写的，那么，你想改变成promise的方式， 怎么下手呢？最典型的栗子就是 ajax 请求。 假如你用的jq 封装的，那还好说，因为它默认支持promise 。但是，假如是其他的库，或者自己封装的代码，那还要先封装 request（） 方法。  5： 无法取消  一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得  这个任务悬而未决的话，你也没有办法从外部停止它的进程。  6 Promise 性能？    把基本的基于回调的异步任务链与 Promise 链中需要移动的部分数量进行比较。很显然，  Promise 进行的动作要多一些，这自然意味着它也会稍慢一些。    Promise 稍慢一些，但是作为交换，你得到的是大量内建的可信任性、对 Zalgo 的避免以及  可组合性。可能局限性实际上并不是它们的真实表现，而是你缺少发现其好处的眼光呢。    ## 生成器+promise    回调函数一节我们提到回调的顺序性问题，同步的大脑难以理解异步逻辑，Promise 链也开始提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步 JavaScript 代码。这个问题的一种更好的解决方案生成器+promise        ## rxjs                        小知识    console.log是异步的吗？    WebKit的console.log由于表现出异步行为而让很多开发者惊诧  不已。在Chrome或Safari中，以下这段代码会在控制台记录  {foo:bar}。    ```javascript  var obj = {};   console.log(obj);   obj.foo = \'bar\';   ```    怎么会这样？WebKit的console.log并没有立即拍摄对象快照，  相反，它只存储了一个指向对象的引用，然后在代码返回事件队  列时才去拍摄快照。    Node的console.log是另一回事，它是严格同步的，因此同样的  代码输出的却为{}。        [JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)    <https://segmentfault.com/q/1010000000140970>    [完全理解回调函数](http://maples7.com/2017/10/17/understand-callback/)     [事件驱动程序设计](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)    [什么是回调函数](https://www.zhihu.com/question/19801131)    [setImmediate API demo](http://jphpsf.github.io/setImmediate-shim-demo/)    [从源码看 Promise 概念与实现](https://segmentfault.com/a/1190000015171823)'},{title:"一篇文章掌握所有 vue 组件通信方法",path:"/posts/vue.html",strippedContent:" 太长不看版：    prop、slot、event 是 vue 组件通信的核心方法，全局的可以使用总线 bus 和 vuex 。祖孙组件通信为了避免 props 穿透而引入 inheritAttrs 、 $attrs 和 $listener。组件实例获取可以通过 ref 、$parent、$children，派发和广播已经废弃，可以自行实现。还可以使用自定义方法找到任意组件实例，provide/inject 依赖注入组件库使用较多，不推荐业务代码中写。    ## 什么是组件    视图按照功能，切分为若干基本单元，所得的东西就可以称为组件，而组件又可以一级一级组合而成复合组件，从而在整个应用的规模上，形成一棵倒置的组件树。一个个组件就像零散的积木，我们需要把这些积木按照一定的规则拼装起来，把而且要让它们**互相之间能进行通讯，这样才能构成一个有机的完整系统**。    不同关系的组件通信方式有所不同。    ## 组件的分类    - 纯展示型的组件，数据进，DOM出，直观明了  - 接入型组件，在 React 场景下的 container component，这种组件会跟数据层的service打交道，会包含一些跟服务器或者说数据源打交道的逻辑，container 会把数据向下传递给展示型组件  - 交互型组件，典型的例子是对于表单组件的封装和加强，大部分的组件库都是以交互型组件为主，比如说Element UI，特点是有比较复杂的交互逻辑，但是是比较通用的逻辑，强调组件的复用  - 功能型组件，以 Vue 的应用场景举例，路由的 router-view 组件、transition 组件，本身并不渲染任何内容，是一个逻辑型的东西，作为一种扩展或者是抽象机制存在    ## 前端组件化开发理念：    1. 页面上的每个 **独立的** 可视/可交互区域视为一个组件；  2. **每个组件对应一个工程目录**，组件所需的各种资源都在这个目录下**就近维护**；  3. 由于组件具有独立性，因此组件与组件之间可以 **自由组合**；  4. 页面只不过是组件的容器，负责组合组件形成功能完整的界面；  5. 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。    ## 组件的核心    一个再复杂的组件，都是由三部分组成的：prop、event、slot，它们构成了 Vue.js 组件的 API。如果你开发的是一个通用组件，那一定要事先设计好这三部分，因为组件一旦发布，后面再修改 API 就很困难了，使用者都是希望不断新增功能，修复 bug，而不是经常变更接口。如果你阅读别人写的组件，也可以从这三个部分展开，它们可以帮助你快速了解一个组件的所有功能。    #### 属性 prop    prop 定义了这个组件有哪些可配置的属性，组件的核心功能也都是它来确定的。写通用组件时，props 最好用对象的写法，这样可以针对每个属性设置类型、默认值或自定义校验属性的值，这点在组件开发中很重要，然而很多人却忽视，直接使用 props 的数组用法，这样的组件往往是不严谨的。    #### 插槽 slot    插槽 slot，它可以分发组件的内容。和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：    ```  <alert-box>    Something bad happened.  </alert-box>  ```        可能会渲染出这样的东西：    ```  Error!Something bad happended.  ```        幸好，Vue 自定义的 元素让这变得非常简单：    ```  Vue.component('alert-box', {    template: `      <div class=\"demo-alert-box\">        <strong>Error!</strong>        <slot></slot>      </div>    `  })  ```        如你所见，我们只要在需要的地方加入插槽就行了——就这么简单！    #### 自定义事件 event    两种写法：    - 在组件内部自定义事件event      ```js    <template>      <button @click=\"handleClick\">        <slot></slot>      </button>    </template>    <script>      export default {        methods: {          handleClick (event) {            this.$emit('on-click', event);          }        }      }    <\/script>    ```    通过 $emit，就可以触发自定义的事件 on-click ，在父级通过 @on-click 来监听：    ```  <i-button @on-click=\"handleClick\"></i-button>  ```        - 用事件修饰符 .native直接在父级声明      所以上面的示例也可以这样写：      ```    <i-button @click.native=\"handleClick\"></i-button>    ```     .native 是 监听组件根元素的原生事件    ## 组件的结构    在真实的应用中，组件最终会构成树形结构，就像人类社会中的家族树一样：    ![](https://img.dubiqc.com/picgo/20190318103439.png)    在树形结构里面，组件之间有几种典型的关系：父子关系、兄弟关系、祖孙关系、没有直接关系。    ![](https://img.dubiqc.com/picgo/20190318113004.png)    A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是祖孙关系（可能隔多代）。    不同关系的组件通信方式有所不同，相应地，vue 中组件之间有以下几种典型的通讯方案：    | 直接的父子关系                          | 兄弟关系 | 没有直接关系 |  | :-------------------------------------- | -------- | ------------ |  | 父组件向子组件传递数据通过prop传递      |          |              |  | 子组件传递数据给父组件通过$emit触发事件 |          |              |  |                                         |          |              |  |                                         |          |              |  |                                         |          |              |        ### 直接的父子关系：    - 父组件向子组件传递数据通过prop传递  - 子组件传递数据给父组件通过$emit触发事件  - 父组件通过 ref 直接访问子组件实例的属性和方法  - 通过`$parent` / `$children`：访问父 / 子实例    ### 祖孙关系    - $attrs和$listeners    - 利用 provide / inject ，向所有子孙后代注入依赖  - $boradcast和$dispatch      ### 没有直接关系：    - 借助于中央事件总线  event bus 进行通讯。  - 利用 vuex 进行通讯。  - 利用 cookie 和 localstorage 进行通讯。  - 利用 session 进行通讯。    另外还可以使用工具函数找到任意组件实例进行通信    无论你使用什么前端框架，组件之间的通讯都离开不以上几种方案，这些方案与具体框架无关。    ## 组件通信方式    ### **1. props和$emit**    父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发自定义事件来做到的。    ```js  Vue.component('child',{          data(){              return {                  mymessage:this.message              }          },          template:`              <div>                  <input type=\"text\" v-model=\"mymessage\" @input=\"passData(mymessage)\"> </div>          `,          props:['message'],//得到父组件传递过来的数据          methods:{              passData(val){                  //触发父组件中的事件                  this.$emit('getChildData',val)              }          }      })      Vue.component('parent',{          template:`              <div>                  <p>this is parent compoent!</p>                  <child :message=\"message\" v-on:getChildData=\"getChildData\"></child>              </div>          `,          data(){              return {                  message:'hello'              }          },          methods:{              //执行子组件触发的事件              getChildData(val){                  console.log(val)              }          }      })      var app=new Vue({          el:'#app',          template:`              <div>                  <parent></parent>              </div>          `      })  ```    在上面的例子中，有父组件parent和子组件child。     - 父组件传递了message数据给子组件，并且通过v-on绑定了一个getChildData事件来监听子组件的触发事件；   - 子组件通过props得到相关的message数据,最后通过this.$emit触发了getChildData事件。    ### 2. ref 、$parent 以及 $children    - ref：给元素或组件注册引用信息；  - $parent / $[children](https://cn.vuejs.org/v2/api/#vm-children)：访问父 / 子实例。    用 ref 来访问组件（部分代码省略）：    ```js  // component-a  export default {    data () {      return {        title: 'Vue.js'      }    },    methods: {      sayHello () {        window.alert('Hello');      }    }  }  ```        ```js  <template>    <component-a ref=\"comA\"></component-a>  </template>  <script>    export default {      mounted () {        const comA = this.$refs.comA;        console.log(comA.title);  // Vue.js        comA.sayHello();  // 弹窗      }    }  <\/script>  ```    $parent 和 $children 类似，也是基于当前上下文访问父组件或全部子组件的。     [vm.parent](https://cn.vuejs.org/v2/api/#parent)指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。    节制地使用 `$parent` 和 `$children` - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信     [vm.$children ](https://cn.vuejs.org/v2/api/#vm-children)当前实例的直接子组件。        这两种方法的弊端是，无法在跨级或兄弟间通信，比如下面的结构：    ```  // parent.vue  <component-a></component-a>  <component-b></component-b>  <component-b></component-b>  ```        我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下,是暂时无法实现的，后面会讲解到方法。    ### **3.$attrs和$listeners**    前面两种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？   如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。    ```js  Vue.component('C',{          template:`              <div>                  <input type=\"text\" v-model=\"$attrs.messagec\" @input=\"passCData($attrs.messagec)\"> </div>          `,            methods:{              passCData(val){                  //触发父组件A中的事件                  this.$emit('getCData',val)              }          }      })        Vue.component('B',{          data(){              return {                  mymessage:this.message              }          },          template:`              <div>                  <input type=\"text\" v-model=\"mymessage\" @input=\"passData(mymessage)\">                   \x3c!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --\x3e                  \x3c!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --\x3e                  <C v-bind=\"$attrs\" v-on=\"$listeners\"></C>              </div>          `,          props:['message'],//得到父组件传递过来的数据          methods:{              passData(val){                  //触发父组件中的事件                  this.$emit('getChildData',val)              }          }      })      Vue.component('A',{          template:`              <div>                  <p>this is parent compoent!</p>                  <B :messagec=\"messagec\" :message=\"message\" v-on:getCData=\"getCData\" v-on:getChildData=\"getChildData(message)\"></B>              </div>          `,          data(){              return {                  message:'hello',                  messagec:'hello c' //传递给c组件的数据              }          },          methods:{              getChildData(val){                  console.log('这是来自B组件的数据')              },              //执行C子组件触发的事件              getCData(val){                  console.log(\"这是来自C组件的数据：\"+val)              }          }      })      var app=new Vue({          el:'#app',          template:`              <div>                  <A></A>              </div>          `      })  ```    详细可参考<https://juejin.im/post/5ae4288a5188256712784787>    ### 4. provide / inject    前面几种方法，如果祖孙隔代太远就不好用了。可以使用一种无依赖的组件通信方法：Vue.js 内置的 provide / inject 接口。    provide / inject 是 Vue.js 2.2.0 版本后新增的 API，在文档中这样介绍 ：  这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。  provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。  假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件:    ```  // A.vue  export default {    provide: {      name: 'Aresn'    }  }    // B.vue  export default {    inject: ['name'],    mounted () {      console.log(this.name);  // Aresn    }  }  ```        需要注意的是：  provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。    只要一个组件使用了 provide 向下提供数据，那其下所有的子组件都可以通过 inject 来注入，不管中间隔了多少代，而且可以注入多个来自不同父级提供的数据。需要注意的是，一旦注入了某个数据，那这个组件中就不能再声明 这个数据了，因为它已经被父级占有。    provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。然后有两种场景它不能很好的解决：    - 父组件向子组件（支持跨级）传递数据；  - 子组件向父组件（支持跨级）传递数据。    这种父子（含跨级）传递数据的通信方式，Vue.js 并没有提供原生的 API 来支持，下面介绍一种在父子组件间通信的方法 dispatch 和 broadcast。    ### 5. $boradcast和$dispatch    在 Vue.js 1.x 中，提供了两个方法：`$dispatch` 和 `$broadcast` ，前者用于向上级派发事件，只要是它的父级（一级或多级以上），都可以在组件内通过 `$on` （或 events，2.x 已废弃）监听到，后者相反，是由上级向下级广播事件的。这两个方法虽然看起来很好用，但是在 Vue.js 2.x 中都废弃了，官方给出的解释是：    > 因为基于组件树结构的事件流方式有时让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。    很多开源软件都自己封装了这种方式，比如element ui和iview等。     我们可以自行实现 dispatch 和 broadcast 方法，具有以下功能：    - 在子组件调用 dispatch 方法，向上级指定的组件实例（最近的）上触发自定义事件，并传递数据，且该上级组件已预先通过 `$on` 监听了这个事件；  - 相反，在父组件调用 broadcast 方法，向下级指定的组件实例（最近的）上触发自定义事件，并传递数据，且该下级组件已预先通过 `$on` 监听了这个事件。    实现这对方法的关键点在于，如何正确地向上或向下找到对应的组件实例，并在它上面触发方法。在设计一个新功能（features）时，可以先确定这个功能的 API 是什么，也就是说方法名、参数、使用样例，确定好 API，再来写具体的代码。    因为 Vue.js 内置的方法，才是以 `$` 开头的，比如 `$nextTick`、`$emit` 等，为了避免不必要的冲突并遵循规范，这里的 dispatch 和 broadcast 方法名前不加 `$`。并且该方法可能在很多组件中都会使用，复用起见，我们封装在混合（mixins）里。那它的使用样例可能是这样的：    ```js  // 部分代码省略  import Emitter from '../mixins/emitter.js'    export default {    mixins: [ Emitter ],    methods: {      handleDispatch () {        this.dispatch();  // ①      },      handleBroadcast () {        this.broadcast();  // ②      }    }  }  ```    上例中行 ① 和行 ② 的两个方法就是在导入的混合 **emitter.js** 中定义的，这个稍后我们再讲，先来分析这两个方法应该传入什么参数。一般来说，为了跟 Vue.js 1.x 的方法一致，第一个参数应当是自定义事件名，比如 “test”，第二个参数是传递的数据，比如 “Hello, Vue.js”，但在这里，有什么问题呢？只通过这两个参数，我们没办法知道要在哪个组件上触发事件，因为自行实现的这对方法，与 Vue.js 1.x 的原生方法机理上是有区别的。上文说到，实现这对方法的关键点在于准确地**找到组件实例**。那在寻找组件实例上，我们的“惯用伎俩”就是通过遍历来匹配组件的 `name` 选项，在独立组件（库）里，每个组件的 `name` 值应当是唯一的，name 主要用于递归组件，在后面小节会单独介绍。    先来看下 **emitter.js** 的代码：    ```js  function broadcast(componentName, eventName, params) {    this.$children.forEach(child => {      const name = child.$options.name;        if (name === componentName) {        child.$emit.apply(child, [eventName].concat(params));      } else {        broadcast.apply(child, [componentName, eventName].concat([params]));      }    });  }  export default {    methods: {      dispatch(componentName, eventName, params) {        let parent = this.$parent || this.$root;        let name = parent.$options.name;          while (parent && (!name || name !== componentName)) {          parent = parent.$parent;            if (parent) {            name = parent.$options.name;          }        }        if (parent) {          parent.$emit.apply(parent, [eventName].concat(params));        }      },      broadcast(componentName, eventName, params) {        broadcast.call(this, componentName, eventName, params);      }    }  };  ```    因为是用作 mixins 导入，所以在 methods 里定义的 dispatch 和 broadcast 方法会被混合到组件里，自然就可以用 `this.dispatch` 和 `this.broadcast` 来使用。    这两个方法都接收了三个参数，第一个是组件的 `name` 值，用于向上或向下递归遍历来寻找对应的组件，第二个和第三个就是上文分析的自定义事件名称和要传递的数据。    可以看到，在 dispatch 里，通过 *while* 语句，不断向上遍历更新当前组件（即上下文为当前调用该方法的组件）的父组件实例（变量 parent 即为父组件实例），直到匹配到定义的 `componentName` 与某个上级组件的 `name` 选项一致时，结束循环，并在找到的组件实例上，调用 `$emit` 方法来触发自定义事件 `eventName`。broadcast 方法与之类似，只不过是向下遍历寻找。    来看一下具体的使用方法。有 **A.vue** 和 **B.vue** 两个组件，其中 B 是 A 的子组件，中间可能跨多级，在 A 中向 B 通信：    ```  \x3c!-- A.vue --\x3e  <template>  \t<button @click=\"handleClick\">触发事件</button>  </template>  <script>    import Emitter from '../mixins/emitter.js';        export default {      name: 'componentA',      mixins: [ Emitter ],      methods: {        handleClick () {          this.broadcast('componentB', 'on-message', 'Hello Vue.js');        }      }    }  <\/script>  // B.vue  export default {    name: 'componentB',    created () {      this.$on('on-message', this.showMessage);    },    methods: {      showMessage (text) {        window.alert(text);      }    }  }  ```    同理，如果是 B 向 A 通信，在 B 中调用 dispatch 方法，在 A 中使用 $on 监听事件即可。    以上就是自行实现的 dispatch 和 broadcast 方法，相比 Vue.js 1.x，有以下不同：    - 需要额外传入组件的 name 作为第一个参数；  - 无冒泡机制；  - 第三个参数传递的数据，只能是一个（较多时可以传入一个对象），而 Vue.js 1.x 可以传入多个参数，当然，你对 emitter.js 稍作修改，也能支持传入多个参数，只是一般场景传入一个对象足以。    ### 6.找到任意组件实例——findComponents 系列方法    前面我们已经介绍了两种组件间通信的方法：provide / inject 和 dispatch / broadcast。它们有各自的使用场景和局限，比如前者多用于子组件获取父组件的状态，后者常用于父子组件间通过自定义事件通信。    现在将介绍第 3 种组件通信方法，也就是自行实现 findComponents 系列方法，以工具函数的形式来使用，它是一系列的函数，可以说是组件通信的终极方案。findComponents 系列方法最终都是返回组件的实例，进而可以读取或调用该组件的数据和方法。    它适用于以下场景：    - 由一个组件，向上找到最近的指定组件；  - 由一个组件，向上找到所有的指定组件；  - 由一个组件，向下找到最近的指定组件；  - 由一个组件，向下找到所有指定的组件；  - 由一个组件，找到指定组件的兄弟组件。    5 个不同的场景，对应 5 个不同的函数，实现原理也大同小异。都是通过递归、遍历，找到指定组件的 `name` 选项匹配的组件实例并返回。    #### 向上找到最近的指定组件——findComponentUpward    先看代码：    ```  // assist.js  // 由一个组件，向上找到最近的指定组件  function findComponentUpward (context, componentName) {    let parent = context.$parent;    let name = parent.$options.name;      while (parent && (!name || [componentName].indexOf(name) < 0)) {      parent = parent.$parent;      if (parent) name = parent.$options.name;    }    return parent;  }  export { findComponentUpward };  ```    findComponentUpward 接收两个参数，第一个是当前上下文，比如你要基于哪个组件来向上寻找，一般都是基于当前的组件，也就是传入 `this`；第二个参数是要找的组件的 `name` 。    该方法会在 while 语句里不断向上覆盖当前的 `parent` 对象，通过判断组件（即 parent）的 name 与传入的 componentName 是否一致，直到直到最近的一个组件为止。    与 dispatch 不同的是，该方法是直接拿到组件的实例，而非通过事件通知组件。只会找到最近的一个组件实例，如果要找到全部符合要求的组件，就需要用到下面的这个方法。    #### 向上找到所有的指定组件——findComponentsUpward    代码如下：    ```  // assist.js  // 由一个组件，向上找到所有的指定组件  function findComponentsUpward (context, componentName) {    let parents = [];    const parent = context.$parent;      if (parent) {      if (parent.$options.name === componentName) parents.push(parent);      return parents.concat(findComponentsUpward(parent, componentName));    } else {      return [];    }  }  export { findComponentsUpward };  ```    与 findComponentUpward 不同的是，findComponentsUpward 返回的是一个数组，包含了所有找到的组件实例（注意函数名称中多了一个“s”）。    该方法的使用场景较少，一般只用在递归组件里面，因为这个函数是一直向上寻找父级（parent）的，只有递归组件的父级才是自身。    #### 向下找到最近的指定组件——findComponentDownward    代码如下：    ```  // assist.js  // 由一个组件，向下找到最近的指定组件  function findComponentDownward (context, componentName) {    const childrens = context.$children;    let children = null;      if (childrens.length) {      for (const child of childrens) {        const name = child.$options.name;          if (name === componentName) {          children = child;          break;        } else {          children = findComponentDownward(child, componentName);          if (children) break;        }      }    }    return children;  }  export { findComponentDownward };  ```    `context.$children` 得到的是当前组件的全部子组件，所以需要遍历一遍，找到有没有匹配到的组件 `name`，如果没找到，继续递归找每个 $children 的 $children，直到找到最近的一个为止。        #### 向下找到所有指定的组件——findComponentsDownward    如果要向下找到所有的指定组件，要用到 findComponentsDownward 函数，代码如下：    ```  // assist.js  // 由一个组件，向下找到所有指定的组件  function findComponentsDownward (context, componentName) {    return context.$children.reduce((components, child) => {      if (child.$options.name === componentName) components.push(child);      const foundChilds = findComponentsDownward(child, componentName);      return components.concat(foundChilds);    }, []);  }  export { findComponentsDownward };  ```    这个函数实现的方式有很多，这里巧妙使用 `reduce` 做累加器，并用递归将找到的组件合并为一个数组并返回，代码量较少，但理解起来稍困难。    #### 找到指定组件的兄弟组件——findBrothersComponents    代码如下：    ```  // assist.js  // 由一个组件，找到指定组件的兄弟组件  function findBrothersComponents (context, componentName, exceptMe = true) {    let res = context.$parent.$children.filter(item => {      return item.$options.name === componentName;    });    let index = res.findIndex(item => item._uid === context._uid);    if (exceptMe) res.splice(index, 1);    return res;  }  export { findBrothersComponents };  ```    相比其它 4 个函数，findBrothersComponents 多了一个参数 `exceptMe`，是否把本身除外，默认是 true。寻找兄弟组件的方法，是先获取 `context.$parent.$children`，也就是父组件的全部子组件，这里面当前包含了本身，所有也会有第三个参数 exceptMe。Vue.js 在渲染组件时，都会给每个组件加一个内置的属性 `_uid`，这个 _uid 是不会重复的，借此我们可以从一系列兄弟组件中把自己排除掉。    ###  7.事件总线（EventBus）    在Vue中可以使用`EventBus`来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。    新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。    ```js  Vue.component('brother1',{          data(){              return {                  mymessage:'hello brother1'              }          },          template:`              <div>                  <p>this is brother1 compoent!</p>                  <input type=\"text\" v-model=\"mymessage\" @input=\"passData(mymessage)\">                 </div>          `,          methods:{              passData(val){                  //触发全局事件globalEvent                  bus.$emit('globalEvent',val)                }          }      })      Vue.component('brother2',{          template:`              <div>                  <p>this is brother2 compoent!</p>                  <p>brother1传递过来的数据：{{brothermessage}}</p>              </div>          `,          data(){              return {                  mymessage:'hello brother2',                    brothermessage:''              }          },          mounted(){              //绑定全局事件globalEvent              bus.$on('globalEvent',(val)=>{                  this.brothermessage=val;              })          }      })      //中央事件总线      var bus=new Vue();        var app=new Vue({          el:'#app',          template:`              <div>                  <brother1></brother1>                  <brother2></brother2>              </div>          `      })  ```    对于全局的事件还有一处简单的写法，即利用 $root 元素：    vm.$root 是当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。    ```  this.$root.$emit('event', 'params')    // 在另一个组件内  this.$root.$on('event, function(params){})  ```    ### 8.vuex    [Vuex](https://vuex.vuejs.org/zh/) 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。当我们的应用遇到**多个组件共享状态**时，单向数据流的简洁性很容易被破坏：    - 多个视图依赖于同一状态。  - 来自不同视图的行为需要变更同一状态。    对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。    我们可以把组件的共享状态抽取出来，以一个全局单例模式管理呢。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！    另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。    这就是 Vuex 背后的基本思想，借鉴了 [Flux](https://facebook.github.io/flux/docs/overview.html)、[Redux](http://redux.js.org/) 和 [The Elm Architecture](https://guide.elm-lang.org/architecture/)。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。    ### 9. 利用 cookie 或者 localstorage 进行通讯    ![](https://img.dubiqc.com/picgo/20190318143701.png-sign)    示例代码片段：    ```  window.localStorage.setItem(\"json\",JSON.stringify({name:'金俊',age:18}));    var json=window.localStorage.getItem(\"json\");  // window.localStorage.removeItem(\"json\");  var obj=JSON.parse(json);  console.log(obj.name);  console.log(obj.age);  ```    cookie、localstorage 这些东西都可以直接用原生的 API 进行操作。    ### 10 利用 session 进行通讯    ![](https://img.dubiqc.com/picgo/20190318143723.png-sign)    参考资料：     [单页应用的数据流方案探索](https://zhuanlan.zhihu.com/p/26426054)     [前端工程——基础篇](https://github.com/fouber/blog/issues/10)     [不吹不黑聊聊前端框架--尤雨溪知乎Live整理](https://juejin.im/entry/5a064a716fb9a045117099ad)"},{title:"JavaScript基础知识",path:"/posts/JavaScript/",strippedContent:" [[toc]]    ## 类型    JavaScript 中有八种基本的类型。    - `number` 用于任何类型的数字：整数或者浮点数。  - `string` 用于字符串。一个字符串可以包含一个或多个字符，所以没有单独的单字符类型。  - `boolean` 用于 `true` 和 `false`。  - `null` 用于未知的值 —— 只有一个 `null` 值的独立类型。  - `undefined` 用于未定义的值 —— 只有一个 `undefined` 值的独立类型。  - `object` 用于更复杂的数据结构。  - `symbol` 用于唯一的标识符。  - `bigint` [没有精度和大小限制的整数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt)    ## 类型判断    ### typeof    `typeof` 运算符可以查看变量的类型。    - 两种形式：`typeof x` 或者 `typeof(x)`。  - 返回的类型的字符串，比如 `\"string\"`。  - `null` 返回 `\"object\"` —— 这是语言中的一个错误，实际上它并不是一个对象。    `typeof` 对于基本类型，除了 `null` 都可以显示正确的类型    ```js  typeof 1 // 'number'  typeof '1' // 'string'  typeof 999999999999999n // 'bigint'  typeof undefined // 'undefined'  typeof true // 'boolean'  typeof Symbol() // 'symbol'  typeof b // b 没有声明，但是还会显示 undefined  typeof` 对于对象，除了函数都会显示 `object  typeof [] // 'object'  typeof {} // 'object'  typeof console.log // 'function'  ```    ### instanceof    `instanceof` 操作符用于检测对象是否属于某个 class，同时，检测过程中也会将继承关系考虑在内。    用法：    ```javascript  obj instanceof Class  ```    如果 `obj` 隶属于 `Class` 类（或者是 `Class` 类的衍生类），表达式将返回 `true`。    举例说明：    ```javascript  class Rabbit {}  let rabbit = new Rabbit();    // rabbit 是 Rabbit 类的实例对象吗?  alert( rabbit instanceof Rabbit ); // true  ```    使用构造函数结果也是一样的：    ```javascript  // 构造函数而非 class  function Rabbit() {}    alert( new Rabbit() instanceof Rabbit ); // true  ```    内置类型 `Array`：    ```javascript  let arr = [1, 2, 3];  alert( arr instanceof Array ); // true  alert( arr instanceof Object ); // true  ```    `arr` 同时还隶属于 `Object` 类。因为从原型上来讲，`Array` 是继承自 `Object` 类的。    `instanceof` 在检测中会将原型链考虑在内，此外，还能借助静态方法 `Symbol.hasInstance` 来改善检测效果。    `obj instanceof Class` 语句的大致执行过程如下：    1. 如果提供了静态方法 `Symbol.hasInstance`，那就直接用这个方法进行检测：       ```javascript     // 假设具有 canEat 属性的对象为动物类     class Animal {       static [Symbol.hasInstance](obj) {         if (obj.canEat) return true;       }     }          let obj = { canEat: true };     alert(obj instanceof Animal); // 返回 true：调用 Animal[Symbol.hasInstance](obj)     ```    2. 大部分的类是没有 `Symbol.hasInstance` 方法的，这时会检查 `Class.prototype` 是否与 `obj` 的原型链中的任何一个原型相等。       简而言之，是这么比较的：       ```javascript     obj.__proto__ === Class.prototype     obj.__proto__.__proto__ === Class.prototype     obj.__proto__.__proto__.__proto__ === Class.prototype     ...     ```       在上一个例子中有 `Rabbit.prototype === rabbit.__proto__` 成立，所以结果是显然的。       再比如下面一个继承的例子，`rabbit` 对象同时也是父类的一个实例：       ```javascript     class Animal {}     class Rabbit extends Animal {}          let rabbit = new Rabbit();     alert(rabbit instanceof Animal); // true     // rabbit.__proto__ === Rabbit.prototype     // rabbit.__proto__.__proto__ === Animal.prototype (match!)     ```    下图展示了 `rabbit instanceof Animal` 的执行过程中，`Animal.prototype` 是如何参与比较的：    ![](https://img.dubiqc.com/201903/07113616.png)    这里还要提到一个方法 [objA.isPrototypeOf(objB)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf)，如果 `objA` 处在 `objB` 的原型链中，调用结果为 `true`。所以，`obj instanceof Class` 也可以被视作为是调用 `Class.prototype.isPrototypeOf(obj)`。    虽然有点奇葩，其实 `Class` 的构造器自身是不参与检测的！检测过程只和原型链以及 `Class.prototype` 有关。    所以，当 `prototype` 改变时，会产生意想不到的结果。    就像这样：    ```javascript  function Rabbit() {}  let rabbit = new Rabbit();    // 修改其 prototype  Rabbit.prototype = {};    // ...再也不是只兔子了！  alert( rabbit instanceof Rabbit ); // false  ```    所以，为了谨慎起见，最好避免修改 `prototype`。    ###  Object.prototype.toString    按照 [规范](https://tc39.github.io/ecma262/#sec-object.prototype.tostring) 上所讲，内置的 `toString` 方法可以从对象中提取出来，以其他值作为上下文（context）对象进行调用，调用结果取决于传入的上下文对象。    - 如果传入的是 number 类型，返回 `[object Number]`  - 如果传入的是 boolean 类型，返回 `[object Boolean]`  - 如果传入 `null`，返回 `[object Null]`  - 传入 `undefined`，返回 `[object Undefined]`  - 传入数组，返回 `[object Array]`  - …等等（例如一些自定义类型）    ````javascript  let s = Object.prototype.toString;  // toString 的内部算法会检查 this 对象，返回对应的结果。    console.log( s.call(123) ); // [object Number]  console.log( s.call(null) ); // [object Null]  console.log( s.call(alert) ); // [object Function]  console.log( s.call(123n) ); // [object BigInt]  console.log( s.call([]) ); // [object Array]  console.log( s.call({}) ); // [object Object]  console.log( s.call(true) ); // [object Boolean]  console.log( s.call(Symbol()) ); // [object Symbol]  ````    ### Symbol.toStringTag    对象的 `toString` 方法可以使用 `Symbol.toStringTag` 这个特殊的对象属性进行自定义输出。    举例说明：    ```javascript  let user = {    [Symbol.toStringTag]: \"User\"  };    alert( {}.toString.call(user) ); // [object User]  ```    大部分和环境相关的对象也有这个属性。以下输出可能因浏览器不同而异：    ```javascript  // 环境相关对象和类的 toStringTag：  alert( window[Symbol.toStringTag]); // window  alert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest    alert( {}.toString.call(window) ); // [object Window]  alert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]  ```    输出结果和 `Symbol.toStringTag`（前提是这个属性存在）一样，只不过被包裹进了 `[object ...]` 里。    这样一来，我们手头上就有了个“磕了药似的 typeof”，不仅能检测基本数据类型，就是内置对象类型也不在话下，更可贵的是还支持自定义。    所以，如果希望以字符串的形式获取内置对象类型信息，而不仅仅只是检测类型的话，可以用这个方法来替代 `instanceof`。    ### 总结    下面，来总结下大家学到的类型检测方式：    |               | 用于                                                         | 返回       |  | ------------- | ------------------------------------------------------------ | ---------- |  | `typeof`      | 基本数据类型                                                 | string     |  | `{}.toString` | 基本数据类型、内置对象以及包含 `Symbol.toStringTag` 属性的对象 | string     |  | `instanceof`  | 任意对象                                                     | true/false |    看样子，`{}.toString` 基本就是一增强版 `typeof`。    `instanceof` 在涉及多层类结构的场合中比较实用，这种情况下需要将类的继承关系考虑在内。    ## 类型转换    ### ToBoolean    转换为 boolean 类型是最为简单的一个。    逻辑操作或显式调用 `Boolean(value)` 会触发 boolean 类型转换。    转换规则如下：    - 假值，JavaScript只有六个假值 `0`、空的字符串、`null`、`undefined` 和 `NaN`、 `false`。  - 其他值变成 `true`。    注意：0 包括 0 、+0、 -0、0n、-0n    [ES10](https://juejin.im/post/5c7c8e125188256365101c34#heading-19)    ## 运行机制    生命周期    页面构建过程    事件处理    ## 数据类型    数组    对象        ## 函数    函数定义、参数    ### 隐式函数参数    函数调用时还会传递两个隐式的参数：arguments和this。    arguments参数是传递给函数的所有参数集合。无论是否有明确定义对应的形参，通过它我们都可以访问到函数的所有参数。    当调用函数时，除了显式提供的参数外，this参数也会默认地传递给函数。this参数是面向对象JavaScript编程的一个重要组成部分，代表函数调用相关联的对象。因此，通常称之为函数上下文。    ### 函数调用与this    函数的调用方式对函数内代码的执行有很大的影响，主要体现在this参数以及函数上下文是如何建立的。    我们可以通过4种方式调用一个函数，每种方式之间有一些细微差别。    -  作为一个函数(function)——skulk()，直接被调用。   -  作为一个方法(method)——ninja.skulk()，关联在一个对象上，实现面向对象编程。   -  作为一个构造函数(constructor)——new Ninja()，实例化一个新的对象。   -  通过函数的apply或者call方法——skulk.apply(ninja)或者skulk.call(ninja)。     ````javascript  function skulk(name) {}  function Ninja(name) {}    skulk('Hattori');  (function(who){ return who; })('Hattori'); 　　←---　作为函数调用    var ninja = {  　skulk: function() {}  };    ninja.skulk('Hattori'); 　　←---　作为ninja对象的一个方法调用    ninja = new Ninja('Hattori'); 　　←---　作为构造函数调用    skulk.call(ninja, 'Hattori'); 　　←---　通过call方法调用    skulk.apply(ninja, ['Hattori']); 　　←---　通过apply方法调用  ````    除了call和apply的方式外，函数调用的操作符都是函数表达式之后加一对圆括号。    #### **作为函数直接被调用**    这里我们说的函数“作为一个函数”被调用是为了区别于其他的调用方式：方法、构造函数和apply/call。如果一个函数没有作为方法、构造函数或者通过apply和call调用的话，我们就称之为作为函数被直接调用。    通过()运算符调用一个函数，且被执行的函数表达式不是作为一个对象的属性存在时，就属于这种调用类型。（当执行的函数表达式是一个对象属性时，属于接下来将要讨论的方法调用类型）这里有一些简单的示例：    ```javascript  function ninja() {};   ninja();　　←---　函数定义作为函数被调用      var samurai = function(){};   samurai();　　←---　函数表达式作为函数被调用   (function(){})()　　←---　会被立即调用的函数表达式，作为函数被调用  ```    当以这种方式调用时，函数上下文（this关键字的值）**有两种可能性：在非严格模式下，它将是全局上下文（window对象），而在严格模式下，它将是undefined**。    #### 作为方法被调用    [详见对象方法与this](/frontend/JavaScript/object.html#对象方法与this)    当一个函数被赋值给一个对象的属性，并且通过对象属性引用的方式调用函数时，函数会作为对象的方法被调用。示例如下：    ````javascript  var ninja = {};  ninja.skulk = function(){};  ninja.skulk();  ````    这种情况下函数被称为方法，如果你有面向对象编程的经历，一定会联想到是否可以在方法内部通过this访问到对象主体。这种情况下同样适用。    **当函数作为某个对象的方法被调用时，该对象会成为函数的上下文，并且在函数内部可以通过参数访问到**。这也是JavaScript实现面向对象编程的主要方式之一。（构造函数是另外一种方式，我们很快就会提到）    #### 作为构造函数被调用    当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造函数里的 this 就指向返回的这个对象，见如下代码：    ````javascript  var MyClass = function(){    this.name = 'sven';   };   var obj = new MyClass();   alert ( obj.name ); // 输出：sven   ````    但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对  象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this：    ````javascript  var MyClass = function(){    this.name = 'sven';    return { // 显式地返回一个对象   name: 'anne'    }   };   var obj = new MyClass();   alert ( obj.name ); // 输出：anne  ````    #### **使用apply和call方法调用**    JavaScript为我们提供了一种调用函数的方式，从而可以显式地指定任何对象作为函数的上下文。我们可以使用每个函数上都存在的这两种方法来完成：apply和call。    传入call 和 apply 方法的第一个参数都会被作为函数上下文，不同处在于后续的参数。apply方法只需要一个额外的参数，也就是一个包含参数值的数组；call方法则需要传入任意数量的参数值，这些参数将用作函数的实参.    #### 解决上下文问题    处理JavaScript函数上下文时可能遇到的一些问题。在回调函数中（例如事件处理器），函数上下文与预期不符，但可以使用call或apply方法绕过。还有另外两个选择：箭头函数和bind方法，在一些情况下可以更优雅地实现相同的效果。    ##### **使用箭头函数绕过函数上下文**    箭头函数不会创建自己的`this,它只会从自己的作用域链的上一层继承this`。this值是在箭头函数创建时确定的。    ````javascript  var foo = {  test: function(){   (()=>console.log(this))()  // 立即调用箭头函数  }  };    foo.test(); // foo  ````        箭头函数需要注意的：箭头函数没有 this 绑定，意味着**箭头函数内部的 this 值只能通过查找作用域链来确定**。  如果箭头函数被包含在一个非箭头函数内，那么 this 值就会与该函数的相等；否则，this 值就会是全局对象（在浏览器中是 window ，在 nodejs 中是 global ）。在全局代码中定义对象字面量，在字面量中定义箭头函数，那么箭头函数内的this指向全局window对象    ````javascript  var foo = {  test: ()=>console.log(this) // 箭头函数  }  };    foo.test(); // windows  ````    **Arrow functions VS bind**    箭头函数 `=>` 和正常函数通过 `.bind(this)` 调用有一个微妙的区别：    - `.bind(this)` 创建该函数的 “绑定版本”。  - 箭头函数 `=>` 不会创建任何绑定。该函数根本没有 `this`。在外部上下文中，`this` 的查找与普通变量搜索完全相同。    ##### **使用bind方法**    所有函数均可访问bind方法，可以创建并返回一个新函数，并绑定在传入的对象上。**不管如何调用该函数，this均被设置为传入对象本身。**被绑定的函数与原始函数行为一致，函数体一致。    调用bind方法不会修改原始函数，而是创建了一个全新的函数。    #### **小结**    - 当调用函数时，除了传入在函数定义中显式声明的参数之外，同时还传入两个隐式参数：arguments与this。    -  arguments参数是传入函数的所有参数的集合。具有length属性，表示传入参数的个数，通过arguments参数还可获取那些与函数形参不匹配的参数。在非严格模式下，arguments对象是函数参数的别名，修改arguments对象会修改函数实参，可以通过严格模式避免修改函数实参。     -  this表示函数上下文，即与函数调用相关联的对象。函数的定义方式和调用方式决定了this的取值。   - 函数的调用方式有4种。    -  作为函数调用：skulk()。     -  作为方法调用：ninja.skulk()。     -  作为构造函数调用：new Ninja()。     -  通过apply与call方法调用：skulk.apply(ninja)或skulk.call(ninja)。   - 函数的调用方式影响this的取值。    -  如果作为函数调用，在非严格模式下，this指向全局window对象；在严格模式下，this指向undefined。     -  作为方法调用，this通常指向调用的对。     -  作为构造函数调用，this指向新创建的对象。     -  通过call或apply调用，this指向call或apply的第一个参数。   -  箭头函数没有单独的this值，this在箭头函数创建时确定。   -  所有函数均可使用bind方法，创建新函数，并绑定到bind方法传入的参数上。被绑定的函数与原始函数具有一致的行为。    闭包、作用域    ## 深浅拷贝    对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个情况。    ```  let a = {    age: 1  }  let b = a  a.age = 2  console.log(b.age) // 2  ```    ### 浅拷贝    首先可以通过 `Object.assign` 。`Object.assign` 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。    ```  let a = {    age: 1  }  let b = Object.assign({}, a)  a.age = 2  console.log(b.age) // 1  ```    另外我们还可以通过展开运算符 `...` 来实现浅拷贝    ```  let a = {    age: 1  }  let b = { ...a }  a.age = 2  console.log(b.age) // 1  ```    通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了    ```  let a = {    age: 1,    jobs: {      first: 'FE'    }  }  let b = { ...a }  a.jobs.first = 'native'  console.log(b.jobs.first) // native  ```    浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。    ### 深拷贝    这个问题通常可以通过 `JSON.parse(JSON.stringify(object))` 来解决。    ```  let a = {    age: 1,    jobs: {      first: 'FE'    }  }  let b = JSON.parse(JSON.stringify(a))  a.jobs.first = 'native'  console.log(b.jobs.first) // FE  ```    但是该方法也是有局限性的：    - 会忽略 `undefined`  - 会忽略 `symbol`  - 不能序列化函数  - 不能解决循环引用的对象    ```  let obj = {    a: 1,    b: {      c: 2,      d: 3,    },  }  obj.c = obj.b  obj.e = obj.a  obj.b.c = obj.c  obj.b.d = obj.b  obj.b.e = obj.b.c  let newObj = JSON.parse(JSON.stringify(obj))  console.log(newObj)  ```    如果你有这么一个循环引用对象，你会发现并不能通过该方法实现深拷贝    在遇到函数、 `undefined` 或者 `symbol` 的时候，该对象也不能正常的序列化    ```  let a = {    age: undefined,    sex: Symbol('male'),    jobs: function() {},    name: 'yck'  }  let b = JSON.parse(JSON.stringify(a))  console.log(b) // {name: \"yck\"}  ```    你会发现在上述情况中，该方法会忽略掉函数和 `undefined` 。    但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题。    如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 `MessageChannel`    ```  function structuralClone(obj) {    return new Promise(resolve => {      const { port1, port2 } = new MessageChannel()      port2.onmessage = ev => resolve(ev.data)      port1.postMessage(obj)    })  }    var obj = {    a: 1,    b: {      c: 2    }  }    obj.b.d = obj.b    // 注意该方法是异步的  // 可以处理 undefined 和循环引用对象  const test = async () => {    const clone = await structuralClone(obj)    console.log(clone)  }  test()  ```    当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 [lodash 的深拷贝函数](https://link.juejin.im/?target=https%3A%2F%2Flodash.com%2Fdocs%23cloneDeep)。    ```  function deepClone(obj) {    function isObject(o) {      return (typeof o === 'object' || typeof o === 'function') && o !== null    }      if (!isObject(obj)) {      throw new Error('非对象')    }      let isArray = Array.isArray(obj)    let newObj = isArray ? [...obj] : { ...obj }    Reflect.ownKeys(newObj).forEach(key => {      newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]    })      return newObj  }    let obj = {    a: [1, 2, 3],    b: {      c: 2,      d: 3    }  }  let newObj = deepClone(obj)  newObj.b.c = 1  console.log(obj.b.c) // 2  ```    ## 开发者工具devtools    ## 编程思想    控制反转    中间件                            "},{title:"webpack开发与上线优化",path:"/posts/webpack-optimize.html",strippedContent:' ## webpack优化    webpack在一线开发中的优化    ## 一 、开启多核压缩 [uglifyjs-webpack-plugin](https://www.npmjs.com/package/uglifyjs-webpack-plugin)    To begin, you\'ll need to install `uglifyjs-webpack-plugin`:    ```  $ npm install uglifyjs-webpack-plugin --save-dev  ```    Then add the plugin to your `webpack` config. For example:    **webpack.config.js**    ```  const UglifyJsPlugin = require(\'uglifyjs-webpack-plugin\');     module.exports = {    optimization: {      minimizer: [new UglifyJsPlugin()],    },  };  ```    配置项    ### `parallel`    类型：`Boolean|Number` 默认：`false`    使用多进程并行运行来提高构建速度。默认并发运行数：`os.cpus().length - 1`。    > ℹ️并行化可以显着加速您的构建，因此**强烈建议**。    #### `Boolean`    启用/禁用多进程并行运行。    **webpack.config.js**    ```js  const os = require(\'os\')   //引入os  module.exports = {    optimization: {      minimizer: [        new UglifyJsPlugin({         // parallel: true,    //默认系统核数减一            parallel： os.cpus().length  //配置为cpu数        }),      ],    },  };  ```    另一个老牌 多核插件[webpack-parallel-uglify-plugin](https://www.npmjs.com/package/webpack-parallel-uglify-plugin)    ## 二、监控你的面板 ：速度测量插件 [speed-measure-webpack-plugin](https://www.npmjs.com/package/speed-measure-webpack-plugin)    这个插件非常重要     ![](https://img.dubiqc.com/201903/12065359.png-sign)    ## Install    ```  npm install --save-dev speed-measure-webpack-plugin  ```    or    ```  yarn add -D speed-measure-webpack-plugin  ```    ## Requirements    SMP requires at least **Node v6**. But otherwise, accepts **all webpack** versions (1, 2, 3, and 4).    ## Usage    Change your webpack config from    ```  const webpackConfig = {    plugins: [      new MyPlugin(),      new MyOtherPlugin()    ]  }  ```    to    ```  const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");     const smp = new SpeedMeasurePlugin();     const webpackConfig = smp.wrap({    plugins: [      new MyPlugin(),      new MyOtherPlugin()    ]  });  ```    and you\'re done! SMP will now be printing timing output to the console by default.    Check out the [examples folder](https://github.com/stephencookdev/speed-measure-webpack-plugin/blob/HEAD/examples) for some more examples.        ## 三、开启通知面板 [webpack-build-notifier](https://www.npmjs.com/package/webpack-build-notifier)        ```js  // webpack.config.js  var WebpackBuildNotifierPlugin = require(\'webpack-build-notifier\');     module.exports = {    // ... snip ...    plugins: [      new WebpackBuildNotifierPlugin({        title: "My Project Webpack Build",      // 通知面板标题        logo: path.resolve("./img/favicon.png"),        suppressSuccess: true                 // 成功消息是否开启      })    ],    // ... snip ...  }    ```        ## 四、开启打包进度 [progress-bar-webpack-plugin](https://www.npmjs.com/package/progress-bar-webpack-plugin)    ![](https://img.dubiqc.com/201903/13170029.png)    ### Installation    ```  npm i -D progress-bar-webpack-plugin  ```    ### Usage    Include the following in your Webpack config.    ```  var ProgressBarPlugin = require(\'progress-bar-webpack-plugin\');     ...     plugins: [    new ProgressBarPlugin()  ]  ```        ## 五、开发面版更清晰 [webpack-dashboard](https://www.npmjs.com/package/webpack-dashboard)    Webpack dev服务器的CLI仪表板    ### 这是怎么回事？    使用webpack时，特别是对于开发服务器，您可能习惯于看到如下内容：    ![](https://img.dubiqc.com/201903/13165951.png-sign)    这很酷，但它主要是噪音和滚动，而不是超级有用。这个插件改变了这一点。现在当你运行你的开发服务器时，你基本上在NASA工作：    ![](https://img.dubiqc.com/201903/13170007.png-sign)    ### 安装    ```  npm install webpack-dashboard --save-dev  ```    ### 使用    **webpack-dashboard@^2.1.1需要Node 8或更高版本。**以前的版本支持到节点6。        First, import the plugin and add it to your webpack config, or apply it to your compiler:    ```  // Import the plugin:  var DashboardPlugin = require("webpack-dashboard/plugin");     // If you aren\'t using express, add it to your webpack configs plugins section:  plugins: [new DashboardPlugin()];     // If you are using an express based dev server, add it with compiler.apply  compiler.apply(new DashboardPlugin());  ```    If using a custom port, the port number must be included in the options object here, as well as passed using the -p flag in the call to webpack-dashboard. See how below:    ```  plugins: [new DashboardPlugin({ port: 3001 })];  ```    在最新版本中，您可以运行您的应用程序，并`webpack-dashboard`独立运行（通过安装`npm install webpack-dashboard -g`）或从您的运行webpack-dashboard `package.json`。因此，如果您的dev服务器启动脚本先前看起来像：    ```  "scripts": {      "dev": "node index.js"  }  ```    您可以将其更改为：    ```  "scripts": {      "dev": "webpack-dashboard -- node index.js"  }  ```    现在你可以像平常一样运行你的启动脚本        ## 六、开启窗口标题 [node-bash-title](https://www.npmjs.com/package/node-bash-title)    一个NodeJS库，用于更改BASH shell的标题。在开发中有用：命名您的bash屏幕并显示错误或信息消息。你甚至可以使用uni-code🍻    ![screeenshot](https://cloud.githubusercontent.com/assets/582533/20051424/3caa15b6-a4cf-11e6-8ce3-642523998a04.png)    ## Install    ```bash    npm install node-bash-title --save  ```    or    ```bash    yarn add node-bash-title  ```    ## Usage (in Node)    ```js    const setTitle = require(\'node-bash-title\');    setTitle(\'🍻  Server\');  ```    ## Usage (in NPM scripts)    ```json   "scripts": {      "start": "set-bash-title server && node server/app.js"    },  ```    ## Keywords    七、窗口打印更直接        上线阶段：    ## 一、es6不需要编译吗    let a =6    会编译为    ```js  try{      throw 6  }catch(a){        }  ```    try 两个缺点会被垃圾回收，作用域链延长    解决方法：    ```html  <script type="module" src="./main.js"><\/script>  <script nomodule src="./main.es5.js"><\/script>  ```    配置webpack根据生成不同版本文件    再配置webpack html-plugin自动注入script    ### 垫片使用：Polyfill.io - 自动化的 JavaScript Polyfill 服务    Polyfill.io 通过分析请求头信息中的 UserAgent 实现自动加载浏览器所需的 polyfills。    Polyfill.io 有一份[默认功能列表](https://polyfill.io/v2/docs/features/#default-sets)，包括了最常见的 polyfills：`document.querySelector`、`Element.classList`、ES5 新增的 `Array` 方法、`Date.now`、ES6 中的 `Object.assign`、`Promise` 等。    你也可以通过传递 `features` 参数来自定义功能列表：    ```html  \x3c!-- 加载 Promise&fetch --\x3e  <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=Promise,fetch"><\/script>  \x3c!-- 加载所有 ES5&ES6 新特性 --\x3e  <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=es5,es6"><\/script>  ```    Polyfill.io 还提供了其他 API，具体请查阅[官方文档](https://polyfill.io/v2/docs/api)：    提高稳定性 可以自己写一套，使用can i use 第三方接口判断ua是否需要垫片        ## 前端缓存小负载    将文件放到local storage    a.js => a.***.js    a.***js=> 实际代码    使用插件 [webpack-manifest-plugin](https://www.npmjs.com/package/webpack-manifest-plugin),生成资源清单     [vue+webpack集成bowl.js实现localStorage本地缓存](http://shmy.tech/2017/01/19/vue-webpck-bowl/)     [bowl.js](https://elemefe.github.io/bowl/#/zh-cn?id=bowljs)    [localStorage的黑科技-js和css缓存机制](https://www.jianshu.com/p/0fa0bf842bbb)      相关文章    3真正的loading    ```  // webpack.config.js    const loading = {    html: \'加载中...\'  };    module.exports = {    plugins: [      new HtmlWebpackPlugin({        template: \'./src/index.html\',        filename: \'index.html\',        loading: loading      })    ]  }    // index.html    <!DOCTYPE html>  <html lang="en">  <head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>构建webpack单页应用</title>  </head>  <body>    <div id="app">      <%= htmlWebpackPlugin.options.loading.html %>    </div>      </body>  </html>  // index.js  setTimeout(()=>{    document.getElementById(\'app\').innerHTML=`<h1>hello</h1>`              },2000)  ```    ## 单页的性能    单页转多页    保证性能用直出，减少请求数量，**把runtime打到html里**    ## 分析打包结果     监控打包大小 ci     - [bundlesize](https://github.com/siddharthkp/bundlesize) 控制包的大小[CI(持续集成)](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)里用的 [size-limit](https://github.com/ai/size-limit) 防止JS库臃肿。如果您不小心添加了大量依赖项，则大小限制将引发错误    [分析打包结果](https://alexkuz.github.io/webpack-chart/)<https://alexkuz.github.io/webpack-chart/>    ## loader设置    test exculde include 提升速度 检测尾缀 干掉 除掉谁 ，这三个loader都设置，速度提升很快     **把 loader 应用的文件范围缩小**    我们在使用 loader 的时候，尽可能把 loader 应用的文件范围缩小，只在最少数必须的代码模块中去使用必要的 loader，例如 node_modules 目录下的其他依赖类库文件，基本就是直接编译好可用的代码，无须再经过 loader 处理了：    ```  rules: [     {      test: /\\.jsx?/,      include: [         path.resolve(__dirname, \'src\'),         // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理        // 通常我们需要 loader 处理的文件都是存放在 src 目录      ],      use: \'babel-loader\',    },    // ...  ],  ```    如上边这个例子，如果没有配置 `include`，所有的外部依赖模块都经过 Babel 处理的话，构建速度也是会收很大影响的。    ## 代码压缩JS CSS    webpack 4.x 版本运行时，mode 为 production 即会启动压缩 JS 代码的插件，而对于 webpack 3.x，使用压缩 JS 代码插件的方式也已经介绍过了。在生产环境中，压缩 JS 代码基本是一个必不可少的步骤，这样可以大大减小 JavaScript 的体积，相关内容这里不再赘述。    除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。    对于 HTML 文件，之前介绍的 html-webpack-plugin 插件可以帮助我们生成需要的 HTML 并对其进行压缩：    ```  module.exports = {    // ...    plugins: [      new HtmlWebpackPlugin({        filename: \'index.html\', // 配置输出文件名和路径        template: \'assets/index.html\', // 配置文件模板        minify: { // 压缩 HTML 的配置          minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码          minifyJS: true // 压缩 HTML 中出现的 JS 代码        }      }),    ],  }  ```    如上，使用 `minify` 字段配置就可以使用 HTML 压缩，这个插件是使用 [html-minifier](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fkangax%2Fhtml-minifier%23options-quick-reference) 来实现 HTML 代码压缩的，`minify` 下的配置项直接透传给 html-minifier，配置项参考 html-minifier 文档即可。    对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 css-loader，也提供了压缩 CSS 代码的功能：    ```  module.exports = {    module: {      rules: [        // ...        {          test: /\\.css/,          include: [            path.resolve(__dirname, \'src\'),          ],          use: [            \'style-loader\',            {              loader: \'css-loader\',              options: {                minimize: true, // 使用 css 的压缩功能              },            },          ],        },      ],    }  }  ```    在 css-loader 的选项中配置 `minimize` 字段为 `true` 来使用 CSS 压缩代码的功能。css-loader 是使用 [cssnano](https://link.juejin.im/?target=http%3A%2F%2Fcssnano.co%2F) 来压缩代码的，`minimize` 字段也可以配置为一个对象，来将相关配置传递给 cssnano。更多详细内容请参考 [cssnano](https://link.juejin.im/?target=http%3A%2F%2Fcssnano.co%2F) 官方文档。     webpack-parallel-uglify-plugin      uglifyjs-webpack-plugin 压缩js    ###   [happypack](https://github.com/cisen/blog/issues/153)    提高打包速度      ts-loader     ### DLLPlugin    [DLLPlugin](https://link.juejin.im/?target=https%3A%2F%2Fdoc.webpack-china.org%2Fplugins%2Fdll-plugin) 是 webpack 官方提供的一个插件，也是用来分离代码的，和 `optimization.splitChunks`（3.x 版本的是 CommonsChunkPlugin）有异曲同工之妙，之所以把 DLLPlugin 放到 webpack 构建性能优化这一部分，是因为它的配置相对繁琐，如果项目不涉及性能优化这一块，基本上使用 `optimization.splitChunks` 即可。    我们来看一下 DLLPlugin 如何使用，使用这个插件时需要额外的一个构建配置，用来打包公共的那一部分代码，举个例子，假设这个额外配置是 `webpack.dll.config.js`：    ```  module.exports = {    name: \'vendor\',    entry: [\'lodash\'], // 这个例子我们打包 lodash 作为公共类库      output: {      path: path.resolve(__dirname, "dist"),      filename: "vendor.js",      library: "vendor_[hash]" // 打包后对外暴露的类库名称    },      plugins: [      new webpack.DllPlugin({        name: \'vendor_[hash]\',        path: path.resolve(__dirname, "dist/manifest.json"), // 使用 DLLPlugin 在打包的时候生成一个 manifest 文件      })    ],  }  ```    然后就是我们正常的应用构建配置，在那个的基础上添加两个一个新的 `webpack.DllReferencePlugin`配置：    ```  module.exports = {    plugins: [      new webpack.DllReferencePlugin({        manifest: path.resolve(__dirname, \'dist/manifest.json\'),         // 指定需要用到的 manifest 文件，        // webpack 会根据这个 manifest 文件的信息，分析出哪些模块无需打包，直接从另外的文件暴露出来的内容中获取      }),    ],  }  ```    在构建的时候，我们需要优先使用 `webpack.dll.config.js` 来打包，如 `webpack -c webpack.dll.config.js --mode production`，构建后生成公共代码模块的文件 `vendor.js` 和 `manifest.json`，然后再进行应用代码的构建。    你会发现构建结果的应用代码中不包含 lodash 的代码内容，这一部分代码内容会放在 `vendor.js` 这个文件中，而你的应用要正常使用的话，需要在 HTML 文件中按顺序引用这两个代码文件，如：    ```  <script src="vendor.js"><\/script>  <script src="main.js"><\/script>  ```    作用是不是和 `optimization.splitChunks` 很相似，但是有个区别，DLLPlugin 构建出来的内容无需每次都重新构建，后续应用代码部分变更时，你不用再执行配置为 `webpack.dll.config.js` 这一部分的构建，沿用原本的构建结果即可，所以相比 `optimization.splitChunks`，使用 DLLPlugin 时，构建速度是会有显著提高的。    但是很显然，DLLPlugin 的配置要麻烦得多，并且需要关心你公共部分代码的变化，当你升级 lodash（即你的公共部分代码的内容变更）时，要重新去执行 `webpack.dll.config.js` 这一部分的构建，不然沿用的依旧是旧的构建结果，使用上并不如 `optimization.splitChunks` 来得方便。这是一种取舍，根据项目的实际情况采用合适的做法。    还有一点需要注意的是，[html-webpack-plugin](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fjantimon%2Fhtml-webpack-plugin) 并不会自动处理 DLLPlugin 分离出来的那个公共代码文件，我们需要自己处理这一部分的内容，可以考虑使用 [add-asset-html-webpack-plugin](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FSimenB%2Fadd-asset-html-webpack-plugin)，关于这一个的使用就不讲解了，详细参考官方的说明文档：[使用 add-asset-html-webpack-plugin](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FSimenB%2Fadd-asset-html-webpack-plugin%23basic-usage)。    ###  optimize-css-assets-webpack-plugin    ## 分离代码文件    关于分离 CSS 文件这个主题，之前在介绍如何搭建基本的前端开发环境时有提及，在 webpack 中使用 [minicssextract-webpack-plugin](frontend/frontend-engineering/webpack.html#css文件的代码分割) 插件即可。    先简单解释一下为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。    假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。    还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观。    因此当我们考虑更好地利用缓存来加速静态资源访问时，会尝试把一些公共资源单独分离开来，利用缓存加速，以避免重复的加载。除了公共的 CSS 文件或者图片资源等，当我们的 JS 代码文件过大的时候，也可以用代码文件拆分的办法来进行优化。    那么，如何使用 webpack 来把代码中公共使用的部分分离成为独立的文件呢？由于 webpack 4.x 和 webpack 3.x 在代码分离这一块的内容差别比较大，因而我们分别都介绍一下。    3.x 以前的版本是使用 CommonsChunkPlugin 来做代码分离的，而 webpack 4.x 则是把相关的功能包到了 `optimize.splitChunks` 中，直接使用该配置就可以实现代码分离。    我们先介绍在 webpack 4.x 中如何使用这个配置来实现代码分离。    ### webpack 4.x 的 optimization    webpack 的作者推荐直接这样简单地配置：    ```  module.exports = {    // ... webpack 配置      optimization: {      splitChunks: {        chunks: "all", // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件      },    },  }  ```    我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 commons.js 需要在入口代码之前。下面是个简单的例子：    ```  <script src="commons.js" charset="utf-8"><\/script>  <script src="entry.bundle.js" charset="utf-8"><\/script>  ```    如果你使用了 html-webpack-plugin，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果没有使用，那么你需要从 `stats` 的 `entrypoints` 属性来获取入口应该引用哪些 JS 文件，可以参考 [Node API](https://link.juejin.im/?target=https%3A%2F%2Fdoc.webpack-china.org%2Fapi%2Fnode%2F) 了解如何从 `stats` 中获取信息，或者开发一个 plugin 来处理正确引用 JS 文件这个问题。第 15 小节会介绍如何开发 webpack plugin，plugin 提供的 API 也可以正确获取到 `stats`中的数据。    之前我们提到拆分文件是为了更好地利用缓存，分离公共类库很大程度上是为了让多页面利用缓存，从而减少下载的代码量，同时，也有代码变更时可以利用缓存减少下载代码量的好处。从这个角度出发，笔者建议将公共使用的第三方类库显式地配置为公共的部分，而不是 webpack 自己去判断处理。因为公共的第三方类库通常升级频率相对低一些，这样可以避免因公共 chunk 的频繁变更而导致缓存失效。    显式配置共享类库可以这么操作：    ```  module.exports = {    entry: {      vendor: ["react", "lodash", "angular", ...], // 指定公共使用的第三方类库    },    optimization: {      splitChunks: {        cacheGroups: {          vendor: {            chunks: "initial",            test: "vendor",            name: "vendor", // 使用 vendor 入口作为公共部分            enforce: true,          },        },      },    },    // ... 其他配置  }    // 或者  module.exports = {    optimization: {      splitChunks: {        cacheGroups: {          vendor: {            test: /react|angluar|lodash/, // 直接使用 test 来做路径匹配            chunks: "initial",            name: "vendor",            enforce: true,          },        },      },    },  }    // 或者  module.exports = {    optimization: {      splitChunks: {        cacheGroups: {          vendor: {            chunks: "initial",            test: path.resolve(__dirname, "node_modules") // 路径在 node_modules 目录下的都作为公共部分            name: "vendor", // 使用 vendor 入口作为公共部分            enforce: true,          },        },      },    },  }  ```    上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 `test`来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法。    ##  进一步控制 JS 大小    [按需加载](frontend/frontend-engineering/webpack.html#lazy-loading-懒加载，chunk-是什么？)     [treeshaking](frontend/frontend-engineering/webpack.html#tree-shaking-概念详解)    ## sideEffects    这是 webpack 4.x 才具备的特性：[side-effects/README.md](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fwebpack%2Fblob%2Fmaster%2Fexamples%2Fside-effects%2FREADME.md)。    我们拿 [lodash](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Flodash%2Flodash) 举个例子。有些同学可能对 [lodash](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Flodash%2Flodash) 已经蛮熟悉了，它是一个工具库，提供了大量的对字符串、数组、对象等常见数据类型的处理函数，但是有的时候我们只是使用了其中的几个函数，全部函数的实现都打包到我们的应用代码中，其实很浪费。    webpack 的 sideEffects 可以帮助解决这个问题。现在 lodash 的 [ES 版本](https://link.juejin.im/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Flodash-es) 的 `package.json` 文件中已经有 `sideEffects: false` 这个声明了，当某个模块的 `package.json` 文件中有了这个声明之后，webpack 会认为这个模块没有任何副作用，只是单纯用来对外暴露模块使用，那么在打包的时候就会做一些额外的处理。    例如你这么使用 `lodash`：    ```  import { forEach, includes } from \'lodash-es\'    forEach([1, 2], (item) => {    console.log(item)  })    console.log(includes([1, 2, 3], 1))  ```    由于 lodash-es 这个模块的 `package.json` 文件有 `sideEffects: false` 的声明，所以 webpack 会将上述的代码转换为以下的代码去处理：    ```  import { default as forEach } from \'lodash-es/forEach\'  import { default as includes } from \'lodash-es/includes\'    // ... 其他代码  ```    最终 webpack 不会把 lodash-es 所有的代码内容打包进来，只是打包了你用到的那两个方法，这便是 sideEffects 的作用。    ## prepack    prepack-webpack-pligin    ## devtool    eval 最快    ## cache-loader        缓存,使用 [cache-loader](https://github.com/webpack-contrib/cache-loader) 来大大地加快 webpack 的编译速度。    ###css styled-components css tree-tracking 一般用在多页,单页不要用这个，单页走的是CSS Module css-loader 处理css style-loader css查到页面    mini-css-extract-plugin CSS提取到外部，轻量级CSS提取 PS:WP4不支持extract-text-webpack-plugin，可以考虑装next版本，也可以用这个mini插件    ```      const MiniCssExtractPlugin = require("mini-css-extract-plugin");      module: {          rules:[              use:[                  // 把css打到js里                  // \'style-loader\',                  // 把css提到外部css文件里                  {                      loader: MiniCssExtractPlugin.loader,                      options:{                          publicPath:\'../\'                      }                  },                  // css类名 改成modules                  {                      loader:\'css-loader\'                      // loader:\'css-loader?modules&localIndetName=[name]_[local]-[hash:base64:5]\'                  }              ]          ]      }  ```    purifycss-webpack 净化CSS,删除没有用到的CSS。要安装两个包-purifycss-webpack 和 purify-css    ```      const PurifyCSSPlugin = require(\'purifycss-webpack\');      plugins:[          // 净化css          new PurifyCSSPlugin({              // Give paths to parse for rules. These should be absolute!              paths: glob.sync(join(__dirname, \'./src/*.html\')),          })      ]  ```'},{title:"webpack速查",path:"/posts/webpack-search.html",strippedContent:" webpack 是一个模块打包工具    模块化概念<https://webpack.js.org/concepts/modules>    [模块化语法](https://webpack.js.org/api/module-methods)、[变量](https://webpack.js.org/api/module-variables)    ## webpack的正确安装姿势    安装最新node.js LTS版本    [http://nodejs.org](http://nodejs.org/)    查看node版本    ````node  node -v  ````    创建文件夹     ````  mkdir webpack-demo  ````    初始化项目    ````  npm init   npm init -y // 默认配置  ````    直接全部回车    生成package.json    ````json  {    \"name\": \"webpack-demo\",   // name不能为webpack,否则不能安装webpack    \"version\": \"1.0.0\",    \"description\": \"\",     \"private\": true, // 添加私有    \"main\": \"index.js\",   // 对外暴露，删除    \"scripts\": {      \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"    },    \"author\": \"\",    \"license\": \"ISC\",    \"devDependencies\": {      \"webpack-cli\": \"^3.2.3\"    }  }  ````    全局安装webpack    我们使用 npm 或者 yarn 来安装 webpack，可以作为一个全局的命令来使用：    ```  npm install webpack webpack-cli -g     # 或者  yarn global add webpack webpack-cli    # 然后就可以全局执行命令了  webpack --help  ```    卸载 全局webpack    `npm uninstall webpack -g                                                    `    项目内安装    ```  npm install webpack webpack-cli -D    npm install webpack webpack-cli --save-dev //等价上面  **#** 或者  yarn add webpack -D    # 项目内运行  npx webpack -v  ```    安装指定版本 webpack     npm install webpack@4.0.0  -D      查看一个包版本号    `npm info webpack`    ## 使用webpack的配置文件    项目文件夹创建webpack.config.js，否则会使用模式配置    创建src目录，在其中新建index.js     ````js  const path = require('path')       // 引入node核心模块path  module.exports = {      entry: './src/index.js',  // 打包入口      output: {             // 输出位置          filename:  'bundle.js',     // 输出文件名          path: path.resolve(__dirname, 'dist')            // 调用path模块resolve方法  __dirname表示文件所在目录路径,输出在该目录下dist目录      }  }  ````    使用其他配置文件名运行webpack    `npx webpack --config webpackconfig.js`    运行webpack    `npx webpack`    修改webpack运行命令    ````json  {    \"scripts\": {      \"bundle\": \"webpack\"  // 先寻找项目中的webpack，没有则使用全局    },  }  ````    此时 使用 `npm run bundle` 运行webpack    运行后生成 ./dist/bundle.js    在dist目录下新建index.html，引入index.js就可以正常使用    小知识： webpack-cli为webpack命令行工具    webpack官方使用指南<https://webpack.js.org/guides/getting-started>    ### 浅析webpack打包输出内容    ![](https://img.dubiqc.com/201903/09075642.png)    打包输出信息：    hash为本次打包唯一hash值    version为打包使用webpack版本    time为打包耗时    built at 为打包时间    asset为输出文件名     size为文件大小     chunks为文件及其依赖文件唯一id值    chunks name为文件对应名字    main的由来：配置文件中使用了简写，为entryp配置的main    ```js   entry: './src/index.js',  // 打包入口   // 等价于   entry： {   main:'./src/index.js'   }  ```    `Entrypoint main = bundle.js                                                             `    表示打包入口为 main入口，即bundle.js    ````js  WARNING in configuration  The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.  ````    警告表示 没有指定打包模式    默认模式为：    ````js  // webpack.config.js  module.exports = {      mode: 'production' // 默认为production，输出代码会压缩，设置为development,代码不会压缩  }  ````    ## 什么是loader    如何学习，配置项目太多，loaders和plugins特别多，是记不住所有配置的。掌握核心知识，业务场景使用中遇到问题再去查看相关文档。    webpack 中提供一种处理多种文件格式的机制，便是使用 loader。我们可以把 loader 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块。    默认识别js文件，其他格式文件需要loader。    下载一个图片命名为1.jpg到src目录    在./src/index.js中引入图片    ````  import img from './1.jpg'  conslole.log(img)  ````    安装 [file-loader](https://webpack.js.org/loaders/file-loader)    配置loader    ````js  const path = require('path')       // 引入node核心模块path  module.exports = {      mode: 'production',      entry: './src/index.js',  // 打包入口      module: {                         // 配置loader          rules:[{              test: /\\.jpg$/,              use: {                  loader: 'file-loader'              }          }]      },      output: {             // 输出位置          filename:  'bundle.js',     // 输出文件名          path: path.resolve(__dirname, 'dist')   // 调用path模块resolve方法  __dirname表示文件所在目录路径      }  }  ````    运行 npm run bundle    file-load 会将1.jpg改名复制到src下，并在js文件中返回文件地址    理论上file-load 可以配置任何静态文件    我们将图片输出到html    改写index.js    ````javascript  import img from './1.jpg'    console.log(img)  let  img1 = new Image()  img1.src = img    let root = document.getElementById('root')  root.append(img1)   ````    改写/dist/index.html    ````html  <!DOCTYPE html>  <html lang=\"en\">  <head>      <meta charset=\"UTF-8\">      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">      <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">      <title>Document</title>  </head>    <body>      <div id=\"root\"></div>  </body>  <script src=\"./bundle.js\"><\/script>  </html>  ````    浏览器打开index.html可以看见图片出现了    ![](https://img.dubiqc.com/201903/09090735.png-sign)    开发vue时会引入vue文件如下    ````js  import header from './header.vue'  ````    webpack同样不能识别，需要安装配置[vue-loader](https://vue-loader.vuejs.org/zh/)    配置教程查看<https://vue-loader.vuejs.org/zh/guide/#vue-cli>    ## 使用loader打包静态资源（图片篇）    使用占位符配置打包输出图片名    ````js  const path = require('path')         module.exports = {      mode: 'production',      entry: './src/index.js',        module: {          rules:[{              test: /\\.jpg$/,              use: {                  loader: 'file-loader',                  options: {                      //placeholder 占位符                      name: '[name].[ext]'  // 原图片名字.原后缀                  }              }          }]      },      output: {                       filename:  'bundle.js',              path: path.resolve(__dirname, 'dist')        }  }  ````    更多占位符查看[file-load文档](https://webpack.js.org/loaders/file-loader)    <https://github.com/webpack/loader-utils#interpolatename>    ### placeholders    ### `[ext]`    类型：`String` 默认：`file.extname`    目标文件/资源的文件扩展名。    ### `[hash]`     类型：`String` 默认：`'md5'`    指定生成文件内容哈希值的哈希方法。 查看下面的 [Hashes](https://github.com/webpack-contrib/file-loader#hashes)。    ### `[N]`     类型：`String` 默认：`undefined`    当前文件名按照查询参数 regExp 匹配后，获得到第 N 个匹配结果    ### `[name]`     类型：`String` 默认：`file.basename`    文件/资源的基本名称。    ### `[path]`     类型：`String` 默认：`file.dirname`    资源相对于 webpack/config context 的路径。    ### Hashes    Custom hashes can be used by specifying a hash with the following format: `[<hashType>:hash:<digestType>:<length>]`.    ### `digestType`    类型：`String` 默认：`'hex'`    The [digest](https://en.wikipedia.org/wiki/Cryptographic_hash_function) that the hash function should use. Valid values include: base26, base32, base36, base49, base52, base58, base62, base64, and hex.    ### `hashType`     类型：`String` 默认：`'md5'`    The type of hash that the has function should use. Valid values include: md5, sha1, sha256, and sha512.    ### `length`     类型：`Number` 默认：`9999`    Users may also specify a length for the computed hash.    ### Examples    The following examples show how one might use `file-loader` and what the result would be.    ```js  // bundle file  import png from 'image.png'  // webpack.config.js  {    loader: 'file-loader',    options: {      name: 'dirname/[hash].[ext]'    }  }  # result  dirname/0dcbbaa701328ae351f.png  ```    ------    ```js  // webpack.config.js  {    loader: 'file-loader',    options: {      name: '[sha512:hash:base64:7].[ext]'    }  }  # result  gdyb21L.png  ```    ------    ```js  // bundle file  import png from 'path/to/file.png'  // webpack.config.js  {    loader: 'file-loader',    options: {      name: '[path][name].[ext]?[hash]'    }  }  # result  path/to/file.png?e43b20c069c4a01867c31e98cbce33c9  ```    添加打包图片种类，配置图片输出目录    ````js     module: {          rules:[{              test: /\\.(jpg|png|gif)$/,   // 添加图片种类              use: {                  loader: 'file-loader',                  options: {                      //placeholder 占位符                      name: '[name]_[hash].[ext]'，                      outputPath: 'images/'  // 打包到dist目录下images文件夹                  }              }          }]      },  ````    更多配置查看file-loader文档    ### url-loader    类似file-loader ，多了limit配置项    安装 `npm i url-loader -D`    配置limit: 2048     如果图片大于2048bytes则打包到 images文件夹下    小于则生成base64插入html，减少网络请求提高性能    ````js     module: {          rules:[{              test: /\\.(jpg|png|gif)$/,   // 添加图片种类              use: {                  loader: 'url-loader', // 改用url-loader                  options: {                      //placeholder 占位符                      name: '[name]_[hash].[ext]'，                      outputPath: 'images/',  // 打包到dist目录下images文件夹                      limmit: 2048                  }              }          }]      },  ````    ![](https://img.dubiqc.com/201903/09095118.png-sign)    阅读[file-loader文档](https://webpack.js.org/loaders/file-loader) [中文](https://www.webpackjs.com/loaders/file-loader/)     [url-loader文档](https://webpack.js.org/loaders/url-loader)  [中文](https://www.webpackjs.com/loaders/url-loader/)    ###  image-webpack-loader    之前提及使用 file-loader 来处理图片文件，在此基础上，我们再添加一个 [image-webpack-loader](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftcoopman%2Fimage-webpack-loader) 来压缩图片文件。简单的配置如下：    ```  module.exports = {    // ...    module: {      rules: [        {          test: /.*\\.(gif|png|jpe?g|svg|webp)$/i,          use: [            {              loader: 'file-loader',              options: {}            },            {              loader: 'image-webpack-loader',              options: {                mozjpeg: { // 压缩 jpeg 的配置                  progressive: true,                  quality: 65                },                optipng: { // 使用 imagemin-optipng 压缩 png，enable: false 为关闭                  enabled: false,                },                pngquant: { // 使用 imagemin-pngquant 压缩 png                  quality: '65-90',                  speed: 4                },                gifsicle: { // 压缩 gif 的配置                  interlaced: false,                },                webp: { // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式                  quality: 75                },            },          ],        },      ],    },  }  ```    image-webpack-loader 的压缩是使用 [imagemin](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fimagemin) 提供的一系列图片压缩类库来处理的，如果需要进一步了解详细的配置，可以查看对应类库的官方文档 [usage of image-webpack-loader](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftcoopman%2Fimage-webpack-loader%23usage)。    ## 使用loader打包静态资源（样式篇上）    [本节完整代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-03%20%E4%BD%BF%E7%94%A8%20Loader%20%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%88%E6%A0%B7%E5%BC%8F%E7%AF%87%20-%20%E4%B8%8A%EF%BC%89/02-03/lesson)    安装 [css-loader](https://webpack.js.org/loaders/css-loader) [style-loader](https://webpack.js.org/loaders/style-loader) 处理css文件    ```  npm i css-loader style-loader -D  ```    css-loader处理文件依赖 style-loader挂载css到html    配置文件    ````js  const path = require('path');    module.exports = {  \tmode: 'development',  \tentry: {  \t\tmain: './src/index.js'  \t},  \tmodule: {  \t\trules: [{  \t\t\ttest: /\\.(jpg|png|gif)$/,  \t\t\tuse: {  \t\t\t\tloader: 'url-loader',  \t\t\t\toptions: {  \t\t\t\t\tname: '[name]_[hash].[ext]',  \t\t\t\t\toutputPath: 'images/',  \t\t\t\t\tlimit: 10240  \t\t\t\t}  \t\t\t}   \t\t},{  \t\t\ttest: /\\.css$/,  \t\t\tuse: [  \t\t\t\t'style-loader',   // loader执行顺序从下到上，从右到左  \t\t\t\t'css-loader',   \t\t\t]  \t\t}]  \t},  \toutput: {  \t\tfilename: 'bundle.js',  \t\tpath: path.resolve(__dirname, 'dist')  \t}  }  ````    index.js    ````js  import avatar from './avatar.jpg';  import style from './index.scss';      createAvatar();    var img = new Image();  img.src = avatar;   img.classList.add(style.avatar);  添加样式    var root = document.getElementById('root');  root.append(img);  ````            安装[scss-loader](https://webpack.js.org/loaders/sass-loader)处理scss    ```bash  npm install sass-loader node-sass  -D  ```    配置文件    ````js  const path = require('path');    module.exports = {  \tmode: 'development',  \tentry: {  \t\tmain: './src/index.js'  \t},  \tmodule: {  \t\trules: [{  \t\t\ttest: /\\.(jpg|png|gif)$/,  \t\t\tuse: {  \t\t\t\tloader: 'url-loader',  \t\t\t\toptions: {  \t\t\t\t\tname: '[name]_[hash].[ext]',  \t\t\t\t\toutputPath: 'images/',  \t\t\t\t\tlimit: 10240  \t\t\t\t}  \t\t\t}   \t\t},{  \t\t\ttest: /\\.scss$/,  \t\t\tuse: [  \t\t\t\t'style-loader',   \t\t\t\t'css-loader',   \t\t\t\t'sass-loader',     \t\t\t]  \t\t}]  \t},  \toutput: {  \t\tfilename: 'bundle.js',  \t\tpath: path.resolve(__dirname, 'dist')  \t}  }  ````     loader执行顺序从下到上，从右到左，打包scss首先使用sass-loader翻译，将css给到css-loader，最后给到style-loader挂载到页面    使用[postcss-loader](https://webpack.js.org/loaders/postcss-loader)  自动添加浏览器前缀    安装    ```bash  npm i -D postcss-loader  ```    安装插件    ```  npm i -D autoprefixer  ```     创建配置文件    **postcss.config.js**    ```js  module.exports = {    plugins: [requre('autoprefixer')]  }  ```    ````js  {  \t\t\ttest: /\\.scss$/,  \t\t\tuse: [  \t\t\t\t'style-loader',     \t\t\t\t'css-loader',   \t\t\t\t'sass-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}  ````         loader执行顺序从下到上，从右到左，打包 ,首先postcss使用autoprefixer插件，再使用sass-loader翻译，将css给到css-loader，最后给到style-loader挂载到页面    ## 使用loader打包静态资源（样式篇下）    ### css module    [css module完整代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-04%20%E4%BD%BF%E7%94%A8%20Loader%20%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%88%E6%A0%B7%E5%BC%8F%E7%AF%87%EF%BC%89/css-modules/lesson)    配置css-loader常用配置项    ````js  {  \t\t\ttest: /\\.scss$/,  \t\t\tuse: [  \t\t\t\t'style-loader',   \t\t\t\t{  \t\t\t\t\tloader: 'css-loader',  \t\t\t\t\toptions: {  \t\t\t\t\t\timportLoaders: 2,  \t\t\t\t\t\tmodules: true  \t\t\t\t\t}  \t\t\t\t},  \t\t\t\t'sass-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}  ````    importLoaders: 2     从js引入scss1文件，scss1中@import scss2，scss2文件不会再走 sass-loader和postcss-loader，直接进入css-loader    配置 importLoaders: 2 确保scss文件 都执行'sass-loader','postcss-loader'    modules: true         开启css模块化使css只在模块中有效避免全局污染    修改代码    ````js  // index.js  import avatar from './avatar.jpg';  import style from './index.scss';  import createAvatar from './createAvatar';    createAvatar();    var img = new Image();  img.src = avatar;  img.classList.add(style.avatar);    // 添加模块前缀    var root = document.getElementById('root');  root.append(img);  ````    ### iconfont    [完整代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-04%20%E4%BD%BF%E7%94%A8%20Loader%20%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%88%E6%A0%B7%E5%BC%8F%E7%AF%87%EF%BC%89/font/lesson)    在[阿里巴巴矢量图库]([https://www.iconfont.cn](https://www.iconfont.cn/))生成字体文件    本文用到字体[地址](https://github.com/jinjun1994/example/tree/master/webpack4/02-04%20%E4%BD%BF%E7%94%A8%20Loader%20%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%88%E6%A0%B7%E5%BC%8F%E7%AF%87%EF%BC%89/inconfont/font_936922_gumrsanrref)    配置 file-loader打包字体文件    ````js  module: {  \t\trules: [ {  \t\t\ttest: /\\.(eot|ttf|svg)$/,  \t\t\tuse: {  \t\t\t\tloader: 'file-loader'  \t\t\t}   \t\t}]  \t},  ````    作业：    阅读下列文档    [postcss-load](https://webpack.js.org/loaders/postcss-loader)  [scss-loader](https://webpack.js.org/loaders/scss-loader) [style-loader](https://webpack.js.org/loaders/style-loader) [css-loader](https://webpack.js.org/loaders/css-loader) [file-loader](https://webpack.js.org/loaders/file-loader)    [文件资源管理](https://webpack.js.org/guides/asset-management)    ## 使用plugins使打包更便捷    [完整代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-05%20%E4%BD%BF%E7%94%A8%20plugins%20%E8%AE%A9%E6%89%93%E5%8C%85%E6%9B%B4%E4%BE%BF%E6%8D%B7/02-05/lesson)    之前我们 /dist 目录下index.html文件是手动添加，现在配置自动生成        ### [HtmlWebpackPlugin](https://webpack.js.org/plugins/html-webpack-plugin)     Installation    ```bash  npm install --save-dev html-webpack-plugin  ```    配置    ````js  / webpack.config.js  var HtmlWebpackPlugin = require('html-webpack-plugin');  //引入插件  var path = require('path');    module.exports = {    entry: 'index.js',    output: {      path: path.resolve(__dirname, './dist'),      filename: 'index_bundle.js'    },    plugins: [new HtmlWebpackPlugin({           // 实例化插件  \t\ttemplate: 'src/index.html'          // 配置模板  \t})]     };  ````    该插件在打包结束后自动生成html文件，并把打包生成的js自动引入该html文件，配置template可以指定html模板，    plugin可以在webpack运行到某个时刻的时候，帮你做有一些事情，很像生命周期函数    ### clean-webpack-plugin    实现打包时清除上次打包文件功能    安装    ```bash  npm i clean-webpack-plugin -D  ```    ````js  / webpack.config.js  var HtmlWebpackPlugin = require('html-webpack-plugin');  //引入html-webpack-plugin  const CleanWebpackPlugin = require('clean-webpack-plugin'); // 引入clean-webpack-plugin    var path = require('path');    module.exports = {    entry: 'index.js',    output: {      path: path.resolve(__dirname, './dist'),      filename: 'index_bundle.js'    },    plugins: [new HtmlWebpackPlugin({           // 实例化插件  \t\ttemplate: 'src/index.html'          // 配置模板  \t}), new CleanWebpackPlugin(['dist'])]   // 实例化插件，配置清除目录dist  };  ````    打包流程：运行 npm run bundle后    首先清除dist目录 ，在打包，最后运行html-webpack-plugin    官网[plugin](https://webpack.js.org/plugins)    plugin很多，业务场景遇到某些需求搜索配置，再看文档使用即可    ## entry与output的基础配置    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-06%20Entry%20%E4%B8%8E%20Output%20%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/02-06/lesson)    ### entry    ````js  entry: './src/index.js'   // 等价于  entry: {  \t\tmain: './src/index.js'  \t},    output: {      path: path.resolve(__dirname, './dist'),      filename: 'bundle.js'     // 删除这行，则会打包输出 main.js    },  ````    打包多次    ````js  entry: {  \t\tmain: './src/index.js',  \t\tsub: './src/index.js'  \t},    output: {      publicPath: 'http://cnd.com.cn'  // 配置cdn地址      path: path.resolve(__dirname, './dist'),      filename: '[name].js'     // 需要使用占位符,[name]表示entry的key值    },  ````    会输出 main.js sub.js     [publiPath文档](https://webpack.js.org/configuration/output#outputpublicpath)    html-webpack-plugin 会注入 main.js,sub.js    ````html  <script type=\"text/javascript\" src=\"http://cdn.com.cn/main.js\"><\/script>  <script type=\"text/javascript\" src=\"http://cdn.com.cn/sub.js\"><\/script>  ````    作业：    查看[output文档](https://webpack.js.org/configuration/output)    [entry](https://webpack.js.org/configuration/entry-context)    [output management](https://webpack.js.org/guides/output-management)    [html-webpack-plugin](https://webpack.js.org/plugins/html-webpack-plugin)    <https://github.com/jantimon/html-webpack-plugin#options>    ## sourceMap的配置    我们先关闭sourceMap    ````js  module.exports = {  \tmode: 'development',  \tdevtool: 'none',  ````    在index.js输入 `consele.log('hellow word')`    打包打开html控制台会报错    ![](https://img.dubiqc.com/201903/10013350.png)    开启sourceMap    ````js  module.exports = {  \tmode: 'development',  \tdevtool: 'source-map',  ````        打包打开html报错如下    ![](https://img.dubiqc.com/201903/10014041.png)    sourceMap 他是一个映射关系，目标代码和源代码的映射，他知道dist目录下main.js文件 96行，实际上对应src目录下index.js第一行    ````js  module.exports = {  \tmode: 'development',  \t// development devtool: 'cheap-module-eval-source-map',    \t// production devtool: 'cheap-module-source-map',  \tdevtool: 'cheap-module-eval-source-map',  ````    [devtool文档](https://webpack.js.org/configuration/devtool)    [中文文档](https://www.webpackjs.com/configuration/devtool/)    配置sourceMap实际上配置devtool    ![](https://img.dubiqc.com/201903/10014833.png-sign)    ### 品质说明(quality)    `打包后的代码` - 将所有生成的代码视为一大块代码。你看不到相互分离的模块。    `生成后的代码` - 每个模块相互分离，并用模块名称进行注释。可以看到 webpack 生成的代码。示例：你会看到类似 `var module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42); module__WEBPACK_IMPORTED_MODULE_1__.a();`，而不是 `import {test} from \"module\"; test();`。    `转换过的代码` - 每个模块相互分离，并用模块名称进行注释。可以看到 webpack 转换前、loader 转译后的代码。示例：你会看到类似 `import {test} from \"module\"; var A = function(_test) { ... }(test);`，而不是 `import {test} from \"module\"; class A extends test {}`。    `原始源代码` - 每个模块相互分离，并用模块名称进行注释。你会看到转译之前的代码，正如编写它时。这取决于 loader 支持。    `无源代码内容` - source map 中不包含源代码内容。浏览器通常会尝试从 web 服务器或文件系统加载源代码。你必须确保正确设置 [`output.devtoolModuleFilenameTemplate`](https://www.webpackjs.com/configuration/output/#output-devtoolmodulefilenametemplate)，以匹配源代码的 url。    `（仅限行）` - source map 被简化为每行一个映射。这通常意味着每个语句只有一个映射（假设你使用这种方式）。这会妨碍你在语句级别上调试执行，也会妨碍你在每行的一些列上设置断点。与压缩后的代码组合后，映射关系是不可能实现的，因为压缩工具通常只会输出一行。    ### 对于开发环境    以下选项非常适合开发环境：    `eval` - 每个模块都使用 `eval()` 执行，并且都有 `//@ sourceURL`。此选项会非常快地构建。主要缺点是，由于会映射到转换后的代码，而不是映射到原始代码（没有从 loader 中获取 source map），所以不能正确的显示行数。    `eval-source-map` - 每个模块使用 `eval()` 执行，并且 source map 转换为 DataUrl 后添加到 `eval()` 中。初始化 source map 时比较慢，但是会在重新构建时提供比较快的速度，并且生成实际的文件。行数能够正确映射，因为会映射到原始代码中。它会生成用于开发环境的最佳品质的 source map。    `cheap-eval-source-map` - 类似 `eval-source-map`，每个模块使用 `eval()` 执行。这是 \"cheap(低开销)\" 的 source map，因为它没有生成列映射(column mapping)，只是映射行数。它会忽略源自 loader 的 source map，并且仅显示转译后的代码，就像 `eval` devtool。    `cheap-module-eval-source-map` - 类似 `cheap-eval-source-map`，并且，在这种情况下，源自 loader 的 source map 会得到更好的处理结果。然而，loader source map 会被简化为每行一个映射(mapping)。    说明：    添加 inline 会将要映射关系文件加载到js文件中，而不是生成.map文件    添加cheap只精确到行，只管业务代码自己写的代码，不管loader的，例如cheap-eval-source-map，添加module则管loader，第三方模块等的错误    eval 则不打包map文件，直接用eval输出错误映射，效率最快，但是较复杂代码不全面    开发环境下建议使用    ```js  module.exports = {  \tmode: 'development',  \tdevtool: 'cheap-module-eval-source-map',  ```    放到生产环境    ````js  module.exports = {  \tmode: 'production',  \tdevtool: 'cheap-module-source-map',  ````        sourceMap原理    ##  使用 WebpackDevServer 提升开发效率    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-08%20%E4%BD%BF%E7%94%A8%20WebpackDevServer%20%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/02-08/lesson)    实现文件更新自动打包    ### 方法一    修改script文件    ````json    // package.json      \"scripts\": {      \"watch\": \"webpack --watch\",        // 监控打包文件变化，自动打包    }  ````        ### 方法二：webpackdevServer        配置devServer    vue-cli 3 react新版都使用    ````js  // webpack.config.js  ...  \tdevServer: {  \t\tcontentBase: './dist',  // 服务器启动目录  \t\topen: true,             // 启动时自动打开浏览器，访问服务器地址  \t\tport: 8080             // 服务器端口 默认8080  \t}  ...      ````    ````json    // package.json      \"scripts\": {      \"watch\": \"webpack --watch\",              \"start\": \"webpack-dev-server\",       // 添加 devServe启动命令    }  ````    安装 devServer    ```bash  npm i webpack-dev-server -D  ```    启动    ```bash  npm run start  ```    扩展知识：devserver可以配置跨域    [文档](https://webpack.js.org/configuration/dev-server#devserverproxy)    ````js  // webpack.config.js  ...  \tdevServer: {  \t\tcontentBase: './dist',  // 服务器启动目录  \t\topen: true,             // 启动时自动打开浏览器，访问服务器地址  \t\tport: 8080 ,            // 服务器端口 默认8080          proxy: {        '/api': 'http://localhost:3000'         }  \t}  ...      ````    dist目录会放到内存中，加快速度    ### 方法三：middleware    老版本devServer不稳定，vue等脚手架使用 node server    安装 koa 或express快速搭建服务器，及webpack-dev-middleware中间件监控webpack文件变化    ```  npm i express webpack-dev-middleware -D  ```    修改package.json    ````json    // package.json      \"scripts\": {      \"server\": \"node server.js\"   // 启动命令    }  ````    修改webpack配置    ````js  output: {          piblicPath: '/',             // 添加这行确保路径正确  \t\tfilename: '[name].js',  \t\tpath: path.resolve(__dirname, 'dist')  \t}  ````    新建server.js    ````js  const express = require('express');    // 引入 express  const webpack = require('webpack');  // 引入webpack  const webpackDevMiddleware = require('webpack-dev-middleware');  const config = require('./webpack.config.js'); // 引入webpack配置文件  // 在node中直接使用webpack  // 在命令行里使用webpack  const complier = webpack(config);  // webpack编译器，运行一次就会打包代码一次    const app = express();  //创建应用    app.use(webpackDevMiddleware(complier, {       piblicPath: config.output.piblicPath  //使用之前配置的路径  })); // 使用编译器中间件，    app.listen(3000, () => {  \tconsole.log('server is running');  });  ````    运行 `npm run server`即可    没有devserver智能，比如不能自动刷新，需要配置很多东西才能达到前者效果，知道有这个方法即可    [命令行使用webpack](https://webpack.js.org/api/cli#usage-with-config-file)    [node中使用webpack](https://webpack.js.org/api/node)    作业阅读文档     [Development](https://webpack.js.org/guides/development)     [DevServer](https://webpack.js.org/configuration/dev-server)    [devtool](https://webpack.js.org/configuration/devtool)    ##   Hot Module Replacement 热模块更新    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-09%20Hot%20Module%20Replacement%20%E7%83%AD%E6%A8%A1%E5%9D%97%E6%9B%B4%E6%96%B0/02-09/lesson)    简写为 HMR    首先添加css支持    ````js  // webpack.config.js    \tmodule: {  \t\trules: [ {  \t\t\ttest: /\\.scss$/,  \t\t\tuse: [  \t\t\t\t'style-loader',   \t\t\t\t{  \t\t\t\t\tloader: 'css-loader',  \t\t\t\t\toptions: {  \t\t\t\t\t\timportLoaders: 2  \t\t\t\t\t}  \t\t\t\t},  \t\t\t\t'sass-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}, {  \t\t\ttest: /\\.css$/,           // 添加css文件支持  \t\t\tuse: [  \t\t\t\t'style-loader',  \t\t\t\t'css-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}]  \t},    ````    修改index.js    ````js  import './style.css';   var btn = document.createElement('button');  btn.innerHTML = '新增';  document.body.appendChild(btn);     btn.onclick = function() {  \tvar div = document.createElement('div');  \tdiv.innerHTML = 'item';  \tdocument.body.appendChild(div);   }  ````    添加 style.css    ````css  div:nth-of-type(odd) {  \tbackground: yellow;   // 偶数变色  }  ````    启动 devserver  `npm run start`    效果,点击生成div，偶数为黄色    ![](https://img.dubiqc.com/201903/10041005.png-sign)    然而当我们修改css代码    ```css  div:nth-of-type(odd) {  \tbackground: blue;   // 偶数变色  }  ```    devServer会自动刷新浏览器，item会消失，需要重新点击生成item才能看到效果    HMR就是模块热替换功能,会在应用程序运行过程中替换、添加或删除模块，而无需重新加载页面。这使得你可以在独立模块变更后，无需刷新整个页面，就可以更新这些模块，极大地加速了开发时间。        配置    ````js  const webpack = require('webpack');  // 引入webpack，为webpack插件  ...  devServer: {  \t\tcontentBase: './dist',  \t\topen: true,  \t\tport: 8080,  \t\thot: true,     // 开启HRM功能  \t\thotOnly: true  //即使HRM未生效也不刷新浏览器  \t},  ...  plugins: [  \t\tnew HtmlWebpackPlugin({  \t\t\ttemplate: 'src/index.html'  \t\t}),   \t\tnew CleanWebpackPlugin(['dist']),  \t\tnew webpack.HotModuleReplacementPlugin()    // 添加HRM插件  \t],  ````    配置成功，重启命令 `npm run start`    此时我们修改css代码，html页面上的item不会消失，实时更新     HRM对js的作用    我们先关闭HRM功能，注释掉配置文件即可    ````js  \t//\thot: true,     // 开启HRM功能  \t//\thotOnly: true  //即使HRM未生效也不刷新浏览器  \t//\tnew webpack.HotModuleReplacementPlugin()    // 添加HRM插件  ````            修改index.js    ````js  import counter from './counter';  import number from './number';    counter();  number();  ````    添加counter.js    ````js  function counter() {  \tvar div = document.createElement('div');  \tdiv.setAttribute('id', 'counter');  \tdiv.innerHTML = 1;  \tdiv.onclick = function() {  \t\tdiv.innerHTML = parseInt(div.innerHTML, 10) + 1  \t}  \tdocument.body.appendChild(div);  }    export default counter;  ````    添加number.js    ````js  function number() {  \tvar div = document.createElement('div');  \tdiv.setAttribute('id', 'number');  \tdiv.innerHTML = 3000;  \tdocument.body.appendChild(div);  }    export default number;  ````    ![](https://img.dubiqc.com/201903/10043101.png-sign)    当我们点击第一个div数字会+1    我们修改number.js 的`div.innerHTML = 3000;`改为其他数字，发现第一个div会重置为1    我们需要实现修改number.js不会影响第一个div    这就是HRM的功能。    我们删除刚才的注释，重新开启HRM功能。    此时我们更改number.js 的`div.innerHTML = 3000;`为其他数字，但是发现，此时第一个div不会重置为1，但是第二个dicv数字仍为3000，我们需要添加一点代码    当number变化时，number重新执行一次，counter不变    ````js  import counter from './counter';  import number from './number';    counter();  number();    if(module.hot) {                  // 如果HRM开启   \tmodule.hot.accept('./number', () => {      \t\tdocument.body.removeChild(document.getElementById('number')); //删除div  \t\tnumber();  // 重新执行number  \t})  }  ````    `module.hot.accept` 方法接受第一个参数，依赖的文件名，如果number文件发生变化，就会执行后面的函数    这样我们就实现了js中HRM功能    为什么css不需要写这段代码，其实是css-loader已经写好了    vue-loader也会写好 react是babel preset    [参考文章](https://juejin.im/post/5b363b576fb9a00e6f660f45#comment)    作业    [HRM指南](https://webpack.js.org/guides/hot-module-replacement) [中文](https://www.webpackjs.com/guides/hot-module-replacement/)    [HRMapi](https://webpack.js.org/api/hot-module-replacement)[中文](https://www.webpackjs.com/api/hot-module-replacement/)    [HRM概念](https://webpack.js.org/concepts/hot-module-replacement)[中文](https://www.webpackjs.com/concepts/hot-module-replacement/)    ## 使用 Babel 处理 ES6 语法    [所有代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-10%20Webpack%E4%B8%AD%E4%BD%BF%E7%94%A8babel%E8%A7%A3%E6%9E%90ES6%E8%AF%AD%E6%B3%95/02-10/lesson)    [bable官网](https://babeljs.io/)    打开官网 点击[set up](https://babeljs.io/setup#installation) 选择webpack     Installation    ```  npm install --save-dev babel-loader @babel/core  ```    配置js    ````bash  // webpack.config.js  module: {    rules: [      { test: /\\.js$/,          // 匹配js      exclude: /node_modules/,  // 不转换此目录下，第三方一般已经转换过了      loader: \"babel-loader\" }       ]  }  ````    添加配置文件    ```shell  npm install @babel/preset-env --save-dev  // 语法转换  ```        ```json  module: {    rules: [      { test: /\\.js$/,          // 匹配js      exclude: /node_modules/,  // 不转换此目录下，第三方一般已经转换过了      loader: \"babel-loader\",      options:{          presets: ['@babel/preset-env']     }  }  ```    低版本浏览器缺失的特性需要腻子 [@babel/polyfill](https://babeljs.io/docs/en/babel-polyfill)    安装    ```sh  npm install --save @babel/polyfill  ```    在业务代码最顶部引入即可    ````js  import \"@babel/polyfill\";  // useBuiltIns: 'usage' 开启不需要这行  ````    这样会全部引入，非常大    修改配置文件，只使用用到的特性 [文档](https://babeljs.io/docs/en/usage)    ````JS  module: {    rules: [      { test: /\\.js$/,          // 匹配js      exclude: /node_modules/,  // 不转换此目录下，第三方一般已经转换过了      loader: \"babel-loader\",      options:{          presets: [['@babel/preset-env', {      \ttargets: {          chrome: \"67\",            //兼容大于chrome67         },       \tuseBuiltIns: 'usage'    // 只打包用到的特性腻子脚本，配置这个不需要引入        }]]       }      }       ]  }  ````    业务代码 配置上面两处即可    但是组件等库代码需要使用[babel-plugin-transform-runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime)    会以闭包的形式，不会污染全局    安装    ```shell  npm install --save-dev @babel/plugin-transform-runtime  ```    ```shell  npm install --save @babel/runtime-corejs2  ```    配置    ````js  // webpack.config.js  module: {    rules: [      { test: /\\.js$/,          // 匹配js      exclude: /node_modules/,  // 不转换此目录下，第三方一般已经转换过了      loader: \"babel-loader\",      options:{  \t\"plugins\": [[\"@babel/plugin-transform-runtime\", {   \t\t\"corejs\": 2,         // 改为2 需要runtime-corejs2支持          \"helpers\": true,          \"regenerator\": true,         \"useESModules\": false  \t}]]    }      }       ]  }  ````    可以单独创建Babel配置文件  .babelrc,将webpack.config.js中的options删除，移到文件中    ````js  {  \t\"plugins\": [[\"@babel/plugin-transform-runtime\", {  \t\t\"corejs\": 2,      \"helpers\": true,      \"regenerator\": true,      \"useESModules\": false  \t}]]  }  ````        ## Webpack 实现对React框架代码的打包    [所有代码](https://github.com/jinjun1994/example/tree/master/webpack4/02-11%20Webpack%20%E5%AE%9E%E7%8E%B0%E5%AF%B9React%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%93%E5%8C%85/02-11/lesson)    首先按上节配置业务代码中的Babel    创建.babelrc文件    ```json  {  \tpresets: [  \t\t[  \t\t\t\"@babel/preset-env\", {      \t\t\t\ttargets: {  \t\t\t\t\tchrome: \"67\",  \t\t\t\t},  \t\t\t\tuseBuiltIns: 'usage'  \t\t\t}  \t\t],  \t\t\"@babel/preset-react\"  // 转换react代码  从下到上执行，不能更换顺序  \t]  }  ```    业务代码中引入腻子     ```js  // index.js  import \"@babel/polyfill\";  \t// 配置 useBuiltIns: 'usage' 时不需要引入  ```    还需要安装[react转换器](https://babeljs.io/docs/en/babel-preset-react)    ```bash  npm install --save-dev @babel/preset-react  ```        安装 react    ```  npm i react react-dom --save  ```        书写react代码    ```js  import \"@babel/polyfill\";    import React, { Component } from 'react';  import ReactDom from 'react-dom';    class App extends Component {  \trender() {  \t\treturn <div>Hello World</div>  \t}  }    ReactDom.render(<App />, document.getElementById('root'));  ```    ##  Tree Shaking 概念详解    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-01%20Tree%20Shaking%20%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/03-01/lesson)    ```js  // math.js  export const add = (a, b) => {  \tconsole.log( a + b );  }    export const minus = (a, b) => {  \tconsole.log( a - b );  }  ```    ```js  // index.js  // Tree Shaking 只支持 ES Module    import { add } from './math.js';  add(1, 2);  ```    从math.js引入add，却同时打包了minus函数    实现按需引入，webpack2.0提供了tree shaking 摇树    Tree Shaking 只支持 ES Module，因为es 静态引入，commont.js为动态引入    配置方法：    mode: 'development'默认没有tree shaking    ```js  // webpack.config.js     mode: 'development',     plugins: ...     ...  \toptimization: {        // 在plugins下面配置开启  \t\tusedExports: true    \t}  ```    ```json  // package.json  {    \"sideEffects\": false  }  ```     \"sideEffects\": false    如果开启tree shaking 不导入内容的模块，例如    ```  import \"@babel/polyfill\"  // 会在window下绑定全面变量 promise等  ```    会被抖掉，    需要设置     ```json  // package.json  {    \"sideEffects\": [\"@babel/polyfill\"]   //这样就不会抖掉该模块，值为false，则全部开启  }  ```    一般会设置    ```json  // package.json  {    \"sideEffects\": [\"*.css\"]   //这样就不会抖掉该模块，值为false，则全部开启  }  ```    mode: 'development' 模式下不会实际删除代码，只加了备注需要的代码，方便调试    改为mode: 'production' ，会自动启动tree shaking，甚至不需要配置  optimization    但是仍需要配置 sideEffects，切换模式记得更改devtool模式    [中文文档](https://webpack.docschina.org/guides/tree-shaking/)        ## 深度tree shakiing    [代码地址](https://github.com/jinjun1994/example/tree/master/webpack4/%E6%B7%B1%E5%BA%A6treeshaking)    ### 什么是Tree-shaking    所谓Tree-shaking就是‘摇’的意思，作用是把项目中没必要的模块全部抖掉，用于在不同的模块之间消除无用的代码，可列为性能优化的范畴。    Tree-shaking早期由rollup实现，后来webpack2也实现了Tree-shaking的功能，但是至今还不是很完备。至于为什么不完备，可以看一下[百度外卖的Tree-shaking原理](https://juejin.im/post/5a4dc842518825698e7279a9)    ### Tree-shading原理    Tree-shaking的本质用于消除项目一些不必要的代码。早在编译原理中就有提到DCE(dead code eliminnation)，作用是消除不可能执行的代码，它的工作是使用编辑器判断出某些代码是不可能执行的，然后清除。    Tree-shaking同样的也是消除项目中不必要的代码，但是和DCE又有略不相同。可以说是DCE的一种实现，它的主要工作是应用于模块间，在打包过程中抽出有用的部分，用于完成DCE。    Tree-shaking是依赖ES6模块静态分析的，ES6 module的特点如下：    1. 只能作为模块顶层的语句出现  2. import 的模块名只能是字符串常量  3. import binding 是 immutable的    依赖关系确定，与运行时无关，静态分析。正式因为ES6 module的这些特点，才让Tree-shaking更加流行。    主要特点还是依赖于ES6的静态分析，在编译时确定模块。如果是require，在运行时确定模块，那么将无法去分析模块是否可用，只有在编译时分析，才不会影响运行时的状态。    ### Webpack4的Tree-shaking    webpack从第2版本就开始支持Tree-shaking的功能，但是至今也并不能实现的那么完美。凡是具有副作用的模块，webpack的Tree-shaking就歇菜了。    #### 副作用    副作用在我们项目中，也同样是频繁的出现。知道函数式编程的朋友都会知道这个名词。所谓模块(这里模块可称为一个函数)具有副作用，就是说这个模块是不纯的。这里可以引入纯函数的概念。    > 对于相同的输入就有相同的输出，不依赖外部环境，也不改变外部环境。    符合上述就可以称为纯函数，不符合就是不纯的，是具有副作用的，是可能对外界造成影响的。    webpack自身的Tree-shaking不能分析副作用的模块。以lodash-es这个模块来举个例子    ```  //test.js  import _ from \"lodash-es\";    const func1 = function(value){      return _.isArray(value);  }  const func2 = function(value){      return value=null;  }    export {      func1,      func2,  }  //index.js  import {func2} from './test.js'  func2()  复制代码  ```    上述代码在test.js中引入lodash-es,在func1中使用了loadsh，并且这里不符合纯函数的概念，它是具有副作用的。func2是一个纯函数。    在index.js中只引入了func2，并且使用了func2，可见整个代码的执行是和func1是没有任何关系的。我们通过生产环境打包一下试试看(Tree-shaking只在生产环境生效)        ![img](https://user-gold-cdn.xitu.io/2019/2/15/168eeff584fcb43d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)     main.js 91.7KB，可见这个结果是符合我们的预期的，因为func1函数的副作用，webpack自身的Tree-shaking并没有检测到这里有没必要的模块。解决办法还是用的，webpack的插件系统是很强大的。    webpack没有深度js treeshaking 没有css tree shaking，scope内分析不了， 类、函数以及模块等等， treeshaking不能shaking到函数scoop内东西， 使用插件 将scoop抓出来 使webpack tree shaking增效，        ### webpack-deep-scope-plugin    webpack-deep-scope-plugin是一位中国同胞(学生)在Google夏令营，在导师Tobias带领下写的一个webpack插件。    这个插件主要用于填充webpack自身Tree-shaking的不足，通过作用域分析来消除无用的代码。            // webpack-scope-plugin  https://github.com/vincentdchan/webpack-deep-scope-analysis-plugin  https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis            [webpack 如何通过作用域分析消除无用代码](https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis)    Posted at 2018-05-25    > GSoC 2018 中，我的项目就在于给 webpack 实现深作用域分析（Deep Scope Analysis），主要还是为了改进 webpack 的 tree-shaking 工作。    ### 前言    JS 的 tree-shaking 一直是前端开发中的痛点，大家都在想尽办法减少打包的代码体积。Tree shaking 是一个帮助在不同模块之间消除无用代码的 feature。在编译原理中，我们把这项技术叫做 DCE(dead code elimination)。但是 DCE 和 tree shaking 有些许不同，按照 Tobias 的说法，tree shaking 主要应用于于模块（module）之间，用于帮助进行 DCE（webpack 的 DEC 通过 uglify 完成），rollup 的作者也曾经提到， tree shaking 是打包的过程中抽取有用的部分，别的部分像树叶一样落下，所以叫 tree shaking。    [项目地址](https://github.com/vincentdchan/webpack-deep-scope-analysis-plugin)    ### 从前    webpack 本身的 tree shaking 比较简单，主要是找一个 import 进来的变量是否在这个模块内出现过，非常简单粗暴。但是这种方式往往作用不大，因为一般人不会去 import 一个没有用到的变量。比较多的情况是可能曾经引用过，但是忘了删掉。现在的编辑器和 lint 工具都会提示你去删掉无用的变量，所以 webpack 本身的 tree shaking 功能是不够强大的。    ```javascript  import { isNumber, isNull } from 'lodash-es';      export fun1() {    // do nothing  }      export isNull(...args) {    return isNull(...args);  }  ```    在上面的例子中，变量 *isNumber* 并没有被引用到，所以会被消去。    ### 开端    在今年年初，webpack 项目下面有一个 [issue](https://github.com/webpack/webpack/issues/6264) 提到了 webpack 打包了多余的代码和模块。但是这也为优化 tree-shaking 提供了一个思路，就是找到作用域之间的关系，来进行优化。    ![img](https://user-images.githubusercontent.com/3199950/34681428-28df7576-f49c-11e7-942d-12caa6e905b8.png)    在上面的例子中，其实 *function2* 和整个 *external2* 都可以被消去，因为 *function2*并没有被 *entry* 引用到。但是目前 webpack 的机制不能做到这一点。借助于 webpack 强大的插件极致，我的插件就可以帮助 webpack 做到。    ### 我的插件做了什么    插件包括了一个作用域分析器，可以分析一个模块里面的作用域，从此我们可以得到不同作用域之间变量的引用关系。当我们知道一个作用域是否会被使用，就可以因此而推断出这个作用域做引用的其他作用域是否也会被使用。这就是作用域分析器帮助消除无用代码的原理。    ### 什么是作用域    下面的代码列举了 JS 中会**新建**一个作用域的代码：    ```javascript  // module scope start      // Block      { // <- scope start  } // <- scope end      // Class      class Foo { // <- scope start      } // <- scope end      // If else      if (true) { // <- scope start       } /* <- scope end */ else { // <- scope start      } // <- scope end      // For      for (;;) { // <- scope start  } // <- scope end      // Catch      try {      } catch (e) { // <- scope start      } // <- scope end      // Function      function() { // <- scope start  } // <- scope end      // Scope      switch() { // <- scope start  } // <- scope end      // module scope end  ```    对于 ES6 模块来说，module scope 是最底层的作用域。而对于一个模块来说，**只有 class 和 function 的作用域是可以导出到其他模块的**。所以在这张需要遍历的图里面，并不是所有的作用域都可以被当作一个独立的遍历结点，像 if-else 作用域其实是归属于父作用域的。    ### 插件的工作原理    在我们去分析作用域之间的引用关系之前，我们先需要去分析代码的作用域。代码的作用域分析建立在 AST(Abstract Syntax Tree) 之上。在这里，我借助了一个叫 [escope](https://github.com/estools/escope) 的工具。    解析完之后，其实就是图的深度遍历，找到那些作用域是会被使用到了，哪些是可以消去的。    ![img](https://diverse.space/images/tree-shaking.png)    因为这个插件可以从导出的作用域之间分析出这些导出的作用域和导入变量之间的关系，也就是说。只要知道哪些导出作用域被使用的到，那么就知道哪些导入变量被引用，那些没有被引用。    另一方面，webpack 本身是可以分析出模块之间的变量引用关系的，从 webpack 我可以得知一个模块哪些导出变量是被用到的，这是 webpack 4 的新 feature。所以我的插件 tap 上了 webpack 相应的 hook，获取这个模块中会被其他模块引用的导出变量，返回给 webpack 哪些引入的变量被用到，这样 webpack 就可以根据我的插件的信息进行更完善的 tree-shaking。    ### Edge cases    实际上，JavaScript 的分析有很多 Edge cases 会导致代码不会被消去，这里列举一些比较常见的：    同时提供一个 [Demo](https://vincentdchan.github.io/webpack-deep-scope-demo/) 来给大家尝试。    ### 根作用域的引用    ```javascript  import { isNull } from 'lodash-es';      export function scope(...args) {    return isNull(...args);  }      console.log(scope(null));  ```    在根作用域引用到的作用域不会被消除。    ### 给变量重新赋值 👎    ```javascript  import { isNull } from 'lodash-es';      var fun = 1;      fun = function scope(...args) {    return isNull(...args);  }      export { fun }  ```    因为缺少[数据流分析](https://en.wikipedia.org/wiki/Data-flow_analysis)，对变量重新赋值的作用域不会被消去。在上面的例子中，因为对 *fun* 变量进行了重新赋值，所以 *isNull* 无论如何都会被引入。    ### 纯函数调用 👍    ```javascript  // copy from rambda/es/allPass.js  import _curry1 from './internal/_curry1';  import curryN from './curryN';  import max from './max';  import pluck from './pluck';      var allPass = /*#__PURE__*/_curry1(function allPass(preds) {    return curryN(reduce(max, 0, pluck('length', preds)), function () {      var idx = 0;      var len = preds.length;      while (idx < len) {        if (!preds[idx].apply(this, arguments)) {          return false;        }        idx += 1;      }      return true;    });  });  export default allPass;  ```    如果一个匿名函数被包在一个函数调用中，那么其实这个插件是无法分析的，像上面的例子。但是如果加上了 PURE 注释的话，这个插件会把这个函数调用当作一个独立的域，所以在上述的例子中，tree-shaking 是会生效的。    ### 实际使用的过程中应该注意什么    深作用域分析原理很简单，实现起来也不复杂，但是真的要使用再实际项目的过程中，却有很多要注意的地方：    **一、必须使用 ES6 的 import/export 模块机制。**    其实整个深作用域分析都是基于 ES6 模块完成的，也就是说深作用域分析无法分析 CommonJS 和 AMD 等等模块规范。这个时候，就要求项目中引用的模块都遵循 ES6 的规范，比如使用 lodash-es 代替 lodash。另外就是要注意 babel-loader 和 TypeScript 的设置，是否会把代码转换到 ES5 语法，导致深作用域分析失效。    **二、学会使用 PURE 注释。**    由于 JS 语法的复杂程度，webpack 没有打算给 JS 实现数据流分析，所以插件是无法知道一个函数调用是否具有副作用的。所以对于一些导出模块，如果是纯的函数调用，则需要加上 `/*@__PURE__*/`注释来表明这个函数是 pure 的，这是 [Uglify](https://github.com/mishoo/UglifyJS2) 使用的方法。当然也可以使用相关的 babel 插件进行批量添加。    ### 总结    其实我这插件的实现是归根于 ES6 中良好的 import/export 语法的设计的。相信很多前端大佬都提到，就是模块的设计一定要合理。tree shaking 再强大它也只是一个编译器的工具，如果模块设计不合理，它一样会在打包的时候引入很多无用的代码。一个合理设计的模块一定能借助 tree shaking 机制只引入它需要的代码。    ## Develoment 和 Production 模式的区分打包    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-02%20Develoment%20%E5%92%8C%20Production%20%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%86%E6%89%93%E5%8C%85/03-02/lesson)    Develoment  sourcemap详细     Production   sourcemap详细  代码压缩    更换mode不方便，可以创建三个个配置文件，webpack.prod.js  、webpack.dev.js以及webpack.common.js    分别为生产环境配置文件、开发、以及公共配置文件    安装  `npm i webpack-merge -d`    ```js  // webpack.pord.js  const merge = require('webpack-merge');  const commonConfig = require('./webpack.common.js');    const prodConfig = {  \tmode: 'production',  \tdevtool: 'cheap-module-source-map'  }    module.exports = merge(commonConfig, prodConfig);  ```    ```js  // webpack.dev.js  const webpack = require('webpack');  const merge = require('webpack-merge');  const commonConfig = require('./webpack.common.js');    const devConfig = {  \tmode: 'development',  \tdevtool: 'cheap-module-eval-source-map',  \tdevServer: {  \t\tcontentBase: './dist',  \t\topen: true,  \t\tport: 8080,  \t\thot: true  \t},  \tplugins: [  \t\tnew webpack.HotModuleReplacementPlugin()  \t],  \toptimization: {  \t\tusedExports: true  \t}  }    module.exports = merge(commonConfig, devConfig);  ```    ```js  // webpack.common.js  const path = require('path');  const HtmlWebpackPlugin = require('html-webpack-plugin');  const CleanWebpackPlugin = require('clean-webpack-plugin');    module.exports = {  \tentry: {  \t\tmain: './src/index.js'  \t},  \tmodule: {  \t\trules: [{   \t\t\ttest: /\\.js$/,   \t\t\texclude: /node_modules/,   \t\t\tloader: 'babel-loader',  \t\t}, {  \t\t\ttest: /\\.(jpg|png|gif)$/,  \t\t\tuse: {  \t\t\t\tloader: 'url-loader',  \t\t\t\toptions: {  \t\t\t\t\tname: '[name]_[hash].[ext]',  \t\t\t\t\toutputPath: 'images/',  \t\t\t\t\tlimit: 10240  \t\t\t\t}  \t\t\t}   \t\t}, {  \t\t\ttest: /\\.(eot|ttf|svg)$/,  \t\t\tuse: {  \t\t\t\tloader: 'file-loader'  \t\t\t}   \t\t}, {  \t\t\ttest: /\\.scss$/,  \t\t\tuse: [  \t\t\t\t'style-loader',   \t\t\t\t{  \t\t\t\t\tloader: 'css-loader',  \t\t\t\t\toptions: {  \t\t\t\t\t\timportLoaders: 2  \t\t\t\t\t}  \t\t\t\t},  \t\t\t\t'sass-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}, {  \t\t\ttest: /\\.css$/,  \t\t\tuse: [  \t\t\t\t'style-loader',  \t\t\t\t'css-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}]  \t},  \tplugins: [  \t\tnew HtmlWebpackPlugin({  \t\t\ttemplate: 'src/index.html'  \t\t}),   \t\tnew CleanWebpackPlugin(['dist'], {  \t\t\troot: path.resolve(__dirname, '../')  \t\t})  \t],  \toutput: {  \t\tfilename: '[name].js',  \t\tpath: path.resolve(__dirname, '../dist')  \t}  }  ```    修改运行命令    ```js  // package.json  {    \"scripts\": {      \"dev\": \"webpack-dev-server --config ./build/webpack.dev.js\",      \"build\": \"webpack --config ./build/webpack.prod.js\"    }  }  ```        ##  Webpack 和 Code Splitting    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-03%20Webpack%20%E5%92%8C%20Code%20Splitting/03-03/lesson)    代码分割    举例    安装 `npm i lodash --save`    使用    ```js  // index.js  import _ from 'lodash';  console.log(_.jion(['a','b','c'],'***'))  // 此处省略十万行业务逻辑    ```    ![](https://img.dubiqc.com/201903/10080938.png)    这样会带来一个问题 打包文件会非常大，加载时间长；第二个问题，lodash文件一般不会变，但是会一块打包    解决问题：    ![](https://img.dubiqc.com/201903/11153853.png-sign)    添加入口文件配置    ```js  \tentry: {  \t\tmain: './src/index.js',          lodash: './src/lodash.js'  \t},  ```    ```js  // index.js  // import _ from 'lodash';  删除  console.log(_.jion(['a','b','c'],'***'))  // 此处省略十万行业务逻辑  ```    ```js  // lodash.js   import _ from 'lodash';    window._=_  ```    上面的方法是手动不够智能 webpack可以用插件自动分割代码    恢复index.js    ```js  // index.js  import _ from 'lodash';  console.log(_.jion(['a','b','c'],'***'))  // 此处省略十万行业务逻辑    ```    配置    ```js  // webpack.common.js    optimization: {  \t\tsplitChunks: {      //代码分割  \t\t\tchunks: 'all'  \t\t}  \t}  ```    这样就完成了同步代码分割    ### 异步代码分割    安装 异步引入语法转换器 `npm i babel-plugin-dynamic-import-webpack -D`    配置babelrc    ```json  {  \tpresets: [  \t\t[  \t\t\t\"@babel/preset-env\", {  \t\t\t\ttargets: {  \t\t\t\t\tchrome: \"67\",  \t\t\t\t},  \t\t\t\tuseBuiltIns: 'usage'  \t\t\t}  \t\t],  \t\t\"@babel/preset-react\"  \t],  \tplugins: [\"dynamic-import-webpack\"]  // 添加  }  ```    动态导入    ```js  // index.js  function getComponent() {  \treturn import('lodash').then(({ default: _ }) => {  \t\tvar element = document.createElement('div');  \t\telement.innerHTML = _.join(['Dell', 'Lee'], '-');  \t\treturn element;  \t})  }    getComponent().then(element => {  \tdocument.body.appendChild(element);  });    // 代码分割，和webpack无关  // webpack中实现代码分割，两种方式  // 1. 同步代码： 只需要在webpack.common.js中做optimization的配置即可  // 2. 异步代码(import): 异步代码，无需做任何配置，会自动进行代码分割，放置到新的文件中  ```    ## SplitChunksPlugin 配置参数详解    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-04%20SplitChunksPlugin%20%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/03-04/lesson)    代码分割底层使用SplitChunksPlugin    [`SplitChunksPlugin`](https://webpack.docschina.org/plugins/split-chunks-plugin/) 插件可以将公共的依赖模块提取到已有的 entry chunk 中，或者提取到一个新生成的 chunk。    ### 更改打包文件名    更换使用官方异步引入[语法转换器](https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import)    ```  npm install --save-dev @babel/plugin-syntax-dynamic-import  ```    配置    ```json  {    \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"]  }  ```    修改文件名写法    ```js   // index.js   function getComponent() {   \treturn import(/* webpackChunkName:\"lodash\" */ 'lodash').then(({ default: _ }) => {   \t\tvar element = document.createElement('div');  \t\telement.innerHTML = _.join(['Dell', 'Lee'], '-');   \t\treturn element;   \t})   }     getComponent().then(element => {   \tdocument.body.appendChild(element);   });   //使用魔法注释  /* webpackChunkName:\"lodash\" */ 'lodash'  ```    这样打包的名字为： vendors~lodash.js    配置[split-chunks-plugin](https://webpack.js.org/plugins/split-chunks-plugin)    ```js  // webpack.common.js    optimization: {  \t\tsplitChunks: {      //代码分割  \t\t\tchunks: 'all',              cacheGroups: {                  vendors: false,                  default:false              }  \t\t}  \t}  ```    配置完 打包名字为 loadsh.js    同步异步代码分割都会被splitChunks配置影响    如果不配置会使用默认配置    ```JS  splitChunks: {  }  ```    等价于    ```JS  // webpack.common.js    module.exports = {    //...    optimization: {      splitChunks: {        chunks: 'async',   // 只对异步引入代码生效 all ：都分割。同步会进入cacheGroups流程        minSize: 30000,   //大于30kb才分割 ，同步代码往下走cacheGroups流程        maxSize: 0,       //二次代码分割临界值，一般不配置        minChunks: 1,    //最小Chunks引入次数        maxAsyncRequests: 5,  // 最大并行请求数量        maxInitialRequests: 3,  // 入口处最大并行请求数        automaticNameDelimiter: '~', // 组合文件连接符        name: true,   //cacheGroups文件名有效        cacheGroups: {          vendors: {                           // 文件组            test: /[\\\\/]node_modules[\\\\/]/,   // node模块            priority: -10，                   //组匹配优先级            filename: 'vendors.js',               },          default: {                          //不属于node模块            minChunks: 2,            priority: -20,            reuseExistingChunk: true,       // 忽略已打包文件            filename: 'common.js'          }        }      }    }  };  ```    完整配置阅读[split-chunks-plugin](https://webpack.js.org/plugins/split-chunks-plugin)    ##  Lazy Loading 懒加载，Chunk 是什么？    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-05%20Lazy%20Loading%20%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%8CChunk%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/03-05/lesson)    动态导入模块，导入函数执行以后才加载    ```js  // idex.js  function getComponent() {   \treturn import(/* webpackChunkName:\"lodash\" */ 'lodash').then(({ default: _ }) => {   \t\tvar element = document.createElement('div');  \t\telement.innerHTML = _.join(['Dell', 'Lee'], '-');   \t\treturn element;   \t})   }      // 等价于上面 async写法  async function getComponent() {  \tconst { default: _ } = await import(/* webpackChunkName:\"lodash\" */ 'lodash');  \tconst element = document.createElement('div');  \telement.innerHTML = _.join(['Dell', 'Lee'], '-');  \treturn element;  }    document.addEventListener('click', () =>{  \tgetComponent().then(element => {  \t\tdocument.body.appendChild(element);  \t});  })    ```        Chunk 是什么，打包后生成 的文件，每个都是一个chunk        许多框架和类库对于如何用它们自己的方式来实现（懒加载）都有自己的建议。这里有一些例子：    - React: [Code Splitting and Lazy Loading](https://reacttraining.com/react-router/web/guides/code-splitting)  - Vue: [Lazy Load in Vue using Webpack's code splitting](https://alexjoverm.github.io/2017/07/16/Lazy-load-in-Vue-using-Webpack-s-code-splitting/)  - AngularJS: [AngularJS + Webpack = lazyLoad](https://medium.com/@var_bin/angularjs-webpack-lazyload-bb7977f390dd) by [@var_bincom](https://twitter.com/var_bincom)    [vue动态组件 & 异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html)    ##  打包分析，Preloading,  Prefetching    ### 打包分析    <https://github.com/webpack/analyse>    配置方法    ```json  // package.json  \"dev-build\": \"webpack --profile --json > stats.json --config ./build/webpack.dev.js\",  ```    根目录会生成stats.json打包分析文件    进入<http://webpack.github.io/analyse/>    上次分析文件    其他分析工具<https://webpack.js.org/guides/code-splitting#bundle-analysis>    用的较多[webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)    ### 代码覆盖率     [Chrome DevTools 代码覆盖率功能详解](https://segmentfault.com/a/1190000009013738)    快捷键 crtl + shift +p  输入coverage    Coverage 顾名思义就是代码覆盖率的意思。Coverage 功能使用动态分析（Dynamic Analysis）法来收集代码运行时的覆盖率，让开发者能够窥探他的代码到底有多大比例在发光发热。动态分析是指在应用运行状态下收集代码执行数据的过程，换句话说，覆盖率数据就是在代码执行过程中通过标记收集到的。    代码覆盖率比缓存更为重要，因为缓存第二次才会用到，提高代码覆盖率会提高首次加载时间。    提高代码覆盖率我们需要加页面加载时不需要的代码动态引入，例如登录模块代码，点击登录按钮后才会用到，我们可以在用户点击时加载代码，但是如果点击时才加载登录代码，可能因为网络延迟导致卡顿，所以我们可以使用prefetch和preload。    <link rel=\"prefetch\">是一种告诉浏览器**获取一项可能被**下一页访问**所需要的资源**方式。这意味着资源将以较低优先级地获取（因为浏览器知道当前页面所需要的资源，要比我们猜测在下一页访问所需资源更重要）。这意味着prefetch的主要用途是加速下一页访问速度，而不是当前页面的速度。    Preload是为当前页面服务的，它有一个 as 属性，这可以让浏览器做到很多subresource和prefetch做不到的事情：    - **浏览器可以设置正确的资源优先级**，使得资源可以被正确地加载，重要的资源不再会被延迟，不再被不重要的资源阻塞。  - 浏览器会保证请求对应正确的内容安全策略（[Content-Security-Policy](http://www.html5rocks.com/en/tutorials/security/content-security-policy/) ）指令，不会发起非法请求。  - 浏览器会基于资源类型发送正确的 Accept 首部。（比如获取图片时指定对“image/webp”的支持）  - 浏览器知道资源的类型，所以可以稍后决定资源是否在后续请求中保持可重用。    Preload的另外一个不同是，它有onload事件（至少在Chrome中，对另外两种 rel 取值并没作用）。    Preload**不阻塞window的onload事件**，除非该资源是被一个阻塞该事件的资源请求的。    将这些特性结合在一起，我们可以做到一些新的事情。    加载较晚发现的资源    preload最基本的使用方式是**提前加载较晚发现的资源**。虽然大部分基于标签的资源会被浏览器内部的预加载器（[preloader](http://calendar.perfplanet.com/2013/big-bad-preloader/)）提早发现，但并非所有资源都是基于标签的。有些资源是隐藏在CSS和JavaScript中的，浏览器不知道页面即将需要这些资源，而等到发现它们时已经为时已晚。所以在有些情况，这些资源延缓了首屏渲染，或是延缓了页面关键部分的加载。    查看本站可以看到body结束前的三个defer脚本在页面head做了preload    ![](https://img.dubiqc.com/201903/11003137.png)    ![](https://img.dubiqc.com/201903/11003254.png)    还可以配合[instant.page](https://instant.page/) ，instant.page使用*即时预加载* - 它在用户点击之前*预先*加载页面。因为鼠标悬停和点击之间有几百毫秒延迟，移动设备上，手指触摸到释放也会有延迟。    或者使用 [GoogleChromeLabs/quicklink](GoogleChromeLabs/quicklink) 这个项目：它由 Google 公司著名开发者 Addy Osmani 发起，实现了：**在空闲时间预获取页面可视区域内的链接，加快后续加载速度。**     我已经将instant.page已发布到npm [click-prefetch](https://www.npmjs.com/package/click-prefetch)    click-prefetch npm 模块使用    ```bash  npm i click-prefetch  ```    vue动态引入    ```js   mounted () {    window.addEventListener('load', () => {      import(        /* webpackPrefetch: true */        /* webpackChunkName:\"click-prefetch\"*/       'click-prefetch').then(({default: func}) => {  \t\tfunc();  \t})    });    }  ```    普通引入    ```js  // index.js  import  clickPrefetch from 'click-prefetch'    window.addEventListener('load', () => {    clickPrefetch()    });  ```        ### 预取/预加载模块(prefetch/preload module)    webpack v4.6.0+ 添加了预取和预加载的支持。    在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 \"resource hint(资源提示)\"，来告知浏览器：    - prefetch(预取)：将来某些导航下可能需要的资源  - preload(预加载)：当前导航下可能需要资源    下面这个 prefetch 的简单示例中，有一个 `HomePage` 组件，其内部渲染一个 `LoginButton` 组件，然后在点击后按需加载 `LoginModal` 组件。    **LoginButton.js**    ```js  //...  import(/* webpackPrefetch: true */ 'LoginModal');  ```    这会生成 `<link rel=\"prefetch\" href=\"login-modal-chunk.js\">` 并追加到页面头部，指示着浏览器在闲置时间预取 `login-modal-chunk.js` 文件。    > 只要父 chunk 完成加载，webpack 就会添加 prefetch hint(预取提示)。    与 prefetch 指令相比，preload 指令有许多不同之处：    - preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。  - preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。  - preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。  - 浏览器支持程度不同。    下面这个简单的 preload 示例中，有一个 `Component`，依赖于一个较大的 library，所以应该将其分离到一个独立的 chunk 中。    我们假想这里的图表组件 `ChartComponent` 组件需要依赖体积巨大的 `ChartingLibrary` 库。它会在渲染时显示一个 `LoadingIndicator(加载进度条)` 组件，然后立即按需导入 `ChartingLibrary`：    **ChartComponent.js**    ```js  //...  import(/* webpackPreload: true */ 'ChartingLibrary');  ```    在页面中使用 `ChartComponent` 时，在请求 ChartComponent.js 的同时，还会通过 `<link rel=\"preload\">` 请求 charting-library-chunk。假定 page-chunk 体积很小，很快就被加载好，页面此时就会显示 `LoadingIndicator(加载进度条)` ，等到 `charting-library-chunk` 请求完成，LoadingIndicator 组件才消失。启动仅需要很少的加载时间，因为只进行单次往返，而不是两次往返。尤其是在高延迟环境下。        ### 代码演示    ```js  // index.js  document.addEventListener('click', () =>{  \timport(/* webpackPrefetch: true */ './click.js').then(({default: func}) => {  \t\tfunc();  \t})  });  ```    ```js  // click.js  function handleClick() {  \tconst element = document.createElement('div');  \telement.innerHTML = 'Dell Lee';  \tdocument.body.appendChild(element);  }    export default handleClick;  ```    动态引入click.js    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-06%20%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%EF%BC%8CPreloading%2C%20%20Prefetching/03-06/lesson)    [import文档包含魔法注释](https://webpack.docschina.org/api/module-methods/#import-)    参考文章    [Preload有什么好处](http://www.alloyteam.com/2016/05/preload-what-is-it-good-for-part1/)     [Code Splitting with Vue.js And Webpack](https://juejin.im/post/5a372d956fb9a045204c4ff1)     [异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6)    ## css文件的代码分割    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-07%20CSS%20%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/03-07/lesson)    小知识    ```js  \toutput: {  \t\tfilename: '[name].js',                  // 入口文件名  \t\tchunkFilename: '[name].chunk.js',       // chunk文件名  \t\tpath: path.resolve(__dirname, '../dist')  \t}  ```    ### MiniCssExtractPlugin    css分割插件  webpack默认不打包css文件，使用css in js    MiniCssExtractPlugin 暂不支持HRM因此要在生产环境中使用    另外压缩css需要[Optimize CSS Assets Webpack Plugin](https://github.com/NMFR/optimize-css-assets-webpack-plugin)    安装    ```bash  npm install --save-dev mini-css-extract-plugin  npm install --save-dev optimize-css-assets-webpack-plugin  ```    修改生产环境配置    ```js  const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");  // 添加插件  const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");//添加插件  const merge = require('webpack-merge');  const commonConfig = require('./webpack.common.js');      const prodConfig = {  \tmode: 'production',  \tdevtool: 'cheap-module-source-map',  \tmodule: {  \t\trules:[{  \t\t\ttest: /\\.scss$/,  \t\t\tuse: [  \t\t\t\tMiniCssExtractPlugin.loader,    //修改loader  \t\t\t\t{  \t\t\t\t\tloader: 'css-loader',  \t\t\t\t\toptions: {  \t\t\t\t\t\timportLoaders: 2  \t\t\t\t\t}  \t\t\t\t},  \t\t\t\t'sass-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}, {  \t\t\ttest: /\\.css$/,  \t\t\tuse: [  \t\t\t\tMiniCssExtractPlugin.loader,   //修改loader  \t\t\t\t'css-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}]  \t},  \toptimization: {  \t\tminimizer: [new OptimizeCSSAssetsPlugin({})]  //实例化压缩插件  \t},  \tplugins: [  \t\tnew MiniCssExtractPlugin({                     // 实例化插件  \t\t\tfilename: '[name].css',                    //直接引入页面的css名字  \t\t\tchunkFilename: '[name].chunk.css'          //  \t\t})  \t]  }    module.exports = merge(commonConfig, prodConfig);  ```        修改开发环境配置 ，添加cssloader配置    ```js  const webpack = require('webpack');  const merge = require('webpack-merge');  const commonConfig = require('./webpack.common.js');    const devConfig = {  \tmode: 'development',  \tdevtool: 'cheap-module-eval-source-map',  \tdevServer: {  \t\tcontentBase: './dist',  \t\topen: true,  \t\tport: 8080,  \t\thot: true  \t},  \tmodule: {  \t\trules: [{  \t\t\ttest: /\\.scss$/,  \t\t\tuse: [  \t\t\t\t'style-loader',   \t\t\t\t{  \t\t\t\t\tloader: 'css-loader',  \t\t\t\t\toptions: {  \t\t\t\t\t\timportLoaders: 2  \t\t\t\t\t}  \t\t\t\t},  \t\t\t\t'sass-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}, {  \t\t\ttest: /\\.css$/,  \t\t\tuse: [  \t\t\t\t'style-loader',  \t\t\t\t'css-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}]  \t},  \tplugins: [  \t\tnew webpack.HotModuleReplacementPlugin()  \t],  }    module.exports = merge(commonConfig, devConfig);  ```            修改公共配置  删除css配置    ```js  const path = require('path');  const HtmlWebpackPlugin = require('html-webpack-plugin');  const CleanWebpackPlugin = require('clean-webpack-plugin');    module.exports = {  \tentry: {  \t\tmain: './src/index.js',  \t},  \tmodule: {  \t\trules: [{   \t\t\ttest: /\\.js$/,   \t\t\texclude: /node_modules/,   \t\t\tloader: 'babel-loader',  \t\t}, {  \t\t\ttest: /\\.(jpg|png|gif)$/,  \t\t\tuse: {  \t\t\t\tloader: 'url-loader',  \t\t\t\toptions: {  \t\t\t\t\tname: '[name]_[hash].[ext]',  \t\t\t\t\toutputPath: 'images/',  \t\t\t\t\tlimit: 10240  \t\t\t\t}  \t\t\t}   \t\t}, {  \t\t\ttest: /\\.(eot|ttf|svg)$/,  \t\t\tuse: {  \t\t\t\tloader: 'file-loader'  \t\t\t}   \t\t}]  \t},  \tplugins: [  \t\tnew HtmlWebpackPlugin({  \t\t\ttemplate: 'src/index.html'  \t\t}),   \t\tnew CleanWebpackPlugin(['dist'], {  \t\t\troot: path.resolve(__dirname, '../')  \t\t})  \t],  \toptimization: {  \t\tusedExports: true,  \t\tsplitChunks: {        chunks: 'all'      }  \t},  \toutput: {  \t\tfilename: '[name].js',  \t\tchunkFilename: '[name].chunk.js',  \t\tpath: path.resolve(__dirname, '../dist')  \t}  }  ```        因为开启tree shaking，要配置package.json ，防止删除css    ```js    \"sideEffects\": [      \"*.css\"    ],  ```        高级特性，查看[文档](https://webpack.js.org/plugins/mini-css-extract-plugin)     使用预加载或内联CSS    在单个文件中提取所有CSS     媒体查询插件    如果您想从提取的CSS中提取媒体查询（因此移动用户不再需要加载桌面或平板电脑特定的CSS），您应该使用以下插件之一：    - [媒体查询插件](https://github.com/SassNinja/media-query-plugin)  - [媒体查询拆分插件](https://github.com/mike-diamond/media-query-splitting-plugin)    ## webpack与浏览器缓存    小知识：    ```js  performance: false,  //关闭性能警告 ，超出200kb控制台会警告   cacheGroups: {        \tvendors: {        \t\ttest: /[\\\\/]node_modules[\\\\/]/,        \t\tpriority: -10,        \t\tname: 'vendors',                     //修改node模块打包文件名        \t}        }  ```    打包后的服务器文件会在用户浏览器生产缓存，因此要修改生产环境output，根据内容产生hash值，内容不变就不会变    ```js  output: {  \t\tfilename: '[name].[contenthash].js',  \t\tchunkFilename: '[name].[contenthash].js'  \t}  ```    这样代码变化重新上线，用户只需要下载变更打代码部分即可    老版本webpack需要额外配置    ```js  \toptimization: {  \t\truntimeChunk: {  \t\t\tname: 'runtime'    \t\t}      }  ```    因为老版本webpack处理业务代码和库代码关系的manifest代码可能会变化，配置runtimeChunk会把这部分代码抽离出来    ## shimming    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-09%20Shimming%20%E7%9A%84%E4%BD%9C%E7%94%A8/03-09/lesson)    垫片    模块化各模块之间的变量不能互相使用，可以使用ProvidePlugin插件自动加载，而不必模块`import`或`require`它们无处不在。    配置plugin    ```js  const webpack = require('webpack');    new webpack.ProvidePlugin({    identifier: 'module1',    // ...  });  ```    要么    ```js  const webpack = require('webpack');  new webpack.ProvidePlugin({    identifier: ['module1', 'property1'],    // ...  });  ```    无论何时`identifier`在模块中遇到自由变量，`module`都会自动加载，并`identifier`用加载的导出填充`module`（或者`property`为了支持命名导出）。    > 要导入ES2015模块的默认导出，必须指定模块的默认属性。    模块中的this默认为这个模块，要想改成window可以使用插件    安装    ```  npm i imports-loader -D  ```    配置    ```js  // webpack.common.js  \t\trules: [{   \t\t\ttest: /\\.js$/,   \t\t\texclude: /node_modules/,  \t\t\tuse: [{  \t\t\t\tloader: 'babel-loader'  \t\t\t}, {  \t\t\t\tloader: 'imports-loader?this=>window'   //添加loader  \t\t\t}]  \t\t}  ```    作业    阅读[文档](https://webpack.js.org/guides)    ## 环境变量的使用    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/03-10%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/03-10/lesson)    使用环境变量修改    可以配置环境变量使用不同配置文件    ```json  // package.json    \"scripts\": {      \"dev-build\": \"webpack --config ./build/webpack.common.js\",      \"dev\": \"webpack-dev-server --config ./build/webpack.common.js\",      \"build\": \"webpack --env.production --config ./build/webpack.common.js\"    }  ```    ```js  // webpack.common.js  module.exports = (env) => {  \tif(env && env.production) {  \t\treturn merge(commonConfig, prodConfig);  \t}else {  \t\treturn merge(commonConfig, devConfig);  \t}  }  ```    想要消除 [开发环境](https://webpack.docschina.org/guides/development) 和 [生产环境](https://webpack.docschina.org/guides/production) 之间的 `webpack.config.js` 差异，你可能需要环境变量(environment variable)。    webpack 命令行 [环境配置](https://webpack.docschina.org/api/cli/#environment-options) 的 `--env` 参数，可以允许你传入任意数量的环境变量。而在 `webpack.config.js` 中可以访问到这些环境变量。例如，`--env.production` 或 `--env.NODE_ENV=local`（`NODE_ENV` 通常约定用于定义环境类型，查看 [这里](https://dzone.com/articles/what-you-should-know-about-node-env)）。    ```bash  webpack --env.NODE_ENV=local --env.production --progress  ```    > 如果设置 `env` 变量，却没有赋值，`--env.production` 默认表示将 `--env.production` 设置为 `true`。还有许多其他可以使用的语法。更多详细信息，请查看 [webpack CLI](https://webpack.docschina.org/api/cli/#environment-options) 文档。    对于我们的 webpack 配置，有一个必须要修改之处。通常，`module.exports` 指向配置对象。要使用 `env` 变量，你必须将 `module.exports` 转换成一个函数：    **webpack.config.js**    ```js  const path = require('path');    module.exports = env => {    // Use env.<YOUR VARIABLE> here:    console.log('NODE_ENV: ', env.NODE_ENV); // 'local'    console.log('Production: ', env.production); // true      return {      entry: './src/index.js',      output: {        filename: 'bundle.js',        path: path.resolve(__dirname, 'dist')      }    };  };  ```    vue-cli等默认配置了环境变量    ```js  // vue.config.js  module.exports = {    baseUrl: process.env.NODE_ENV === 'production' ? './' : '/'  }    ```    ## library的打包    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/04-01%20Library%E7%9A%84%E6%89%93%E5%8C%85/04-01/library)    打包库步骤：    创建文件夹 library    初始化 npm init     创建库文件    ```js  // index.js  import * as math from './math';  import * as string from './string';    export default { math, string }  ```    ```js  // math.js  export function add(a, b) {  \treturn a + b;  }    export function minus(a, b) {  \treturn a - b;  }    export function multiply(a, b) {  \treturn a * b;  }    export function division(a, b) {  \treturn a / b;  }  ```    ```js  // string.js  import _ from 'lodash';    export function join(a, b) {  \treturn _.join([a, b], ' ');  }  ```    安装webpack     ```  npm i webpack webpack-cli -D  ```    创建webpack配置文件    ```js  const path = require('path');    module.exports = {  \tmode: 'production',  \tentry: './src/index.js',  \texternals: 'lodash',        // 见下文  \toutput: {  \t\tpath: path.resolve(__dirname, 'dist'),  \t\tfilename: 'library.js',  \t\tlibrary: 'root',     // 支持scrpit引入，全局变量挂到root  \t\tlibraryTarget: 'umd'   //支持 es commonjs等模块引入语法  \t}  }  ```    其他组合配置    ```js  \t\tlibrary: 'library',     // 支持scrpit引入，全局变量挂到this  \t\tlibraryTarget: 'this'   //不支持 es common.js require.js等模块引入语法  ```    ```js  \t\tlibrary: 'library',     // 支持scrpit引入，全局变量挂到window 浏览器环境  \t\tlibraryTarget: 'window'   //不支持 es common.js require.js等模块引入语法  ```    ```js  \t\tlibrary: 'library',     // 支持scrpit引入，全局变量挂到global node环境  \t\tlibraryTarget: 'global'   //不支持 es common.js require.js等模块引入语法  ```    es10规范规定globalThis也可以使用    ### 库引用其他库怎么办    例如应用了lodash配置    ```js  externals: 'lodash',          ```    `externals` 配置选项提供了「从输出的 bundle 中排除依赖」的方法。相反，所创建的 bundle 依赖于那些存在于用户环境(consumer's environment)中的依赖。此功能通常对 **library 开发人员**来说是最有用的，然而也会有各种各样的应用程序用到它。    > **用户(consumer)**，在这里是指，引用了「使用 webpack 打包的 library」的所有终端用户的应用程序(end user application)。    ### `externals`    ```  string` `object` `function` `regex  ```    **防止**将某些 `import` 的包(package)**打包**到 bundle 中，而是在运行时(runtime)再去从外部获取这些*扩展依赖(external dependencies)*。    例如，从 CDN 引入 [jQuery](https://jquery.com/)，而不是把它打包：    **index.html**    ```html  <script    src=\"https://code.jquery.com/jquery-3.1.0.js\"    integrity=\"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=\"    crossorigin=\"anonymous\">  <\/script>  ```    **webpack.config.js**    ```javascript  module.exports = {    //...    externals: {      jquery: 'jQuery'    }  };  ```    这样就剥离了那些不需要改动的依赖模块，换句话，下面展示的代码还可以正常运行：    ```javascript  import $ from 'jquery';    $('.my-element').animate(/* ... */);  ```    具有外部依赖(external dependency)的 bundle 可以在各种模块上下文(module context)中使用，例如 [CommonJS, AMD, 全局变量和 ES2015 模块](https://webpack.docschina.org/concepts/modules)。外部 library 可能是以下任何一种形式：    - **root**：可以通过一个全局变量访问 library（例如，通过 script 标签）。  - **commonjs**：可以将 library 作为一个 CommonJS 模块访问。  - **commonjs2**：和上面的类似，但导出的是 `module.exports.default`.  - **amd**：类似于 `commonjs`，但使用 AMD 模块系统。    可以接受各种语法……    [完整配置查看文档](https://webpack.docschina.org/configuration/externals/)    ### 如何让别人使用库    修改main为打包生的文件    ```JSON  // package.json    \"main\": \"./dist/library.js\",  ```    最后是发布    查看本站[发布教程](/frontend/node/node.html#npm)    ##  PWA 的打包配置    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/04-02%20PWA%20%E7%9A%84%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/04-02/lesson)    安装 http-server 模拟服务器    ```bash  npm i http-server -D  ```    修改package.json    ```json   \"scripts\": {      \"start\": \"http-server dist\",      \"dev\": \"webpack-dev-server --config ./build/webpack.dev.js\",      \"build\": \"webpack --config ./build/webpack.prod.js\"    },  ```    打包后运行 `npm run start` 会在dist文件夹下模拟一台服务器    打开127.0.0.1可以访问    如果我们 按`ctrl +c`停止服务器，网页就不能访问了    但是pwa即使服务器挂掉，本地页面缓存还能访问    实现这种技术可以使用插件 ，底层实现是serviceworker     ```  npm i workbox-webpack-plugin -D  ```    配置生产环境即可，本地开发不用pwa    ```js  const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");  const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");  const WorkboxPlugin = require('workbox-webpack-plugin');  // 引入插件  const merge = require('webpack-merge');  const commonConfig = require('./webpack.common.js');    const prodConfig = {  \tmode: 'production',  \tdevtool: 'cheap-module-source-map',  \tmodule: {  \t\trules:[{  \t\t\ttest: /\\.scss$/,  \t\t\tuse: [  \t\t\t\tMiniCssExtractPlugin.loader,   \t\t\t\t{  \t\t\t\t\tloader: 'css-loader',  \t\t\t\t\toptions: {  \t\t\t\t\t\timportLoaders: 2  \t\t\t\t\t}  \t\t\t\t},  \t\t\t\t'sass-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}, {  \t\t\ttest: /\\.css$/,  \t\t\tuse: [  \t\t\t\tMiniCssExtractPlugin.loader,  \t\t\t\t'css-loader',  \t\t\t\t'postcss-loader'  \t\t\t]  \t\t}]  \t},  \toptimization: {  \t\tminimizer: [new OptimizeCSSAssetsPlugin({})]  \t},  \tplugins: [  \t\tnew MiniCssExtractPlugin({  \t\t\tfilename: '[name].css',  \t\t\tchunkFilename: '[name].chunk.css'  \t\t}),  \t\tnew WorkboxPlugin.GenerateSW({     // 实例化插件  \t\t\tclientsClaim: true,              \t\t\tskipWaiting: true  \t\t})  \t],  \toutput: {  \t\tfilename: '[name].[contenthash].js',  \t\tchunkFilename: '[name].[contenthash].js'  \t}  }    module.exports = merge(commonConfig, prodConfig);  ```    配置成功，运行npm run build打包    会发现打包文件 多了service-worker 和precache-manifest     可以理解为另类的缓存    此时pwa还不能正常使用，需要在业务代码中启用    ```js  if ('serviceWorker' in navigator) {  \twindow.addEventListener('load', () => {  \t\tnavigator.serviceWorker.register('/service-worker.js')  \t\t\t.then(registration => {  \t\t\t\tconsole.log('service-worker registed');  \t\t\t}).catch(error => {  \t\t\t\tconsole.log('service-worker register error');  \t\t\t})  \t})  }  ```    重新打包     启动本地服务器npm run start    再关掉服务器，发现网站还能访问    pwa配置还有很多可以自行查看文档    本站已配置PWA，您可以关掉网络测试，依然可以访问    [pwa](https://lavas.baidu.com/pwa)    ##  TypeScript 的打包配置    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/04-03%20TypeScript%20%E7%9A%84%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/type-script/type-script)    ts代码    ```typescript  import * as _ from 'lodash';    class Greeter {    greeting: string;    constructor(message: string) {      this.greeting = message;    }    greet() {    \treturn _.join([\"Hello,\", ' ', this.greeting], '');    }  }    let greeter = new Greeter(\"world\");    alert(greeter.greet());  ```        安装 ts-loader typrscript    ```  npm i ts-loader typescript -D  ```        ```js  const path = require('path');    module.exports = {  \tmode: 'production',  \tentry: './src/index.tsx',   //ts文件入口  \tmodule: {  \t\trules: [{  \t\t\ttest: /\\.tsx?$/,  \t\t\tuse: 'ts-loader',      // 配置loader  \t\t\texclude: /node_modules/    // 引入文件来自node模块不处理  \t\t}]  \t},  \toutput: {  \t\tfilename: 'bundle.js',  \t\tpath: path.resolve(__dirname, 'dist')  \t}  }  ```    tsconfig.json    ```json  {  \t\"compilerOpitons\": {  \t\t\"outDir\": \"./dist\",  //输出目录  \t\t\"module\": \"es6\",     //模块引入方式  \t\t\"target\": \"es5\",    // 转为什么形式  \t\t\"allowJs\": true,    // 允许引入js模块文件  \t}  }  ```    识别loadsh方法错误调用还需要安装    ```  npm i @type/lodash -D  ```    引入相应库都有安装type工具    <https://github.com/DefinitelyTyped/DefinitelyTyped>    使用工具[搜索](https://microsoft.github.io/TypeSearch/)    ##  使用 WebpackDevServer 实现请求转发    使用此处代码进行[演示](https://github.com/jinjun1994/example/tree/master/webpack4/02-11%20Webpack%20%E5%AE%9E%E7%8E%B0%E5%AF%B9React%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%93%E5%8C%85/02-11/lesson)    [完成后代码](https://github.com/jinjun1994/example/tree/master/webpack4/04-04%20%E4%BD%BF%E7%94%A8%20WebpackDevServer%20%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91/04-04/lesson)    安装    ```  npm i axios -D  ```    引入模块使用    ```js  import React, { Component } from 'react';  import ReactDom from 'react-dom';  import axios from 'axios';                   //引入    class App extends Component {    \tcomponentDidMount() {                         //发送get请求  \t\taxios.get('/react/api/header.json')  \t\t\t.then((res) => {  \t\t\t\tconsole.log(res);  \t\t\t})  \t}    \trender() {  \t\treturn <div>Hello World</div>  \t}  }    ReactDom.render(<App />, document.getElementById('root'));  ```    开发环境与生产环境接口不一样    接口使用相对路径，配置[devserver.prox](https://webpack.js.org/configuration/dev-server#devserverproxy)    进行数据转发    ```js  devServer: {  \t\tcontentBase: './dist',  \t\topen: true,  \t\tport: 8080,  \t\thot: true,  \t\thotOnly: true,  \t\tproxy: {  \t\t\t'/react/api': {  \t\t\t\ttarget: 'https://www.dell-lee.com',     //转发到此地址  \t\t\t\tsecure: false,                         // 请求https需要配置，http不需要  \t\t\t\tpathRewrite: {  \t\t\t\t\t'header.json': 'demo.json'  \t\t\t\t},  \t\t\t\tchangeOrigin: true,  \t\t\t\theaders: {  \t\t\t\t\thost: 'www.dell-lee.com',  \t\t\t\t}  \t\t\t}  \t\t}  \t}  ```    如果真实接口为header.json，假数据为demo.json，防止上线后出错，不要将假数据接口写到业务代码，防止出错，可以配置pathwrite，这样真实接口可用之后删除此行配置即可。devserve只在开发环境下有效    ```js  pathRewrite: {  \t\t\t\t\t'header.json': 'demo.json'  \t\t\t\t},  ```     `devServer.proxy`    ```  object` `[object, function]  ```    如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。    dev-server 使用了非常强大的 [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware) 包。更多高级用法，请查阅其 [文档](https://github.com/chimurai/http-proxy-middleware#options)。Note that some of `http-proxy-middleware`'s features do not require a `target` key, e.g. its `router` feature, but you will still need to include a `target` key in your config here, otherwise `webpack-dev-server` won't pass it along to `http-proxy-middleware`).    在 `localhost:3000` 上有后端服务的话，你可以这样启用代理：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      proxy: {        '/api': 'http://localhost:3000'      }    }  };  ```    请求到 `/api/users` 现在会被代理到请求 `http://localhost:3000/api/users`。    如果你不想始终传递 `/api` ，则需要重写路径：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      proxy: {        '/api': {          target: 'http://localhost:3000',          pathRewrite: {'^/api' : ''}        }      }    }  };  ```    默认情况下，不接受运行在 HTTPS 上，且使用了无效证书的后端服务器。如果你想要接受，修改配置如下：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      proxy: {        '/api': {          target: 'https://other-server.example.com',          secure: false        }      }    }  };  ```    有时你不想代理所有的请求。可以基于一个函数的返回值绕过代理。    在函数中你可以访问请求体、响应体和代理选项。必须返回 `false` 或路径，来跳过代理请求。    例如：对于浏览器请求，你想要提供一个 HTML 页面，但是对于 API 请求则保持代理。你可以这样做：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      proxy: {        '/api': {          target: 'http://localhost:3000',          bypass: function(req, res, proxyOptions) {            if (req.headers.accept.indexOf('html') !== -1) {              console.log('Skipping proxy for browser request.');              return '/index.html';            }          }        }      }    }  };  ```    如果你想要代理多个路径特定到同一个 target 下，你可以使用由一个或多个「具有 `context` 属性的对象」构成的数组：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      proxy: [{        context: ['/auth', '/api'],        target: 'http://localhost:3000',      }]    }  };  ```    注意，默认情况下，根请求不会被代理。要启用根代理，应该将 `devServer.index` 选项指定为 falsy 值：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      index: '', // specify to enable root proxying      host: '...',      contentBase: '...',      proxy: {        context: () => true,        target: 'http://localhost:1234'      }    }  };  ```    主机头的origin保持默认进行代理时，可以设置`changeOrigin`以`true`覆盖此行为。在某些情况下，例如使用[基于名称的虚拟托管站点](https://en.wikipedia.org/wiki/Virtual_hosting#Name-based)非常有用。接口对origin做了限制的话可以加这个    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      proxy: {        '/api': 'http://localhost:3000',        changeOrigin: true      }    }  };  ```    完整配置：    <https://github.com/chimurai/http-proxy-middleware>    ##  WebpackDevServer 解决单页面应用路由问题    [全部代码](https://github.com/jinjun1994/example/tree/master/webpack4/04-05%20WebpackDevServer%20解决单页面应用路由问题/04-05/lesson)    首先书写代码    ```js  / index.js  import React, { Component } from 'react';  import { BrowserRouter, Route } from 'react-router-dom';  import ReactDom from 'react-dom';  import Home from './home.js';  import List from './list.js';    class App extends Component {  \trender() {  \t\treturn (  \t\t\t<BrowserRouter>  \t\t\t\t<div>  \t\t\t\t\t<Route path='/' exact component={Home}/>  \t\t\t\t\t<Route path='/list' component={List}/>  \t\t\t\t</div>  \t\t\t</BrowserRouter>  \t\t)  \t}  }    ReactDom.render(<App />, document.getElementById('root'));  ```    ```js  // list.js  import React, { Component } from 'react';    class List extends Component {  \trender() {  \t\treturn <div>ListPage</div>  \t}  }    export default List;  ```    ```js  // home.js  import React, { Component } from 'react';    class Home extends Component {  \trender() {  \t\treturn <div>HomePage</div>  \t}  }    export default Home;  ```        访问/list会不存在，因为页面不存在，只有index.html    配置[devServer.historyApiFallback](https://webpack.js.org/configuration/dev-server#devserverhistoryapifallback)即可        **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      historyApiFallback: true    }  };  ```    原理是将请求都转换为对根路径的请求，就访问到了index.html    ### `devServer.historyApiFallback`    ```  boolean` `object  ```    当使用 [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History) 时，任意的 `404` 响应都可能需要被替代为 `index.html`。`devServer.historyApiFallback` 默认禁用。通过传入以下启用：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      historyApiFallback: true    }  };  ```    通过传入一个对象，比如使用 `rewrites` 这个选项，此行为可进一步地控制：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      historyApiFallback: {        rewrites: [          { from: /^\\/$/, to: '/views/landing.html' },          { from: /^\\/subpage/, to: '/views/subpage.html' },          { from: /./, to: '/views/404.html' }        ]      }    }  };  ```    historyApiFallback: true  等价于 {from: /\\.*\\/, to: '/index.html'}    当路径中使用点(dot)（常见于 Angular），你可能需要使用 `disableDotRule`：    **webpack.config.js**    ```javascript  module.exports = {    //...    devServer: {      historyApiFallback: {        disableDotRule: true      }    }  };  ```    CLI 用法    ```bash  webpack-dev-server --history-api-fallback  ```    更多选项和信息，查看 [connect-history-api-fallback](https://github.com/bripkens/connect-history-api-fallback) 文档。    可以使用函数来更好地控制重写过程。例如，以下列表显示了如何将请求`/libs/jquery/jquery.1.12.0.min.js`等路由到`./bower_components/libs/jquery/jquery.1.12.0.min.js`。如果您在URL路径中有API版本，也可以使用此功能。    ```  history({    rewrites: [      {        from: /^\\/libs\\/.*$/,        to: function(context) {          return '/bower_components' + context.parsedUrl.pathname;        }      }    ]  });  ```    The function始终使用具有以下属性的上下文对象调用该函数：    - **parsedUrl**：有关[URL模块](https://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost) 提供的[URL的信息](https://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost)`url.parse`。  - **match**：由提供的匹配结果数组`String.match(...)`。  - **request**：HTTP请求对象。    只能开发环境，生产环境需要后端配置nginx    ##  EsLint 在 Webpack 中的配置    规范项目代码    ```  npm i eslint -D  ```    配置规范    npx eslint --init    可以选择规范    选择 ues a popular style guide    再选择 Airbnb    选择是否使用react： yes    选择配置文件格式  JavaScript    选择是否安装依赖 ：是    配置（[官方文档](https://eslint.org/docs/user-guide/configuring)）    安装 解析器 nm i babel-eslint    ```js  module.exports = {  \t\"extends\": \"airbnb\",    \"parser\": \"babel-eslint\",  // 更换解析器   };  ```        配置完成    使用：    方法一npx eslint src 检测src目录下代码规范错误    方法二    使用vscode编辑器 安装 eslint插件(可能需要科学上网安装，不然容易出错)，这种方法不需要使用webpack    会根据配置提示错误，如下图    ![](https://img.dubiqc.com/201903/12051831.png-sign)    例如 会提示无状态组件不需要用class写法，应该写成函数    ![](https://img.dubiqc.com/201903/12051935.png-sign)    如果不想遵循此条规范，可以将错误提示后面的规则名复制到配置文件设置为0，即关闭    ```js  module.exports = {  \t\"extends\": \"airbnb\",    \"parser\": \"babel-eslint\",    \"rules\": {      \"react/prefer-stateless-function\": 0,   // 关闭      \"react/jsx-filename-extension\": 0       // 关闭只能在jsx文件写jsx    },    globals: {      document: false                      // 配置document全局变量不允许被覆盖    }  };  ```    如果插件安装不了。命令行又很麻烦。    这样我们可以和webpack结合    安装     ```  eslint-loader  ```    配置    ```js  module: {  \t\trules: [{   \t\t\ttest: /\\.js$/,   \t\t\texclude: /node_modules/,   \t\t\tuse: ['babel-loader', 'eslint-loader']  \t\t}, {  ```    这样打包的时候会提示问题    ![](https://img.dubiqc.com/201903/12053203.png-sign)    这样仍在命令行，看起来不方便，我们可以设置    ```js  // webpack.config.js  devServer: {  \t\toverlay: true,  ```    这样就会在浏览器弹出错误    ![](https://img.dubiqc.com/201903/12053440.png-sign)    这样改掉错误，提示会即时消失    更多配置项查看文档[eslint-loader](https://webpack.js.org/loaders/eslint-loader)    #### `fix`（默认值：false）    此选项将启用 [ESLint自动修复功能](http://eslint.org/docs/user-guide/command-line-interface#fix)。    **注意：此选项将更改源文件。**    #### `cache`（默认值：false）    此选项将启用将linting结果缓存到文件中。这对于减少完整构建时的掉毛时间特别有用。    这可以是`boolean`值或缓存目录路径（例如:) `'./.eslint-loader-cache'`。    如果`cache: true`使用，则将缓存文件写入`./node_modules/.cache`目录。这是推荐用法    为了安全起见，您可以使用`enforce: \"pre\"`section检查源文件，而不是由其他加载器修改（如`babel-loader`）。强制eslint-loader最先执行    ```js  module.exports = {    // ...    module: {      rules: [        {          enforce: \"pre\",          test: /\\.js$/,          exclude: /node_modules/,          loader: \"eslint-loader\"        },        {          test: /\\.js$/,          exclude: /node_modules/,          loader: \"babel-loader\"        }      ]    }    // ...  };  ```    推荐配置    真实项目不用eslint -loader,降低打包时间，使用git hook钩子，提交代码时，自动运行eslint src。出错禁止提交"},{title:"闭包的前世今生",path:"/posts/JavaScript/closure.html",strippedContent:' [[toc]]    ## 为什么需要闭包？    ```javascript  function makeWorker() {    let name = "Pete";      return function() {      alert(name);    };  }    let name = "John";    // 创建一个函数  let work = makeWorker();    // call it  work(); // 它显示的是什么呢？"Pete"（创建位置的 name）还是"John"（调用位置的 name）呢？  ```    函数 `makeWorker` 生成并返回另一个函数。这个新的函数可以在其他位置进行调用。它访问的是创建位置还是调用位置的外部变量呢，还是都可以？我们从这个问题了来理解闭包。    在允许创建函数引用（例如把函数当参数传递）的语言里，需要解决一个问题，那就是什么时候把作用域规则应用于这种函数，创建这种引用时还是函数最终被调用时？这个问题也就是**引用环境的约束规则，在创建时建立引用环境称为深约束，而推迟到调用时建立引用环境称为浅约束。**    在前一种情况下,将这个函数作为参数传递的那段代码,其实已经设想了一个明确的引用环境(当时的环境)，它并不希望该函数在其他环境中被调用。因此,在函数第一次被作为参数传递时就做好环境约束,在该函数最终被调用时恢复这个环境。这种引用环境的早期约束称为深约束。    要想实现深约束，那么就需要一种能够显示的表示引用环境的东西，也就是函数在将来运行时就像在现在运行一样，并将它与有关的函数的引用打包捆绑在一起，这个被捆绑起来产生的整体称为**“闭包”**。**闭包是函数和声明该函数的词法环境的组合**。也有说法认为闭包单指词法环境，不包含这个函数。    闭包使得函数可以继续访问定义时的词法作用域。无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包，它会持有对原始定义作用域的引用。    根据ECMA-262规范，JavaScript的函数包含一个[[scopes]]属性。[[scopes]] 指向作用域链 即 scope chain（ECMA-262v3）或者Lexical Environment（ECMA-262v5）。这对应于闭包的环境部分，[[scopes]]中可访问的属性列表即是标识符列表，对象本身的引用则对应于环境。    我们可以通过控制台查看文章开始 `work` 函数的闭包。    ![闭包](https://img.dubiqc.com/201902/25012606.png-sign)    本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一  级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、  Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使  用了回调函数，实际上就是在使用闭包。    ## 作用域    在 1936 年，图灵提出了现在称为“图灵机”的形式系统。图灵机概念中提出了通过 0、1运算系统来解决复杂问题。 1945 年，冯·诺依曼等人提出了 EDVAC 体系设计，以及其上的编码程序、纸带存储与输入。该设计方案完全实现了图灵的科学预见与构思。我们现在最常见的通用编程环境，就是构架于冯·诺依曼的设计，必然面临这样的物理环境——具有存储系统（例如内存、硬盘等）的计算机体系，并依赖存储（这里指内存）进行运算。后来有人简单地归结这样的运算系统：通过修改内存来反映运算的结果。    程序最终可以被表达为数据（结构）和逻辑（算法）两个方面，几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个值进行访问或修改。需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。  这套规则被称为作用域。在大多数现代语言中，变量的作用域都是静态确定的—即在程序编译时确定，这一类可以成为**静态作用域**。    在JavaScript中，函数的入口引入一个新的作用域，我们在这里建立局部对象的变量名与值的绑定，与局部变量同名的全局变量就会失效，它们被局部的变量绑定给屏蔽掉了。在函数退出时撤销所有的局部变量的绑定，并重新激活那些被屏蔽的全局对象的绑定。**对变量绑定的这些操作看似需要在运行时来处理，但实际则完全不需要执行任何代码，一个变量处于活动状态的那个程序区域完全是由纯粹的正文规则所决定，由于这个原因，静态作用域也被称为词法作用域**。典型的情况就是：对于一个特定的变量名字，其“当前的绑定”就是程序里包围这个名字的，距离该名字最近的那个代码区域里面的那个绑定。    在 JavaScript 中，每个运行的函数、代码块或整个程序，都有一个称为**词法环境（Lexical Environment）**的关联对象。    词法环境对象由两部分组成：    1. **环境记录（Environment Record）**—— 一个把所有局部变量作为其属性（包括一些额外信息，比如 `this` 值）的对象。  2. **外部词法环境（outer lexical environment）**的引用 —— 通常是嵌套当前代码（当前花括号之外）之外代码的词法环境。    所以，『变量』只是环境记录这个特殊内部对象的属性。『访问或修改变量』意味着『访问或改变词法环境的一个属性』。    举个例子，这段简单的代码中只有一个词法环境：            这是一个所谓的与整个程序关联的全局词法环境。在浏览器中，所有的 `<script>` 标签都同享一个全局（词法）环境。    在上图中，矩形表示环境记录（存放变量），箭头表示外部（词法环境）引用。全局词法环境没有外部（词法环境）引用，所以它指向了 `null`。    这是关于 `let` 变量（如何变化）的全程展示：            右侧的矩形演示在执行期间全局词法环境是如何变化的：    1. 执行开始时，词法环境为空。  2. `let phrase` 定义出现。它没有被赋值，所以存为 `undefined`。  3. `phrase` 被赋予了一个值。  4. `phrase` 引用了一个新值。    现在一切看起来都相当简单易懂，是吧？    总结一下：    - 变量是特定内部对象的属性，与当前执行的（代码）块/函数/脚本有关。  - 操作变量实际上操作的是该对象的属性。        在大多数现代语言中，约束的作用域都是静态确定的—即在程序编译时确定，这一类可以成为**静态作用域**。    什么时候将作用域规则应用与子程序？    ## 闭包的历史    历史背景：闭包这个概念第一次出现在1964年的《The Computer Journal》上，由**彼得·约翰·兰丁** （**Peter John Landin**）在《The mechanical evaluation of expressions》一文中提出了applicative expression（应用表达式）和closure（闭包）的概念。     文中AE的概念定义如下：    > We are, therefore, interested in a class of expressions about any one of which it is appropriate to ask the following questions:  > Q1. Is it an identifier? If so, what identifier?  > Q2. Is it a λ-expression? If so, what identifier or identifiers constitute its bound variable part and in what arrangement? Also what is the expression constituting its λ-body?  > Q3. Is it an operator/operand combination? If so, what is the expression constituting its operator? Also what is the expression constituting its operand?  > We call these expressions applicative expressions (AEs).    简单翻译    > 这样，我们对于能够适合提问以下问题的一类特性表达式感兴趣：  > Q1. 它是否是标识符？ 如果是的话，是什么标识符？  > Q2. 它是否是λ表达式？ 如果是的话，哪个或者哪些的标识符构成了它的绑定变量部分，范围是什么？还有是什么表达式构成了它的λ-body？  > Q3. 它是否是操作符/操作数的组合？如果是的话，构成它的操作符的表达式是什么？还有构成它的操作数的表达式又是什么？  > 我们称这一类表达式为“适用表达式”（AE）。    在AE的基础上，闭包定义为    > Also we represent the value of a λ-expression by a bundle of information called a "closure", comprising the λ-expression and the environment relative to which it was evaluated. We must therefore arrange that such a bundle is correctly interpreted whenever it has to be applied to some argument. More precisely:  > a closure has an environment part which is a list whose two items are:  > (1) an environment  > (2) an identifier or list of identifiers  > and a control part which consists of a list whose sole item is an AE.    翻译如下    > 此外，我们把带有一系列信息的λ表达式称作"闭包"，其中包括λ表达式和它执行时的相关连的环境。于是我们要确保无论当它被用于什么参数时，这些信息都能够被正确解析。更精确地：  > 闭包包含环境部分，它是个只有两项的list，这两项分别是：  > (1)环境  > (2)一个标识符或者标识符列表  > 以及控制部分，他是个只有一项的list，唯一的项是个AE    在1975年，Scheme最早实现了闭包。    60年代，因为受到函数式思维影响，计算机软件领域的"表达式"一般是包括λ表达式，也就是函数式语言中的函数的。所以这个闭包的定义在80年代后被更多过程式语言借鉴，其中包括C语言的static全局变量机制、C++的成员函数、JavaScript的局部函数。对于过程式语言中，因为很少有函数以外的"表达式"，所以闭包这个概念更多被用于指函数。    ## 闭包的应用    '},{title:"es6之模块笔记",path:"/posts/es6+/%E6%A8%A1%E5%9D%97.html",strippedContent:" ##  模块简述    模块（Modules）是使用不同方式加载的 JS 文件（与 JS 原先的脚本加载方式相对）。这种不同模式很有必要，因为它与脚本（script）有大大不同的语义：    - 模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式；  - 在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在；  - 模块顶级作用域的 this 值为 undefined；  - 模块不允许在代码中使用 HTML 风格的注释（这是 JS 来自于早期浏览器的历史遗留特性）；  - 对于需要让模块外部代码访问的内容，模块必须导出它们；  - 允许模块从其他模块导入绑定。    ##  ES6 模块语法    ### 静态加载    ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。    ```js  // CommonJS模块  let { stat, exists, readFile } = require('fs');    // 等同于  let _fs = require('fs');  let stat = _fs.stat;  let exists = _fs.exists;  let readfile = _fs.readfile;  ```        上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。    由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。    除了静态加载带来的各种好处，ES6 模块还有以下好处。    - 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。  - 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。  - 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。    ###  严格模式    ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。    - 严格模式主要有以下限制:  - 变量必须声明后再使用  - 函数的参数不能有同名属性，否则报错  - 不能使用 with 语句  - 不能对只读属性赋值，否则报错  - 不能使用前缀 0 表示八进制数，否则报错  - 不能删除不可删除的属性，否则报错  - 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]  - eval 不会在它的外层作用域引入变量  - eval 和 arguments 不能被重新赋值  - arguments 不会自动反映函数参数的变化  - 不能使用 arguments.callee  - 不能使用 arguments.caller  - 禁止 this 指向全局对象  - 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈  - 增加了保留字（比如 protected、static 和 interface）    其中，尤其需要注意 this 的限制。ES6 模块之中，顶层的 this 指向 undefined，即不应该在顶层代码使用 this。    ### export 命令    #### 基本导出    一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，最简单方法就是将 export 放置在任意变量、函数或类声明之前，从模块中将它们公开出去。    ```js  // profile.js  export var firstName = 'Michael';  export var lastName = 'Jackson';  export var year = 1958;  //或者  export {firstName, lastName, year};  ```        上面代码在 export 命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在 var 语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export 命令除了输出变量，还可以输出函数或类（class）。    需要特别注意的是，export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。    ```js  // 报错  export 1;    // 报错  var m = 1;  export m;  ```        上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量 m，还是直接输出 1。1 只是一个值，不是接口。正确的写法是下面这样。    ```js  // 写法一  export var m = 1;    // 写法二  var m = 1;  export {m};    // 写法三  var n = 1;  export {n as m};  ```        同样的，function 和 class 的输出，也必须遵守这样的写法。    ```js  // 报错  function f() {}  export f;    // 正确  export function f() {};    // 正确  function f() {}  export {f};  ```        另外，export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。    ```js  export var foo = 'bar';  setTimeout(() => (foo = 'baz'), 500);  ```        上面代码输出变量 foo，值为 bar，500 毫秒之后变成 baz。    最后，export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的 import 命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。    #### 重命名导出    通常情况下，export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。    ```js  function v1() { ... }  function v2() { ... }    export {    v1 as streamV1,    v2 as streamV2,    v2 as streamLatestVersion  };  ```        ### import 命令    #### 基本导入    使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块。    ```js  // main.js  import { firstName, lastName, year } from './profile.js';    function setName(element) {    element.textContent = firstName + ' ' + lastName;  }  ```        上面代码的 import 命令，用于加载 profile.js 文件，并从中输入变量。import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。    import 命令输入的变量都是只读的，因为它的本质是输入接口。输入的变量指向的地址是只读的，不能重新赋值.也就是说，不允许在加载模块的脚本里面，改写接口。    ```js  import { a } from './xxx.js';    a = {}; // Syntax Error : 'a' is read-only;  a.foo = 'hello'; // 合法操作  ```        import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。    注意，import 命令具有提升效果，会提升到整个模块的头部，首先执行。这种行为的本质是，import 命令是编译阶段执行的，在代码运行之前。    ```js  foo();    import { foo } from 'my_module';  ```        由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。    ```js  // 报错  import { 'f' + 'oo' } from 'my_module';    // 报错  let module = 'my_module';  import { foo } from module;    // 报错  if (x === 1) {    import { foo } from 'module1';  } else {    import { foo } from 'module2';  }  ```        最后，import 语句会执行所加载的模块，因此可以有下面的写法。如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。    ```js  import 'lodash';  ```        ```js  import { foo } from 'my_module';  import { bar } from 'my_module';    // 等同于  import { foo, bar } from 'my_module';  ```        上面代码仅仅执行 lodash 模块，但是不输入任何值。    #### 重命名导入    如果想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名。    ```js  import { lastName as surname } from './profile.js';  ```        #### 完全导入一个模块    除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。    ```js  import * as circle from './circle';    console.log('圆面积：' + circle.area(4));  console.log('圆周长：' + circle.circumference(14));  ```        注意，模块整体加载所在的那个对象（上例是 circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。    ```js  import * as circle from './circle';    // 下面两行都是不允许的  circle.foo = 'hello';  circle.area = function() {};  ```        ### export default 命令    将一个函数作为默认值进行了导出，default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。    ```js  // export-default.js  export default function() {    console.log('foo');  }    // import-default.js  import customName from './export-default';  customName(); // 'foo'  ```        一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 export default 命令。    一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 export default 命令。    ```js  // modules.js  function add(x, y) {    return x * y;  }  export { add as default };  // 等同于  // export default add;    // app.js  import { default as foo } from 'modules';  // 等同于  // import foo from 'modules';  ```        正是因为 export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。    ```js  // 正确  export var a = 1;    // 正确  var a = 1;  export default a;    // 错误  export default var a = 1;  ```        同样地，因为 export default 命令的本质是将后面的值，赋给 default 变量，所以可以直接将一个值写在 export default 之后。    ```js  // 正确  export default 42;    // 报错  export 42;  ```        如果想在一条 import 语句中，同时输入默认方法和其他接口，可以写成下面这样。    ```js  import _, { each, forEach } from 'lodash';  ```        ### 绑定的再导出    如果在一个模块之中，先输入后输出同一个模块，import 语句可以与 export 语句写在一起。    ```js  export { foo, bar } from 'my_module';    // 可以简单理解为  import { foo, bar } from 'my_module';  export { foo, bar };    // 接口改名  export { foo as myFoo } from 'my_module';    // 整体输出  export * from 'my_module';    //默认接口的写法如下。  export { default } from 'foo';    //具名接口改为默认接口  export { es6 as default } from './someModule';  // 等同于  import { es6 } from './someModule';  export default es6;    //默认接口也可以改名为具名接口  export { default as es6 } from './someModule';  ```        下面三种 import 语句，没有对应的复合写法。    ```js  import * as someIdentifier from 'someModule';  import someIdentifier from 'someModule';  import someIdentifier, { namedIdentifier } from 'someModule';  ```        为了做到形式的对称，现在有提案，提出补上这三种复合写法。    ```js  export * as someIdentifier from \"someModule\";  export someIdentifier from \"someModule\";  export someIdentifier, { namedIdentifier } from \"someModule\";  ```        ####  跨模块常量    const 声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。    ```js  // constants/db.js  export const db = {    url: 'http://my.couchdbserver.local:5984',    admin_username: 'admin',    admin_password: 'admin password'  };    // constants/user.js  export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];    // constants/index.js  export {db} from './db';  export {users} from './users';    // script.js  import {db, users} from './constants/index';  ```        ### import()动态导入    #### 基本语法    前面介绍过，import 命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import 命令叫做“连接” binding 其实更合适）。    这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果 import 命令要取代 Node 的 require 方法，这就形成了一个障碍。因为 require 是运行时加载模块，import 命令无法取代 require 的动态加载功能。因此，有一个提案，建议引入 import()函数，完成动态加载。webpack2+已经支持，需要配置，详情看[webpack速查](/blog/posts/webpack-search.html)    ```js  import(specifier);  ```        上面代码中，import 函数的参数 specifier，指定所要加载的模块的位置。import 命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。    import()返回一个 Promise 对象。下面是一个例子。    ```js  const main = document.querySelector('main');    import(`./section-modules/${someVariable}.js`)    .then(module => {      module.loadPageInto(main);    })    .catch(err => {      main.textContent = err.message;    });  ```        import()加载模块成功以后，这个模块会作为一个对象，当作 then 方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。    ```js  import('./myModule.js').then(({ export1, export2 }) => {    // ...·  });  ```        如果模块有 default 输出接口，可以用参数直接获得。    ```js  import('./myModule.js').then(myModule => {    console.log(myModule.default);  });  //或者  import('./myModule.js').then(({ default: theDefault }) => {    console.log(theDefault);  });  ```        如果想同时加载多个模块，可以采用下面的写法。    ```js  Promise.all([    import('./module1.js'),    import('./module2.js'),    import('./module3.js'),  ])  .then(([module1, module2, module3]) => {     ···  });  ```        import()也可以用在 async 函数之中。    ```js  async function main() {    const myModule = await import('./myModule.js');    const { export1, export2 } = await import('./myModule.js');    const [module1, module2, module3] = await Promise.all([      import('./module1.js'),      import('./module2.js'),      import('./module3.js')    ]);  }  main();  ```        import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与 import 语句不相同。import()类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。    #### 适用场合    #####  按需加载    import()可以在需要的时候，再加载某个模块。    ```js  button.addEventListener('click', event => {    import('./dialogBox.js')      .then(dialogBox => {        dialogBox.open();      })      .catch(error => {        /* Error handling */      });  });  ```        ##### 条件加载    import()可以放在 if 代码块，根据不同的情况，加载不同的模块。    ```js  if (condition) {    import('moduleA').then(...);  } else {    import('moduleB').then(...);  }  ```        ##### 动态的模块路径    import()允许模块路径动态生成。    ```js  import(f())  .then(...);  ```        ## 在 Web 浏览器中使用模块    ###  脚本异步加载    即使在 ES6 之前，web 浏览器都有多种方式在 web 应用中加载 JS。这些可能的脚本加载选择是：    - 使用<script>元素以及 src 属性来指定代码加载的位置，以便加载 JS 代码文件；  - 使用<script>元素但不使用 src 属性，来嵌入内联的 JS 代码；  - 加载 JS 代码文件并作为 Worker（例如 Web Worker 或 Service Worker）来执行。    默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<script>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。    如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。    ```html  <script src=\"path/to/myModule.js\" defer><\/script>  <script src=\"path/to/myModule.js\" async><\/script>  ```        defer 与 async 的区别是：    - defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。  - 另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。    ### 在 script 标签中使用模块    浏览器加载 ES6 模块，也使用 script 标签，但是要加入 type=\"module\"属性。    ```html  <script type=\"module\" src=\"./foo.js\"><\/script>  ```        浏览器对于带有 type=\"module\"的< script >，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了 script 标签的 defer 属性。如果网页有多个< script type=\"module\">，它们会按照在页面出现的顺序依次执行。    ```html  <script type=\"module\" src=\"./foo.js\"><\/script>  \x3c!-- 等同于 --\x3e  <script type=\"module\" src=\"./foo.js\" defer><\/script>  ```        < script >标签的 async 属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。    ```html  <script type=\"module\" src=\"./foo.js\" async><\/script>  ```        一旦使用了 async 属性，< script type=\"module\" >就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。    ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。    ```html  <script type=\"module\">    import utils from './utils.js';      // other code  <\/script>  ```        对于外部的模块脚本（上例是 foo.js），有几点需要注意。    - 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。  - 模块脚本自动采用严格模式，不管有没有声明 use strict。  - 模块之中，可以使用 import 命令加载其他模块（.js 后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 export 命令输出对外接口。  - 模块之中，顶层的 this 关键字返回 undefined，而不是指向 window。也就是说，在模块顶层使用 this 关键字，是无意义的。  - 同一个模块如果加载多次，将只执行一次。    ##  ES6 模块与 CommonJS 模块的差异    - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。  - CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。    ```js  // main.js  var mod = require('./lib');    console.log(mod.counter); // 3  mod.incCounter();  console.log(mod.counter); // 3  ```        上面代码说明，lib.js 模块加载以后，它的内部变化就影响不到输出的 mod.counter 了。这是因为 mod.counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。    ```js  // lib.js  var counter = 3;  function incCounter() {    counter++;  }  module.exports = {    get counter() {      return counter;    },    incCounter: incCounter  };  ```        最后，export 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例    ```js  // mod.js  function C() {    this.sum = 0;    this.add = function() {      this.sum += 1;    };    this.show = function() {      console.log(this.sum);    };  }    export let c = new C();    // x.js  import { c } from './mod';  c.add();    // y.js  import { c } from './mod';  c.show();    // main.js  import './x';  import './y';  ```        ## Node 的 ES6 模块    ### 基本规则    Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。    Node 要求 ES6 模块采用.mjs 后缀文件名。也就是说，只要脚本文件里面使用 import 或者 export 命令，那么就必须采用.mjs 后缀名。require 命令不能加载.mjs 文件，会报错，只有 import 命令才可以加载.mjs 文件。反过来，.mjs 文件里面也不能使用 require 命令，必须使用 import。    目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用--experimental-modules 参数才能打开该功能。    ```js  node --experimental-modules my-app.mjs  ```        为了与浏览器的 import 加载规则相同，Node 的.mjs 文件支持 URL 路径。目前，Node 的 import 命令只支持加载本地模块（file:协议），不支持加载远程模块。    ```js  import './foo?query=1'; // 加载 ./foo 传入参数 ?query=1  ```        上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。    目前，Node 的 import 命令只支持加载本地模块（file:协议），不支持加载远程模块。    ```js  import 'baz';  import 'abc/123';  ```        如果模块名包含路径，那么 import 命令会按照路径去寻找这个名字的脚本文件。    ```js  import 'file:///etc/config/app.json';  import './foo';  import './foo?search';  import '../bar';  import '/baz';  ```        如果脚本文件省略了后缀名，比如 import './foo'，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载./foo/package.json 的 main 字段指定的脚本。如果./foo/package.json 不存在或者没有 main 字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。    最后，Node 的 import 命令是异步加载，这一点与浏览器的处理方法相同。    ### 缺失的内部变量    ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。    首先，就是 this 关键字。ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块，这是两者的一个重大差异。    其次，以下这些顶层变量在 ES6 模块之中都是不存在的。    - arguments  - require  - module  - exports  - __filename  - __dirname    如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做。    ```js  // expose.js  module.exports = { __dirname };    // use.mjs  import expose from './expose.js';  const { __dirname } = expose;  ```        ## ES6 模块加载 CommonJS 模块    CommonJS 模块的输出都定义在 module.exports 这个属性上面。Node 的 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性，当作模块的默认输出，即等同于 export default xxx。    ```js  // a.js  module.exports = {    foo: 'hello',    bar: 'world'  };    // 等同于  export default {    foo: 'hello',    bar: 'world'  };  ```        即 import 命令实际上输入的是这样一个对象{ default: module.exports}。所以，一共有三种写法，可以拿到 CommonJS 模块的 module.exports。    ```js  // 写法一  import baz from './a';  // baz = {foo: 'hello', bar: 'world'};    // 写法二  import { default as baz } from './a';  // baz = {foo: 'hello', bar: 'world'};    // 写法三  import * as baz from './a';  // baz = {  //   get default() {return module.exports;},  //   get foo() {return this.default.foo}.bind(baz),  //   get bar() {return this.default.bar}.bind(baz)  // }  ```        ```js  // c.js  module.exports = function two() {    return 2;  };    // es.js  import foo from './c';  foo(); // 2    import * as bar from './c';  bar.default(); // 2  bar(); // throws, bar is not a function  ```        上面代码中，bar 本身是一个对象，不能当作函数调用，只能通过 bar.default 调用。    CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。    ```js  // foo.js  module.exports = 123;  setTimeout(_ => (module.exports = null));  ```        上面代码中，对于加载 foo.js 的脚本，module.exports 将一直是 123，而不会变成 null。    由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用 import 命令加载 CommonJS 模块时，不允许采用下面的写法。    ```js  // 不正确  import { readFile } from 'fs';    // 正确的写法一  import * as express from 'express';  const app = express.default();    // 正确的写法二  import express from 'express';  const app = express();  ```        ##  CommonJS 模块加载 ES6 模块    CommonJS 模块加载 ES6 模块，不能使用 require 命令，而要使用 import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。    ```js  // es.mjs  let foo = { bar: 'my-default' };  export default foo;    // cjs.js  const es_namespace = await import('./es.mjs');  // es_namespace = {  //   get default() {  //     ...  //   }  // }  console.log(es_namespace.default);  // { bar:'my-default' }  ```        ```js  // es.js  export let foo = { bar: 'my-default' };  export { foo as bar };  export function f() {}  export class c {}    // cjs.js  const es_namespace = await import('./es');  // es_namespace = {  //   get foo() {return foo;}  //   get bar() {return foo;}  //   get f() {return f;}  //   get c() {return c;}  // }  ```        ## 循环加载    “循环加载”（circular dependency）指的是，a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。    ```js  // a.js  var b = require('b');  // b.js  var a = require('a');  ```        ### CommonJS 模块的循环加载    ####  CommonJS 模块的加载原理    CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。    ```js  {    id: '...',    exports: { ... },    loaded: true,    ...  }  ```        以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。    #### CommonJS 模块的解决方案    CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出。    ```js  //a.js  exports.done = false;  var b = require('./b.js');  console.log('在 a.js 之中，b.done = %j', b.done);  exports.done = true;  console.log('a.js 执行完毕');    //b.js  exports.done = false;  var a = require('./a.js');  console.log('在 b.js 之中，a.done = %j', a.done);  exports.done = true;  console.log('b.js 执行完毕');    //main.js  var a = require('./a.js');  var b = require('./b.js');  console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);  ```        执行 main.js，运行结果如下。    ```js  $ node main.js    // 在 b.js 之中，a.done = false  // b.js 执行完毕  // 在 a.js 之中，b.done = true  // a.js 执行完毕  // 在 main.js 之中, a.done=true, b.done=true  ```        上面的代码证明了两件事。一是，在 b.js 之中，a.js 没有执行完毕，只执行了第一行。二是，main.js 执行到第二行时，不会再次执行 b.js，而是输出缓存的 b.js 的执行结果，即它的第四行。    另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。    ```js  var a = require('a'); // 安全的写法  var foo = require('a').foo; // 危险的写法    exports.good = function(arg) {    return a.foo('good', arg); // 使用的是 a.foo 的最新值  };    exports.bad = function(arg) {    return foo('bad', arg); // 使用的是一个部分加载时的值  };  ```        上面代码中，如果发生循环加载，require('a').foo 的值很可能后面会被改写，改用 require('a')会更保险一点。    ###  ES6 模块的循环加载    ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用 import 从一个模块加载变量（即 import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。    ```js  // a.mjs  import { bar } from './b';  console.log('a.mjs');  console.log(bar);  export let foo = 'foo';    // b.mjs  import { foo } from './a';  console.log('b.mjs');  console.log(foo);  export let bar = 'bar';  ```        上面代码中，a.mjs 加载 b.mjs，b.mjs 又加载 a.mjs，构成循环加载。执行 a.mjs，结果如下。    ```js  $ node --experimental-modules a.mjs  b.mjs  ReferenceError: foo is not defined  ```        首先，执行 a.mjs 以后，引擎发现它加载了 b.mjs，因此会优先执行 b.mjs，然后再执行 a.mjs。接着，执行 b.mjs 的时候，已知它从 a.mjs 输入了 foo 接口，这时不会去执行 a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行 console.log(foo)的时候，才发现这个接口根本没定义，因此报错。    解决这个问题的方法，就是让 b.mjs 运行的时候，foo 已经有定义了。这可以通过将 foo 写成函数来解决。    ```js  // a.mjs  import { bar } from './b';  console.log('a.mjs');  console.log(bar());  function foo() {    return 'foo';  }  export { foo };    // b.mjs  import { foo } from './a';  console.log('b.mjs');  console.log(foo());  function bar() {    return 'bar';  }  export { bar };  ```        这时再执行 a.mjs 就可以得到预期结果。    ```js  $ node --experimental-modules a.mjs  // b.mjs  // foo  // a.mjs  // bar  ```        这是因为函数具有提升作用，在执行 import {bar} from './b'时，函数 foo 就已经有定义了，所以 b.mjs 加载的时候不会报错。这也意味着，如果把函数 foo 改写成函数表达式，也会报错."},{title:"css核心知识",path:"/posts/css/css.html",strippedContent:' [[toc]]    ## 如何学习css    如何学习css推荐这篇文章    [如何学习CSS](https://www.smashingmagazine.com/2019/01/how-to-learn-css/)    [中文版](https://juejin.im/post/5c447efa51882528735eedb2)    ## 盒模型    HTML文档中的每个元素在渲染的时候都会被描绘成一个矩形盒子，而盒模型(box model)正是用来表示每个元素盒子所占用空间大小的模型。    CSS将源文档组织为元素和文本节点树，并将其呈现在画布上(例如屏幕、纸张或音频流)。为此，它生成一个中间结构，即box tree，它表示呈现的文档的格式化结构。box树中的每个box表示画布上空间和/或时间中对应的元素(或伪元素)，而box树中运行的每个文本同样表示其对应文本节点的内容。([css标准](https://www.w3.org/TR/css-display-3/#intro))    ::: tip    盒模型是css的核心，css面试必问题：对CSS盒模型的认识，下面从此题了解盒模型    :::    0    ## 对盒模型的认识    对于这个题目，我们要回答一下几个方面：    （1）基本概念：content、padding、border、[outline](https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline)、margin。    （2）标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人。    （3）CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。    （4）JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。    （5）实例题：根据盒模型解释**边距重叠**。    前四个方面是逐渐递增，第五个方面，却鲜有人知。    （6）BFC（边距重叠解决方案）或IFC。    如果能回答第五条，就会引出第六条。BFC是面试频率较高的。    **总结**：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论。    接下来，我们把上面的六条，依次讲解。    ### 一、基本概念    CSS假设每个元素生成一个或多个矩形框，称为元素框。    每个元素框的中心都有一个内容区域。这个内容区域被可选的内边距、边框、轮廓线和外边距包围。这些区域被认为是可选的，因为它们都可以设置为宽度为0，从而有效地将它们从元素框中移除。    下图显示了一个示例。默认情况下，颜色或平铺图像的内容背景应用于内边距。外边距总是透明的，允许任何父元素的背景都是可见的。内边距不能有负的长度，但是边距可以。我们将在后面探讨负外边距的影响。    ![](https://img.dubiqc.com/201902/16162258.png-sign)    每个外边距、边框和内边距都可以使用各种特定于边的属性(如 margin-left or border-bottom)以及缩写属性(如`{padding:  }`)进行设置。轮廓没有特定于边的属性。标准盒模型如下图所示：    ![标准盒模型](https://img.dubiqc.com/201902/16164226.png-sign)    #### margin padding border content 各区域分布如下图所示    ![](https://img.dubiqc.com/201902/17142641.png-sign)    ::: tip    [CSS](https://developer.mozilla.org/en-US/docs/CSS)的`outline`属性是用来设置一个或多个单独的轮廓属性的[简写属性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties) ， 例如 [`outline-style`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline-style), [`outline-width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline-width) 和 [`outline-color`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline-color)。 多数情况下，简写属性更加可取和便捷。    轮廓与边框在以下几个方面存在不同：    - 轮廓不占据空间，它们被描绘于内容之上  - 轮廓可以是非矩形的。在Gecko/Firefox中，轮廓是矩形的，但是Opera则会围绕元素结构绘制非矩形的形状    :::    ###  二、标准盒模型、IE盒模型的区别    - 在 **标准盒子模型**中，**width 和 height 指的是内容区域**的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。    - **IE盒子模型**中，**width 和 height 指的是内容区域+border+padding**的宽度和高度。      ###  三、CSS如何设置这两种模型    代码如下：    ```css      /* 设置当前盒子为 标准盒模型（默认） */      box-sizing: content-box;        /* 设置当前盒子为 IE盒模型 */      box-sizing: border-box;  ```    备注：盒子默认为标准盒模型。    ::: tip    `padding-box`    [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 和 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height) 属性包括内容和内边距，但是不包括边框和外边距。只有Firefox实现了这个值，它在Firefox 50中被删除。    :::    ###  四、JS如何设置、获取盒模型对应的宽和高    ##### 方式一：通过DOM节点的 style 样式获取    ```javascript  \telement.style.width/height;  ```    缺点：通过这种方式，只能获取**行内样式**，不能获取`内嵌`的样式和`外链`的样式。    这种方式有局限性，但应该了解。    ##### 方式二（通用型）    ```javascript      window.getComputedStyle(element).width/height;  ```    方式二能兼容 Chrome、火狐。是通用型方式。    ##### 方式三（IE独有的）    ```javascript  \telement.currentStyle.width/height;  ```    和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。    ##### 方式四    ```javascript  \telement.getBoundingClientRect().width/height;  ```    此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。    此 api 可以拿到四个属性：left、top、width、height。    **总结：**    上面的四种方式，要求能说出来区别，以及哪个的通用型更强。    ### 五、垂直边距重叠    margin的collapse是CSS1就有的。见此：     http://www.w3.org/TR/CSS1/#vertical-formatting    摘录如下：    > The width of the margin on non-floating block-level elements specifies the **minimum distance** to the edges of surrounding boxes. Two or more adjoining vertical margins (i.e., with no border, padding or content between them) are collapsed to use the maximum of the margin values. In most cases, after collapsing the vertical margins the result is visually more pleasing and closer to what the **designer expects**.   >  > 非浮动块级元素上的空白宽度指定到周围框边缘的最小距离。两个或多个相邻的垂直边距(它们之间没有边框、填充或内容)被折叠以使用边距值的最大值。  >  > 在大多数情况下，在折叠垂直边距之后，结果在视觉上更令人愉悦，更接近设计师的预期    可见这个特性应是源自传统排版，目的是指定段落的最小间距。    **标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin**(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。        #### 由上可知    :::tip    **两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠**    类似于普通流另有[bfc布局规则](#bfc布局规则)：**属于同一个BFC的两个相邻Box的margin会发生重叠**    :::    **1.两个或多个**   说明其数量必须是大于一个，又说明，折叠是元素与元素间相互的行为，不存在 A 和 B 折叠，B 没有和 A 折叠的现象。    **2.毗邻**   是指没有被非空内容、padding、border 或 clear 分隔开，说明其位置关系。   注意一点，在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(*非浮动元素等*)的 margin-top 相邻；             只有在一个元素的 height 是 "auto" 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(*非浮动元素等*)的 margin-bottom 相邻。    **3.垂直方向**   是指具体的方位，只有垂直方向的 margin 才会折叠，也就是说，水平方向的 margin 不会发生折叠的现象。    二、那么如何使元素上下margin不折叠呢？    **1.**浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠**（注意这里指的是上下相邻的元素）**    **2.**创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠**（注意这里指的是创建了BFC的元素和它的子元素不会发生折叠）**    触发BFC的因素是**float（除了none）、overflow（除了visible）、display（table-cell/table-caption/inline-block）、position（除了static/relative）** 等    **相邻元素不发生折叠的因素是触发BFC因素的子集**，也就是说**如果我为上下相邻的元素设置了overflow:hidden，虽然触发了BFC，但是上下元素的上下margin还是会发生折叠**          创建BFC的初衷只是为了让元素本身（包括它的子元素）能够正确的计算自己的宽高。[http://www.yuiblog.com/blog/2010/05/19/css-101-block-formatting-contexts](<https://yuiblog.com/blog/2010/05/19/css-101-block-formatting-contexts/>)    不发生折叠的触发因素是浮动元素、inline-block 元素、绝对定位元素，这个只是创建BFC因素的子集，但并不能说明创建了BFC的元素就不会发生折叠，因为BFC还可以用overflow:hidden来创建。相反如果父元素触发了BFC，那么他的块级子元素反而会发生折叠。    ::: tip    如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。    :::        ## BFC IFC GFC FFC    在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。    ###  Box: CSS布局的基本单位    　　Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：    - block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；  - inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；  - run-in box: css3 中才有， 这儿先不讲了。    ### Formatting context    　　Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。    　　CSS2.1 中只有 `BFC `和 `IFC`, **CSS3** 中还增加了 `GFC `和 `FFC。`    ### BFC 定义    　　BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。    BFC 就是个为了布局计算简单，如果所有都从[初始包含块](<https://www.jianshu.com/p/ac7771ea1e9e>)计算得累死，说白了他就是个变了名字的初始包含块，是一个独立计算区域，它里面实际元素累加了多高就是多高。且普通流内元素还是根据普通流 margin 折叠原则折叠 ，只是跟初始包含块一样直接子孙元素与该框上下边界不能边距折叠，不是俩上下相邻的BFC之间不折叠。([参考](https://www.zhihu.com/question/35375980))        ### BFC布局规则    1. 内部的Box会在垂直方向，一个接一个地放置。  2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠  3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。  4. BFC的区域不会与float box重叠。  5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。  6. 计算BFC的高度时，浮动元素也参与计算    ### 哪些元素会生成BFC?    下列方式会创建[块格式化上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)：    - 根元素或包含根元素的元素    - 浮动元素（元素的 [`float`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/float) 不是 `none`）    - 绝对定位元素（元素的 [`position`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position) 为 `absolute` 或 `fixed`）    - 行内块元素（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `inline-block`）    - 表格单元格（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)为 `table-cell`，HTML表格单元格默认为该值）    - 表格标题（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-caption`，HTML表格标题默认为该值）    - 匿名表格单元格元素（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)为 `table、``table-row`、 `table-row-group、``table-header-group、``table-footer-group`（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 `inline-table`）    - [`overflow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow) 值不为 `visible` 的块元素    - [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `flow-root` 的元素    - [`contain`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain) 值为 `layout`、`content`或 `strict` 的元素    - 弹性元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)为 `flex` 或 `inline-flex`元素的直接子元素）    - 网格元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)为 `grid` 或 `inline-grid` 元素的直接子元素）    - 多列容器（元素的 [`column-count`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count) 或 [`column-width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-width) 不为 `auto，包括 ``column-count` 为 `1`）    - `column-span` 为 `all` 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（[标准变更](https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51)，[Chrome bug](https://bugs.chromium.org/p/chromium/issues/detail?id=709362)）。      :::tip    简记：    float不为none、    overflow不为hidden、    display为table-cell，table-caption，inline-block中的任何一个。    dispaly 为flex grid元素的子元素     Position值不为relative或static        :::    ### BFC的作用及原理    #### 1. 自适应两栏布局    代码如下：    ````css  <style>      body {          width: 300px;          position: relative;      }      .aside {          width: 100px;          height: 150px;          float: left;          background: #f66;      }      .main {          height: 200px;          background: #fcc;      }  </style>  <body>      <div class="aside"></div>      <div class="main"></div>  </body>  ````    以上代码效果如下：    <style module="a">      .aside {      width: 100px;      height: 150px;      float: left;      background: #f66;  }      .main {      height: 200px;      background: #fcc;  }  </style>  <div :class="a.aside"></div>  <div :class="a.main">此处可用开发者工具调试查看</div>    <script>  export default {    props: [\'slot-key\'],    mounted () {        console.log(this.a,this.b)    }  }  <\/script>      ​              ![](https://img.dubiqc.com/201902/17145931.png-sign)    根据`BFC`布局规则第3条：    > 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。（点击查看[margin box](#margin-padding-border-content-各区域分布如下图所示)）    　　因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。    　　根据`BFC`布局规则第四条：    > `BFC`的区域不会与`float box`重叠。    　　我们可以通过通过触发main生成`BFC`， 来实现自适应两栏布局。    ```css  .main {      overflow: hidden;  }  ```    　　当触发main生成`BFC`后，这个新的`BFC`不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：此处可用开发者工具调试查看    <style module="b">      .asideb {      width: 100px;      height: 150px;      float: left;      background: #f66;  }      .mainb {      height: 200px;      background: #fcc;      overflow: hidden;  }  </style>  <div :class="b.asideb"></div>  <div :class="b.mainb" ></div>    ![](https://img.dubiqc.com/201902/17153729.png-sign)    #### 2. 清除内部浮动    代码：    ````html  <style>      .par {          border: 5px solid #fcc;          width: 300px;      }         .child {          border: 5px solid #f66;          width:100px;          height: 100px;          float: left;      }  </style>  <body>      <div class="par">          <div class="child"></div>          <div class="child"></div>      </div>  </body>  ````    效果：    <style module="float">      .par {          border: 5px solid #fcc;          width: 300px;      }      .child {          border: 5px solid #f66;          width:100px;          height: 100px;          float: left;      }  </style>    <div :class="float.par">      <div :class="float.child"></div>      <div :class="float.child"></div>  </div>      ![](https://img.dubiqc.com/201902/17154859.png-sign)    根据`BFC`布局规则第六条：    > 计算`BFC`的高度时，浮动元素也参与计算    　　为达到清除内部浮动，我们可以触发par生成`BFC`，那么par在计算高度时，par内部的浮动元素child也会参与计算。    　　代码：    ```css  .par {       overflow: hidden;  }  ```    修改后效果：    ![](https://img.dubiqc.com/201902/17160610.png-sign)    #### 3. 防止垂直 margin 重叠    代码：    ````html  <style>      p {          color: #f55;          background: #fcc;          width: 200px;          line-height: 100px;          text-align:center;          margin: 100px;      }  </style>  <body>      <p>Haha</p>      <p>Hehe</p>  </body>  ````    效果：        ![效果](https://img.dubiqc.com/201902/17160747.png-sign)    两个p之间的距离为100px，发送了margin重叠。    这是由于[普通流中margin重叠](# 由上可知)    　　我们可以在p外面包裹一层容器，并触发该容器生成一个`BFC`。使得p与外部隔离，就不会发生margin重叠了。  　　代码：    ````html  <style>      .wrap {          overflow: hidden;   // 新bfc      }      p {          color: #f55;          background: #fcc;          width: 200px;          line-height: 100px;          text-align:center;          margin: 100px;      }  </style>  <body>      <p>Haha</p>      <div class="wrap">          <p>Hehe</p>      </div>  </body>  ````    效果：    ![](https://img.dubiqc.com/201902/17161224.png-sign)            其实以上的几个例子都体现了，`BFC`就是页面上的一个**隔离的独立容器**，容器里面的子元素不会影响到外面的元素。反之也如此。     `IFC`(`Inline Formatting Contexts`)直译为"内联格式化上下文"，`IFC`的`line box`（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的`padding/margin`影响)     `FFC`(`Flex Formatting Contexts`)直译为"自适应格式化上下文"，`display`值为`flex`或者`inline-flex`的元素将会生成自适应容器（`flex container`）     `GFC`(`GridLayout Formatting Contexts`)直译为"网格布局格式化上下文"，当为一个元素设置`display`值为`grid`的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（`grid container`）上定义网格定义行（`grid definition rows`）和网格定义列（`grid definition columns`）属性各在网格项目（`grid item`）上定义网格行（`grid row`）和网格列（`grid columns`）为每一个网格项目（`grid item`）定义位置和空间。            参考链接：    - [前端精选文摘：BFC 神奇背后的原理](https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html)    ## 继承与层叠    层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在CSS处于核心地位，CSS的全称层叠样式表正是强调了这一点。    ## css选择器    **CSS 选择器**规定了 CSS 规则会应用到哪些元素上。    ### 基本选择器    - [Type（类型）选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors)      这种基本选择器会选择所有匹配给定元素名的元素。       **语法：**`elename`       **例子：**input 将会选择所有的`<input>` 素。    - [Class（类）选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors)      这种基本选择器会基于类属性的值来选择元素。       **语法：** `.classname`       **例子：** `.index` 会匹配所有包含 `index 类的元素` (由类似于`class="index"`这样的属性定义的).    - [ID选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors)      这种基本选择器会选择所有id属性与之匹配的元素。需要注意的是一个文档中每个id都应该是唯一的。       **语法：**`#idname`       **例子：**`#toc` 将会匹配所有id属性为 toc 的元素 (类似于这样的定义 `id="toc"`).    - [通用选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors)      这个基本选择器选择所有节点。它也常常和一个名词空间配合使用，用来选择该空间下的所有元素。       **语法：** `* ns|* *|*`       **例子：**`*` （通配符）将会选择所有元素。    - [属性选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors)      这个基本的选择器根据元素的属性来进行选择。       **语法：**`[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value]`       **例子：**`[autoplay]` 将会选择所有具有 autoplay 属性的元素（不论这个属性的值是什么）    ### 组合选择器    - [紧邻兄弟选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_selectors)      `\'+\'` 操作符选择相邻元素，即第二个节点紧邻着第一个节点，并且拥有共同的父节点。       **语法:** `A + B`       **例子:** `ul + li` 会匹配任何 `ul` 元素后紧邻的 `li` 元素。    - [一般兄弟选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_selectors)      `\'~\'` 操作符选择兄弟元素，也就是说，第二个节点在第一个节点后面的任意位置，并且这俩节点的父节点相同。       **语法:** `A ~ B` **例子:** `p ~ span` 将会匹配同一父元素下，`<p>` 元素后的所有 `<span>` 元素。    - [子选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Child_selectors)      `\'>\'` 操作符选择第一个元素的直接子节点。       **语法:** `A > B`       **例子:** `ul > li` 将会匹配直接嵌套在 `<ul>` 元素内的所有 `<li>` 元素。    - [后代选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_selectors)      `\' \'`  (空格) 操作符将选择第一个元素的子代节点。       **语法:** `A B`       **例子:** `div span` 将匹配`<div>` 元素内所有的 `<span>` 元素。    ### 伪类    [伪类](<https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes>) **允许基于未包含在文档树中的状态信息来选择元素。**    CSS **伪类** 是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，[`:hover`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover) 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色。    #### [标准伪类索引](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes#%E6%A0%87%E5%87%86%E4%BC%AA%E7%B1%BB%E7%B4%A2%E5%BC%95)    像普通的类一样，你可以在一个选择器中按需连用多个伪类。    - [`:active`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active)  - [`:any`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any)  - [`:any-link`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any-link)  - [`:checked`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:checked)  - [`:default`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:default)  - [`:defined`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:defined)  - [`:dir()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:dir)  - [`:disabled`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:disabled)  - [`:empty`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty)  - [`:enabled`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:enabled)  - [`:first`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first)  - [`:first-child`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child)  - [`:first-of-type`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type)  - [`:fullscreen`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:fullscreen)  - [`:focus`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus)  - [`:focus-visible`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-visible)  - [`:host`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:host)  - [`:host()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:host())  - [`:host-context()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:host-context())  - [`:hover`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover)  - [`:indeterminate`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:indeterminate)  - [`:in-range`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:in-range)  - [`:invalid`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid)  - [`:lang()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:lang)  - [`:last-child`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child)  - [`:last-of-type`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type)  - [`:left`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:left)  - [`:link`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link)  - [`:not()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not)  - [`:nth-child()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child)  - [`:nth-last-child()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child)  - [`:nth-last-of-type()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-of-type)  - [`:nth-of-type()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type)  - [`:only-child`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child)  - [`:only-of-type`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-of-type)  - [`:optional`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:optional)  - [`:out-of-range`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:out-of-range)  - [`:read-only`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-only)  - [`:read-write`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-write)  - [`:required`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:required)  - [`:right`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:right)  - [`:root`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root)  - [`:scope`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:scope)  - [`:target`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target)  - [`:valid`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid)  - [`:visited`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited)    ### 伪元素    - [伪元素](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements) 表示所有未被包含在HTML的实体。      就像 [pseudo classes](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes) (伪类)一样， 伪元素添加到选择器，但不是描述特殊状态，它们允许您为元素的某些部分设置样式。 下例中的 [`::first-line`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line)  伪元素改变段落第一行的文字样式。      ```css    /* The first line of every <p> element. */    p::first-line {      color: blue;      text-transform: uppercase;    }    ```    #### 语法    ```css  selector::pseudo-element { property: value; }  ```    #### 所有伪元素    ::: tip    使用after、before可减少dom数量，提升性能    :::        - [`::after`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after)  - [`::before`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before)  - [`::first-letter`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter)  - [`::first-line`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line)  - [`::selection`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection)    **试验性_内嵌**    - [`::backdrop`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::backdrop)   - [`::placeholder`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::placeholder)   - [`::marker`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::marker)   - [`::spelling-error`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error)   - [`::grammar-error`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error)       ### 选择器的优先级    - `!important` > 行内样式 > `#id` > `.class` > `tag` > * > 继承 > 默认  - 选择器 **从右往左** 解析    浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以`a、b、c、d`命名，分别代表以下含义：    1. `a`表示是否使用内联样式（inline style）。如果使用，`a`为 1，否则为 0。  2. `b`表示 ID 选择器的数量。  3. `c`表示类选择器、属性选择器和伪类选择器数量之和。  4. `d`表示标签（类型）选择器和伪元素选择器之和。    优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。`a、b、c、d`权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果`b`的值不同，那么`c`和`d`不管多大，都不会对结果产生影响。比如`0，1，0，0`的优先级高于`0，0，10，10`。    **继承没有权重，通配符权重0**    当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。    在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用`!important`的方式，去覆盖组件的样式了。    《css权威指南》有超详细介绍    ## css布局    [css布局实践](https://www.yuque.com/fe9/basic/ecdg1z)    从例题实战学习css布局：假设高度默认100px ，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。    主要有以下五种    - 方法1：浮动  - 方法2：绝对定位。    - 方法3：flexbox。移动开发里经常用到。  - 方法4：表格布局 table。虽然已经淘汰了，但也应该了解。  - 方法5：网格布局 grid。    ### 方法1 和方法2    **方法1、浮动：**    左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。    **方法2、绝对定位：**    左侧设置为绝对定位， left：0px。右侧设置为绝对定位， right：0px。中间设置为绝对定位，left 和right 都为300px，即可。中间的宽度会自适应。    使用`article`标签作为容器，包裹左、中、右三个部分。    方法1 和方法2 的代码如下：    ```  <!DOCTYPE html>  <html lang="en">    <head>      <meta charset="UTF-8">      <title>Document</title>      <style>          html * {              padding: 0px;              margin: 0px;          }            .layout {              margin-bottom: 150px;          }              .layout article div { /*注意，这里是设置每个小块儿的高度为100px，而不是设置大容器的高度。大容器的高度要符合响应式*/              height: 100px;          }            /* 方法一 start */            .layout.float .left {              float: left;              width: 300px;              background: red;          }            .layout.float .right {              float: right;              width: 300px;              background: blue;          }            .layout.float .center {              background: green;            }            /* 方法一 end */              /* 方法二 start */          .layout.absolute .left-center-right {              position: relative;          }            .layout.absolute .left {              position: absolute;              left: 0;              width: 300px;              background: red;          }            /* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */          .layout.absolute .center {              position: absolute;              left: 300px;              right: 300px;              background: green;          }            .layout.absolute .right {              position: absolute;              right: 0;              width: 300px;              background: blue;          }              /* 方法二 end */      </style>  </head>    <body>        \x3c!-- 方法一：浮动 start --\x3e      \x3c!-- 输入 section.layout.float，即可生成  --\x3e      <section class="layout float">          \x3c!-- 用  article 标签包裹左、中、右三个部分 --\x3e          <article class="left-right-center">              \x3c!-- 输入 div.left+div.right+div.center，即可生成 --\x3e              <div class="left">                  我是 left              </div>              <div class="right">                  我是 right              </div>              <div class="center">                  浮动解决方案                  我是 center              </div>            </article>        </section>      \x3c!-- 方法一：浮动 end --\x3e        <section class="layout absolute">          <article class="left-center-right">              <div class="left">                  我是 left              </div>              <div class="right">                  我是 right              </div>              <div class="center">                  <h1>绝对定位解决方案</h1>                  我是 center              </div>          </article>      </section>  </body>  </html>  ```    注意上方代码中， className 定义和使用，非常规范。    [查看效果](https://jinjun1994.github.io/example/css/float.html)    ### 方法3、flexbox布局    将左中右所在的容器设置为`display: flex`，设置两侧的宽度后，然后让中间的`flex = 1`，即可。    ```html  <!DOCTYPE html>  <html lang="en">    <head>      <meta charset="UTF-8">      <title>Document</title>      <style>          html * {              padding: 0;              margin: 0;          }            .layout article div {              height: 100px;          }            .left-center-right {              display: flex;          }            .layout.flex .left {              width: 300px;              background: red;          }            .layout.flex .center {              flex: 1;              background: green;          }            .layout.flex .right {              width: 300px;              background: blue;          }      </style>    </head>    <body>      <section class="layout flex">          <article class="left-center-right-">              <div class="left">                  我是 left              </div>              <div class="center">                  <h1>flex布局解决方案</h1>                  我是 center              </div>              <div class="right">                  我是 right              </div>            </article>      </section>    </body>    </html>  ```    [点击查看效果](https://jinjun1994.github.io/example/css/flex.html)        ### 方法4、表格布局 table    设置整个容器的宽度为100%，设置三个部分均为表格，然后左边的单元格为 300px，右边的单元格为 300px，即可。中间的单元格会自适应。    ```html  <!DOCTYPE html>  <html lang="en">    <head>      <meta charset="UTF-8">      <title>Document</title>      <style>          html * {              padding: 0;              margin: 0;          }            .layout.table div {              height: 100px;          }            /* 重要：设置容器为表格布局，宽度为100% */          .layout.table .left-center-right {              width: 100%;              display: table;              height: 100px;            }            .layout.table .left-center-right div {              display: table-cell; /* 重要：设置三个模块为表格里的单元*/          }            .layout.table .left {              width: 300px;              background: red;          }            .layout.table .center {              background: green;          }            .layout.table .right {              width: 300px;              background: blue;          }      </style>    </head>    <body>      <section class="layout table">          <article class="left-center-right">              <div class="left">                  我是 left              </div>              <div class="center">                  <h1>表格布局解决方案</h1>                  我是 center              </div>              <div class="right">                  我是 right              </div>            </article>      </section>    </body>    </html>  ```    [点击查看效果](https://jinjun1994.github.io/example/css/table.html)    ### 方法5、网格布局 grid    ```  <!DOCTYPE html>  <html lang="en">    <head>      <meta charset="UTF-8">      <title>Document</title>      <style>          html * {              padding: 0;              margin: 0;          }            /* 重要：设置容器为网格布局，宽度为100% */          .layout.grid .left-center-right {              display: grid;              width: 100%;              grid-template-rows: 100px;              grid-template-columns: 300px auto 300px;  /* 重要：设置网格为三列，并设置每列的宽度。即可。*/            }            .layout.grid .left {              background: red;          }            .layout.grid .center {              background: green;          }            .layout.grid .right {              background: blue;          }      </style>    </head>    <body>      <section class="layout grid">          <article class="left-center-right">              <div class="left">                  我是 left              </div>              <div class="center">                  <h1>网格布局解决方案</h1>                  我是 center              </div>              <div class="right">                  我是 right              </div>            </article>      </section>    </body>    </html>  ```    [点击查看效果](https://jinjun1994.github.io/example/css/grid.html)        ### 延伸：五种方法的对比    - 五种方法的优缺点  - 考虑中间模块的高度问题  - 兼容性问题：实际开发中，哪个最实用？    方法1：浮动：    - 优点：兼容性好。  - 缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。    方法:2：绝对定位    - 优点：快捷。  - 缺点：导致子元素也脱离了标准文档流，可实用性差。    方法3：flex 布局（CSS3中出现的）    - 优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。    方法4：表格布局    - 优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局  - 缺点：因为三个部分都当成了**单元格**来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。    什么时候用 flex 布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。    方法5：网格布局    - CSS3中引入的布局，很好用。代码量简化了很多。    PS：面试提到网格布局，说明我们对新技术是有追求的。    ### 延伸：如果题目中去掉高度已知    问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？    分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。    答案是：**flex 布局和表格布局可以通用**，其他三个布局都不能用了。    ### 页面布局的变通    [![img](https://camo.githubusercontent.com/3f5f902a712386655e19ced04ab3be7d8000eadb/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330355f313933312e706e67)](https://camo.githubusercontent.com/3f5f902a712386655e19ced04ab3be7d8000eadb/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330355f313933312e706e67)    `上下高度固定，中间自适应`，这个在移动端的页面中很常见。    ### 总结    涉及到的知识点：    （1）语义化掌握到位：每个区域用`section`、`article`代表容器、`div`代表块儿。如果通篇都用 div，那就是语义化没掌握好。    （2）页面布局理解深刻。    （3）CSS基础知识扎实。    （4）思维灵活且积极上进。题目中可以通过`网格布局`来体现。    （5）代码书写规范。注意命名。上面的代码中，没有一行代码是多的。                        ## css核心技巧     css分层理论      双飞翼布局    布局方式    ### 基于移动端的PX与REM转换兼容方案    - `different size different DPR`  - 目前的设计稿 一般是 640 750 1125，一般要先均分成100份，(兼容`vh,vm`) `750/10 = 75px (1rem = 75px)`。`div`宽是`240px*120px css`的书写改为`3.2rem * 1.6rem`。 配合响应式修改`html`根的大小。  - 字体不建议使用rem的，`data-dpr`属性动态设置字体大小。屏幕变大放更多的文字，或者屏幕更大放更多的字。[资料介绍](https://segmentfault.com/a/1190000004358316)   - 神奇的`padding/margin-top`等比例缩放间距    ### 移动端布局    - `flex`模型  - `*` 杀伤力太大,根据具体使用什么再加什么  - `Reset.css` 重置 `Normalize.css`修复 `Neat.css`融合  - 移动端必须加上的    ````css  html {    box-sizing: border-box;  }  *, *:before, *:after {    box-sizing: inherit;  }  ````    ### retina1px适配    由于高清屏的特性，以2倍Retina高清屏的移动设备为例，CSS中的1px是由2×2个屏幕物理像素点来渲染的，那么样式上的border:1px在Retina高清屏下会渲染成2个物理像素宽度或高度的边框，有时为了追求1px精准的还原，不得不思考其他的方法来解决这个问题。实现1px边框的方式比较多，通常可以设置元素after或before伪元素为1px内容，并使用transform：scaleY（1/devicePixelRatio）来进行单方向的缩放实现1个物理像素的边框或内容。对于字体，我们也可以设置transform：scale(.5)在浏览器中支持显示小于12px的文字。同时如果页面的内容因为使用高清屏而导致模糊，则需要使用-webkit-font-smoothing: antialiased来尝试修复。    ### inline 元素对齐     vertical-align: middle;    ### reset选择    reset.css(重置) 、[normalize.css](https://github.com/necolas/normalize.css)（修复）、[Neat.css](https://thx.github.io/cube/doc/neat#neatcss-)（融合）    项目开始引入neat.css    #### reset.css    为什么会有`CSS Reset`的存在呢？那是因为早期的浏览器支持和理解的CSS规范不同，导致渲染页面时效果不一致，会出现很多兼容性问题。 关于 [浏览器的默认样式](http://www.w3cfuns.com/topic-12.html) 请点击查阅！    根据玉伯的文章中透漏，最早的一份`CSS Reset`来自Tantek 的[undohtml.css](http://tantek.com/log/2004/undohtml.css)，从URL中的日期可以看出时间是2004年，Tantek根据自身需要对于一些标签进行了简单的重置，源码如下：    ```  /* undohtml.css */  /* (CC) 2004 Tantek Celik. Some Rights Reserved.             */  :link,:visited { text-decoration:none }  ul,ol { list-style:none }  h1,h2,h3,h4,h5,h6,pre,code { font-size:1em; }  ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,body,html,p,blockquote,  fieldset,input{ margin:0; padding:0 }  a img,:link img,:visited img { border:none }  address { font-style:normal }  ```    #### 核心代码与作用    随后加入到`CSS Reset`的行列的大牛越来越多，比如业界领袖 [YUI团队](http://yui.github.io/yui2/) 以及[Eric Meyer](http://meyerweb.com/eric/tools/css/reset/index.html)把这份代码内容变的更加充实，但是不难发现代码的核心部分还是对样式进行重置，在此可以结论出早期的`CSS Reset`的作用就是清除所有浏览器默认样式，让它一切归零！    ```  * { margin:0; padding:0 }  ```    不过在此之后一段时间内，有人开始批判这种暴力清零的`CSS Reset`方式，随后部分前端开发者们也传来一些争议声音，比如：    1. `*{ margin:0; padding:0; }`会带来性能问题  2. 使用通配符存在隐性问题  3. 过渡的标签重置等于画蛇添足  4. 过渡的标签重置导致语言元素失效    reset是革命党，normalize是改良派。reset的方针就是都tm给我脱光光，老子今天要翻牌。什么豹纹，蕾丝，美颜相机统统给我拿掉，老子读书少，都别骗我。于是，一个个屌丝心中的女神都重拾了素颜，但回到本真又能怎样？那两厘米的粉底不都是为了你？于是，在旁边的normalize看不下去了。它主张生活不必处处追求真实，有时应该睁一只眼，闭一只眼。    #### normalize    normalize.css是一个现代的，为HTML5准备的reset.css的替代品。它可以使元素的渲染在多个浏览器下都能保持一致并且符合规范。它所瞄准的，也都是些需要规范化的样式。    #### Normalize.css的目标    1. 保留有用的浏览器默认样式，而不是一概将它们“抹杀”。  2. normalize.css作用在范围更广的元素上面。  3. 修正了一些bug及主流浏览器在渲染上的不一致。  4. 提高了可用性。  5. 用更加详细的文档及注释来解释代码的含义。    normalize.css支持更多的浏览器（包括手机端），同样也包括规范的HTML5元素，排版，列表，内嵌内容（embed），表单及表格的css。    ####  normalize VS reset    - **normalize.css保存了部分可用的默认样式**    reset.css为几乎所有元素统一了样式风格，但normalize保存了一些有用的默认样式，这样你就不用再对一些公共的排版元素重新声明样式。比如ul元素的margin。    - **normalize.css修复了一些bug**    normalize修复了一些常见的PC端及移动端的bug，这往往超出了reset的能力范围，这里包括了HTML5元素的显示设置，修正了预格式化文本的字体问题，在IE9上的SVG overflow 问题以及不同浏览器和操作系统与表单之间的问题。    - **normalize.css不会使你的调试工具混乱**    在页面中调试样式的时候，如果使用了reset.css，在样式调试区域就会出现大量的继承属性链，但normalize.css并不会出现这个问题，因为它的样式规则使用的是具有针对性的样式及相对保守的使用多重选择器。    - **normalize.css可以模块化**    normalize 可以被分成多个独立的部分，也就是说你可以指定你自己需要的默认样式，同时，你的项目不需要哪些样式，可以对其进行删除。    - **normalize提供了大量的文档**    normalize的代码基于非常细致的跨浏览器的研究和系统的测试，在 <https://github.com/necolas/normalize.css> 上面提供了详细的注释，这样你就能知道每行代码做了什么，为啥它会被包含进来，以及浏览器之间的差异，还有就是更容易你自己去进行测试。    #### Neat.css    [Neat.css](https://thx.github.io/cube/) 是基于[normalize](https://github.com/necolas/normalize.css)的全新的 CSS Reset，兼容 IE 6+ 以及其他现代浏览器。    「normalize」的核心理念是不盲目重置为0，让元素拥有统一的默认间距，大小等表现。但针对国内大部分网站不是纯文字排版，Neat.css 选择回归「有即是无，无即是有」的理念，把大部分标签的默认`margin`，`padding` 均重置为 0。如果你需要对大面积文字或者文档快速美化，推荐单独引入专门针对汉字排版的[`type.css`](https://thx.github.io/cube/doc/neat#)。    #### Neat.css 解决的问题    1. 解决Bug，特别是低级浏览器的常见Bug。  2. 统一效果，但不盲目追求重置为0。  3. 向后兼容。  4. 考虑响应式。  5. 考虑移动设备。  6. 跨平台最佳font family    ### css icon    <https://icomoon.io/>    <https://cssicon.space/#/>    <https://www.iconfont.cn/>    ### CSS代码检测团队项目规范    规范css代码书写    [stylelint](https://stylelint.io/)    [csshint](https://www.npmjs.com/package/csshint)    [Hint.css](https://kushagragour.in/lab/hint/)    ## css3d    ### 陀螺仪     [CSS动画之旋转魔方轮播](https://juejin.im/post/5ae1a75a6fb9a07ac3632c8c)    [3d魔方](http://jqsite.com/notes/1603085523.html)        ## css与性能优化    - 避免过度约束  - 避免后代选择符  - 避免链式选择符  - 使用紧凑的语法  - 避免不必要的命名空间  - 避免不必要的重复  - 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么  - 避免！important，可以选择其他选择器  - 尽可能的精简规则，你可以合并不同类里的重复规则    ## css未来    <https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate>    ## css库    #### parallax*.js**parallax*.*js* 是一款简单，轻量级的视差效果生成器，可以对智能设备点击运动的方向作出反应，不需要任何识别方向，检测位置的设备，只需要游标（鼠标运动的方向等）'},{title:"对象、类和继承",path:"/posts/JavaScript/object.html",strippedContent:" [[toc]]    ## 面向对象的三大特性    - 封装  - 继承  - 多态    ## 对象创建    ### 方式一：字面量    ```      var obj11 = {name: 'smyh'};      var obj12 = new Object(name: `smyh`); //内置对象（内置的构造函数）  ```    上面的两种写法，效果是一样的。因为，第一种写法，`obj11`会指向`Object`。    - 第一种写法是：字面量的方式。  - 第二种写法是：内置的构造函数    ### 方式二：通过构造函数    ```      var M = function (name) {          this.name = name;      }      var obj3 = new M('smyhvae');  ```    ### 方法三：Object.create    ```      var p = {name:'smyhvae'};      var obj3 = Object.create(p);  //此方法创建的对象，是用原型链连接的  ```    第三种方法，很少有人能说出来。这种方式里，obj3是实例，p是obj3的原型（name是p原型里的属性），构造函数是`Objecet`。    创建空对象    ````javascript  let a =Object.create(null)  ````    ![](https://img.dubiqc.com/201903/08043358.png-sign)    ## 原型与原型链    ![](https://img.dubiqc.com/201903/08043745.png-sign)    ###  原型    每个函数都有一个 prototype（原型）属性（箭头函数除外），这个属性是一个指针，指向一个对象，  而这个对象的用途是存放实例共享的属性和方法。     prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以  让所有对象实例共享它所包含的属性和方法。    原型对象默认拥有一个constructor属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。    每个对象实例都拥有一个隐藏的属性[[prototype]]，指向它的原型对象，这个属性可以通过`Object.getPrototypeOf(obj)` 或 `obj.__proto__` 来访问。    构造函数的prototype属性与它创建的实例对象的[[prototype]]属性指向的是同一个对象，即 `对象.__proto__ === 函数.prototype` 。    在JavaScript中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。    访问对象的属性时，JavaScript会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。    ### 原型、构造函数、实例三者之间的关系    ![](https://img.dubiqc.com/201903/08050808.png-sign)    - 1、构造函数通过 new 生成实例  - 2、构造函数也是函数，构造函数的`prototype`指向原型。（所有的函数有`prototype`属性，但实例没有 `prototype`属性）  - 3、原型对象中有 constructor，指向该原型的构造函数。    ### 原型链    ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。    ### `instanceof`的原理    [instanceof原理详见](/frontend/JavaScript/#instanceof)     ![](https://img.dubiqc.com/201903/08053219.png-sign)    `instanceof`的**作用**：用于判断**实例**属于哪个**构造函数**。    `instanceof`的**原理**：判断实例对象的`__proto__`属性，和构造函数的`prototype`属性，是否为同一个引用（是否指向同一个地址）。    **注意1**：虽然说，实例是由构造函数 new 出来的，但是实例的`__proto__`属性引用的是构造函数的`prototype`。也就是说，实例的`__proto__`属性与构造函数本身无关。    **注意2**：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找`__proto__`属性。这条链上如果能找到， instanceof 的返回结果也是 true。    比如说：    - `foo instance of Foo`的结果为true，因为`foo.__proto__ === M.prototype`为true。  - **foo instance of Objecet的结果也为true**，因为`Foo.prototype.__proto__ === Object.prototype`为true。    但我们不能轻易的说：`foo 一定是 由Object创建的实例`。这句话是错误的。我们来看下一个问题就明白了。    #### 分析一个问题    **问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成**的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？    分析：这就要用到原型的`constructor`属性了。    - `foo.__proto__.constructor === M`的结果为true，但是 `foo.__proto__.constructor === Object`的结果为false。    所以，用 consturctor判断就比用 instanceof判断，更为严谨。    ### new 运算符    当new Foo()时发生了什么：    （1）创建一个**新的空对象实例**，继承自foo.prototype    （2）执行构造函数foo，传入相应的参数，如果没有参数就不用传，同时 this 被指定为这个新实例。    （3）如果构造函数返回值是一个对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。    代码实现    ````javascript  /**   * new2 new关键字的代码实现演示   * @param {function} func 被new的类 (构造函数)   */  function new2() {      // 获取参数第一项，即构造函数        let Context = [].shift.call(arguments)      // 创建了一个实例对象 o，并且这个对象__proto__指向func这个类的原型对象         let o = Object.create(Context.prototype);       // (在构造函数中this指向当前实例)让这个类作为普通函数值行 并且里面this为实例对象       let result = Context.apply(o,arguments);      // 最后再将实例对象返回 如果你在类中显示指定返回值k，      // 注意如果返回的是引用类型则将默认返回的实例对象o替代掉      return typeof result === 'object' ? result : o;  }    // 实验  function M() { // 即将被new的类      this.name = 'liwenli';  }    let m = new2(M); // 等价于 new M 这里只是模拟  console.log(m instanceof M); // instanceof 检测实例  console.log(m instanceof Object);  console.log(m.__proto__.constructor === M);    ````        ## 继承的方法    ### 原型链继承    实现的本质是重写原型对象，代之以一个新类型的实例。    ```javascript  // 通过原型链实现继承        function Parent() {          this.name = 'Parent 的属性';      }        function Child() {          this.type = 'Child 的属性';      }        Child.prototype = new Parent(); //【重要】，重写原型对象        console.log(new Child());  ```    优点：    子类继承了父类以及父类原型上的属性和方法    问题：    1 **父类引用类型的属性被所有实例共享**。    2 在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是**没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数**。原因是第一点。    ### 借用构造函数继承（经典继承）    实现：在子类型构造函数的内部调用超类型构造函数。    ```javascript      function Parent1() {          this.name = 'parent1 的属性';      }        function Child1() {          Parent1.call(this);         //【重要】此处用 call 或 apply 都行：改变 this 的指向          this.type = 'child1 的属性';      }  ```    优点：相对于原型链而言，借用构造函数有一个很大的优势，即**可以在子类型构造函数中向超类型构造函**  **数传递参数**    缺点：仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——**方法都在构造函数中定**  **义，因此函数复用就无从谈起了**。而且，**在超类型的原型中定义的方法，对子类型而言也是不可见的**，结  果所有类型都只能使用构造函数模式。    ### 组合继承（伪经典继承）    实现：是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承    ```javascript    // 组合方式实现继承：构造函数、原型链        function Parent3() {          this.name = 'Parent 的属性';          this.arr = [1, 2, 3];      }        function Child3() {          Parent3.call(this); //【重要1】执行 parent方法          this.type = 'Child 的属性';      }      Child3.prototype = new Parent3(); //【重要2】第二次执行parent方法        var child = new Child3();  ```    优点：    组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点    而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。    ### 原型式继承（实例继承）    实现：createObj()对传入其中的对象执行了一次浅复制。对实例进行浅复制实现继承。    借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型    ```javascript  function createObj(o) {      function F(){}      F.prototype = o;      return new F();  }  ```    必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给 createObj()函数，然后再根据具体需求对得到的对象加以修改即可。    ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与 object()方法的行为相同。    优点：没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式  继承是完全可以胜任的。    缺点：包含引用类型值的属性始终都会共享相应的值    ### 寄生式继承    实现：寄生式继承的思路与寄生构造函数和工厂模式类似，即**创建一个仅用于封装继承过程的函数**    ```  function createAnother(o) {    var clone = Object.create(o) // 创建一个新对象    clone.sayHi = function() { // 添加方法      console.log(‘hi’)    }    return clone  // 返回这个对象  }    var person = {    name: ‘Jiang’  }    var anotherPeson = createAnother(person)  anotherPeson.sayHi()  ```    基于person返回了一个新对象anotherPeson，新对象不仅拥有了person的属性和方法，还有自己的sayHi方法    在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。    缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。    ### 寄生组合式继承    在前面说的组合模式(原型链+构造函数)中，继承的时候需要调用两次父类构造函数    父类    ```javascript  function Parent(name) {    this.name = name    this.colors = [‘red’, ‘blue’, ‘green’]  }  ```    第一次在子类构造函数中    ```javascript  function Child(name, job) {    // 继承属性    Parent.call(this, name)        this.job = job  }  ```    第二次将子类的原型指向父类的实例    ```javascript  // 继承方法  Child.prototype = new Parent()  ```    当使用`var instance = new Child()`的时候，会产生两组name和color属性，一组在Child实例上，一组在Child原型上，只不过实例上的屏蔽了原型上的    使用寄生式组合模式，可以规避这个问题    这种模式通过借用构造函数来继承属性，通过原型链的混成形式来继承方法    基本思路：**不必为了指定子类型的原型而调用父类的构造函数，我们需要的无非就是父类原型的一个副本**    **本质上就是使用寄生式继承来继承父类的原型，在将结果指定给子类型的原型**    ```javascript  function inheritPrototype(Child, Parent) {    var prototype = Object.create(Parent.prototype)    prototype.constructor = Child    Child.prototype = prototype  }  ```    该函数实现了寄生组合继承的最简单形式，这个函数接受两个参数，一个子类，一个父类。    第一步创建父类原型的副本，第二步将创建的副本添加constructor属性，第三部将子类的原型指向这个副本    ```javascript  function Parent(name) {    this.name = name    this.colors = [‘red’, ‘blue’, ‘green’]  }    Parent.prototype.sayName = function () {    console.log(this.name)  }    function Child(name, job) {    // 继承属性    Parent.call(this, name)        this.job = job  }    // 继承  inheritPrototype(Child, Parent)    var instance = new Child(‘Jiang’, ‘student’)  instance.sayName()  ```    \\> 补充：直接使用Object.create来实现，其实就是将上面封装的函数拆开，这样演示可以更容易理解    ```javascript  function Parent(name) {    this.name = name    this.colors = [‘red’, ‘blue’, ‘green’]  }    Parent.prototype.sayName = function () {    console.log(this.name)  }    function Child(name, job) {    // 继承属性    Parent.call(this, name)        this.job = job  }    // 继承  Child.prototype = Object.create(Parent.prototype)    // 修复constructor  Child.prototype.constructor = Child    var instance = new Child(‘Jiang’, ‘student’)  instance.sayName()  ```    ES6新增了一个方法，`Object.setPrototypeOf`，可以直接创建关联，而且不用手动添加constructor属性    ```javascript  // 继承  Object.setPrototypeOf(Child.prototype, Parent.prototype)    console.log(Child.prototype.constructor === Child) // true  ```    ## 对象方法与this    对象通常被用来表示真实世界中的实体，比如用户、订单等等：    ```javascript  let user = {    name: \"John\",    age: 30  };  ```    另外，在现实世界中，用户可以**操作**：从购物车中挑选某物、登录、注销等。    在 JavaScript 中，操作通过属性中的函数来表示。    ### 方法示例    刚开始，我们来让 `user` 说 hello：    ```javascript  let user = {    name: \"John\",    age: 30  };    user.sayHi = function() {    alert(\"Hello!\");  };    user.sayHi(); // Hello!  ```    这里我们使用函数表达式创建了函数，并将其指定给对象的 `user.sayHi` 属性。随后我们调用它。用户现在可以说话了！    作为对象属性的函数称之为**方法**。    那么，现在 `user` 对象有了一个 `sayHi` 方法。    当然我们也可以使用预先定义的函数作为方法，就像这样：    ```javascript  let user = {    // ...  };    // 首先声明  function sayHi() {    alert(\"Hello!\");  };    // 然后将其作为一个方法  user.sayHi = sayHi;    user.sayHi(); // Hello!  ```    > **Object-oriented programming**  >  > 当我们在代码中用对象表示实体时，这就是所谓的[面向对象编程](https://en.wikipedia.org/wiki/Object-oriented_programming)，简称为 “OOP”。  >  > OOP 是一门很大的学问，也是一门有其本身乐趣的学问。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于此方面的书，例如 E.Gamma、R.Helm、R.Johnson 和 J.Vissides 所著的《设计模式：可复用面向对象软件的基础》、G.Booch 所著的《面向对象分析与设计》等等。    ### 方法简写    在对象字面量中，有一种更短的（声明）方法的语法：    ```javascript  // 这些对象作用一样    let user = {    sayHi: function() {      alert(\"Hello\");    }  };    // 方法简写看起来更好，对吧？  let user = {    sayHi() { // 与 \"sayHi: function()\" 一样      alert(\"Hello\");    }  };  ```    如所示，我们可以省略 `\"function\"` 只写了 `sayHi()`。    说实话，这种表示法还是有些不同。与对象集成有关的细微差别（稍后将会介绍），但现在它们无关紧要。在几乎所有的情况下，较短的语法是最好的。    ### 方法中的 “this”    对象方法需要访问对象中的存储的信息完成其工作是很常见的。    举个例子，`user.sayHi()` 中的代码可能需要用到 `user` 的 name 属性。    **为了访问该对象，方法中可以使用 this 关键字。**    `this` 的值就是在点之前的这个对象，即调用该方法的对象。    举个例子：    ```javascript  let user = {    name: \"John\",    age: 30,      sayHi() {      alert(this.name);    }    };    user.sayHi(); // John  ```    在这里 `user.sayHi()` 执行过程中，`this` 的值是 `user`。    技术上讲，也可以在不使用 `this` 的情况下，通过外部变量名来引用它：    ```javascript  let user = {    name: \"John\",    age: 30,      sayHi() {      alert(user.name); // \"user\" 替代 \"this\"    }    };  ```    但这样的代码是不可靠的。如果我们将 `user` 复制给另一个变量。例如 `admin = user`，并赋另外的值给 `user`，那么它将访问到错误的对象。    如下所示：    ```javascript  let user = {    name: \"John\",    age: 30,      sayHi() {      alert( user.name ); // 导致错误    }    };      let admin = user;  user = null; // 覆盖让其更易懂    admin.sayHi(); // 噢哟！在 sayHi() 使用了旧的变量名。错误！  ```    如果在 `alert` 中以 `this.name` 替换 `user.name`，那么代码就会正常运行。    ### “this” 不受限制    在 JavaScript 中，“this” 关键字与大多数其他编程语言中的不同。首先，它可以用于任何函数。    这样的代码没有语法错误：    ```javascript   function sayHi() {    alert( this.name );  }  ```    `this` 是在运行时求值的。它可以是任何值。    例如，从不同的对象中调用同一个函数可能会有不同的 “this” 值：    ```javascript  let user = { name: \"John\" };  let admin = { name: \"Admin\" };    function sayHi() {    alert( this.name );  }    // 在两个对象中使用的是相同的函数  user.f = sayHi;  admin.f = sayHi;    // 它们调用时有不同的 this 值。  // 函数内部的 \"this\" 是点之前的这个对象。  user.f(); // John  (this == user)  admin.f(); // Admin  (this == admin)    admin['f'](); // Admin（使用点或方括号语法来访问这个方法，都没有关系。）  ```    实际上，我们可以在没有任何对象的情况下调用函数：    ```javascript  function sayHi() {    alert(this);  }    sayHi(); // undefined  ```    在这种情况下，严格模式下的 `this` 值为 `undefined`。如果我们尝试访问 `this.name`，将会出现错误。    在非严格模式（没有使用 `use strict`）的情况下，`this` 将会是**全局对象**（浏览器中的 `window`，我们稍后会进行讨论）。`\"use strict\"` 可以修复这个历史行为。    请注意，通常在没有对象的情况下使用 `this` 的函数调用是不常见的，会（导致）编程错误。如果函数中有 `this`，那么通常意味着它是在对象上下文环境中被调用的。    **The consequences of unbound `this`**    如果你来自其他的编程语言，那么你可能熟悉『绑定 `this`』的概念。在对象定义的方法中，`this` 总是指向该对象。在 JavaScript 中，`this` 是『自由』的，它的值是在调用时进行求值的，它的值并不取决于方法声明的位置，而是（取决）于在『点之前』的是什么对象。    在运行时对 `this` 求值的这个想法有其优缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性给错误留下了余地。这里我们并不是要评判编程语言的这个想法的好坏，而是要了解怎样使用它，如何趋利避害。    ### 内部：引用类型    **In-depth language feature**    本文介绍一个进阶的主题，来更好地理解一些特殊情况。    『复杂』的方法调用可能会失去 `this`，比如：    ```javascript  let user = {    name: \"John\",    hi() { alert(this.name); },    bye() { alert(\"Bye\"); }  };    user.hi(); // John (the simple call works)    // 现在我们要判断 name 属性，来决定调用 user.hi 或是 user.bye。  (user.name == \"John\" ? user.hi : user.bye)(); // Error!  ```    最后一行中有一个三元运算符，它要判断是 `user.hi` 或 `user.bye`。在这种情况下，结果会是 `user.hi`。    该方法立即被括号 `()` 调用。但它无效。    你可以看到该调用导致了错误，因为调用中的 `\"this\"` 为 `undefined`。    这样是正确的（对象点方法）：    ```javascript  user.hi();  ```    这样没有效果（对方法求值）：    ```javascript  (user.name == \"John\" ? user.hi : user.bye)(); // 错误！  ```    原因是什么？如果我们想了解为什么会这样，那么我们要深入理解 `obj.method()` 调用的原理。    仔细看，我们可能注意到 `obj.method()` 语句中有两个操作符。    1. 首先，点 `'.'` 取得这个 `obj.method` 属性。  2. 其后的括号 `()` 调用它。    那么，`this` 是如何从第一部分传递到第二部分的呢？    如果把这些操作分离开，那么 `this` 肯定会丢失：    ```javascript  let user = {    name: \"John\",    hi() { alert(this.name); }  }    // 将赋值与方法调用拆分为两行  let hi = user.hi;  hi(); // 错误，因为 this 未定义  ```    这里 `hi = user.hi` 把函数赋值给变量，其后的最后一行是完全独立的，所以它没有 `this`。    **为了让 user.hi() 有效，JavaScript 用一个技巧 —— 这个 '.' 点返回的不是一个函数, 而是一种特殊的[引用类型]的值(https://tc39.github.io/ecma262/#sec-reference-specification-type).**    引用类型是一种『规范中有的类型』。我们不能明确地指定它，但是可以在语言内部使用。    引用类型的值是三点的结合 `(base, name, strict)`，如下：    - `base` 是对象。  - `name` 是属性。  - 当 `use strict` 生效，`strict` 为真。    `user.hi` 属性访问的值不是函数，而是引用类型的值。在严格模式下，`user.hi` 是：    ```javascript  // 引用类型值  (user, \"hi\", true)  ```    当在引用类型上用 `()` 调用时，它们接收到这个对象和它的方法的所有信息，并且设定正确的 `this` 值（这里等于 `user`）。    `hi = user.hi` 赋值等其他的操作，将引用类型作为一个整体丢弃，只获取 `user.hi`（一个函数）的值进行传递。因此，进一步操作『失去』了 `this`（值）。    所以如果直接使用点 `obj.method()` 或方括号语法 `obj[method]()`（它们在这里并无差别）调用函数，那么作为结果，`this` 值会以正确的方式进行传递。    ### 箭头函数没有自己的 “this”    箭头函数有些特别：它们没有自己的 `this`。如果我们在这样的函数中引用 `this`，`this` 值取决于外部『正常的』函数。    举个例子，这里的 `arrow()` 使用的 `this` 来自外部的 `user.sayHi()` 方法：    ```javascript  let user = {    firstName: \"Ilya\",    sayHi() {      let arrow = () => alert(this.firstName);      arrow();    }  };    user.sayHi(); // Ilya  ```    这是箭头函数的一个特征，当我们并不想要一个独立的 `this` 值，反而想从外部上下文中获取时，它很有用。    ### 总结    - 存储在对象中函数称之为『方法』。  - 对象执行方法进行『操作』，比如 `object.doSomething()`。  - 方法可以将该对象引用为 `this`。    `this` 的值是在运行时求值的。    - 函数声明使用的 `this` 只有等到调用时才会有值。  - 函数可以在对象之间进行共用。  - 当函数使用『方法』语法 `object.method()` 调用时，调用过程中的 `this` 总是指向 `object`。    请注意箭头函数有些特别：它们没有 `this`。在箭头函数内部访问的都是来自外部的 `this` 值。    ## 对象方法    1. #### Object.assign(target, source1, source2, ...)    该方法主要用于对象的合并，将源对象 source 的所有可枚举属性合并到目标对象 target 上,此方法只拷贝源对象的自身属性，不拷贝继承的属性    Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。同名属性会替换    Object.assign 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制    Object.assign 可以用来处理数组，但是会把数组视为对象    ```JavaScript  const target = {      x : 0,      y : 1  };     const source = {      x : 1,      z : 2 ,      fn : {          number : 1      }  };     Object.assign(target, source);    // target  {x : 1, y : 1, z : 2, fn : {number : 1}} // 同名属性会被覆盖  // source  {x : 1, z : 2, fn : {number : 1}}  target.fn.number = 2; // 拷贝为对象引用  // source  {x : 1, z : 2, fn : {number : 2}}     function Person(){      this.name = 1  };  Person.prototype.country = 'china';  let student = new Person();  student.age = 29 ;  const young = {insterst : 'sport'};  Object.assign(young,student);  // young {instest : 'sport' , age : 29  // 只能拷贝自身的属性，不能拷贝prototype        Object.assign([1, 2, 3], [4, 5]) // 把数组当作对象来处理  // [4, 5, 3]  ```    #### 2. Object.create(prototype[,propertiesObject])    使用指定的原型对象及其属性去创建一个新的对象    ```javascript  var parent = {      x : 1,      y : 1  }     var child = Object.create(parent,{      z : { // z会成为创建对象的属性          writable:true,          configurable:true,          value: \"newAdd\"      }  });  console.log(child);  ```    #### 3. Object.defineProperties(obj,props)    直接在一个对象上定义新的属性或修改现有属性，并返回该对象    ```  var obj = {};  Object.defineProperties(obj,   {       'property1': {             value: true,            writable: true      },      'property2': {          value: 'Hello',       writable: false      } // etc. etc.  });  console.log(obj); // {property1: true, property2: \"Hello\"}  ```    #### 4. Object.defineProperty(obj,prop,descriptor)    在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象    ```  Object.defineProperty(Object, 'is',   {       value: function(x, y) {              if (x === y) { // 针对+0 不等于 -0的情况                       return x !== 0 || 1 / x === 1 / y;             }   // 针对NaN的情况              return x !== x && y !== y;         },         configurable: true,         enumerable: false,         writable: true   }); // 注意不能同时设置(writable，value) 和 get，set方法，否则浏览器会报错    // Invalid property descriptor.  Cannot both specify accessors and a value or writable attribute  ```    #### 5. [Object.keys(obj)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)    返回一个由一个给定**对象**的自身可枚举属性组成的**数组**，数组中属性名的排列顺序和使用 [for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）    ```  let arr = [\"a\", \"b\", \"c\"];  console.log(Object.keys(arr)); // ['0', '1', '2'] /* Object 对象 */    let obj = { foo: \"bar\", baz: 42 }, keys = Object.keys(obj);  console.log(keys); // [\"foo\",\"baz\"]  ```    #### 6. Object.values()    方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用 for...in 循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )    Object.values会过滤属性名为 Symbol 值的属性    ```  var an_obj = { 100: 'a', 2: 'b', 7: 'c' };  console.log(Object.values(an_obj)); // ['b', 'c', 'a']    var obj = { 0: 'a', 1: 'b', 2: 'c' };  console.log(Object.values(obj)); // ['a', 'b', 'c']  ```    #### 7. Object.entries()    返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）    ```  const obj = { foo: 'bar', baz: 42 };  console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]     const simuArray = { 0: 'a', 1: 'b', 2: 'c' };  console.log(Object.entries(simuArray)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]  ```    #### 8. hasOwnProperty()    判断对象自身属性中是否具有指定的属性    ```  obj.hasOwnProperty('name')  ```    #### 9. Object.getOwnPropertyDescriptor(obj,prop)    返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）    如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined    ```  var arr = ['name','age'] ;  arr.forEach(val => console.log(Object.getOwnPropertyDescriptor(obj,val)))  // {value: \"js\", writable: true, enumerable: true, configurable: true}  // undefined  ```    #### 10. Object.getOwnPropertyDescriptors(obj)    获取一个对象的所有自身属性的描述符    ```  var obj = {      name : 'js',      age : 20  }  console.log(Object.getOwnPropertyDescriptors(obj));  ```        ![img](https:////upload-images.jianshu.io/upload_images/4804567-998d85e9889852f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/437/format/webp)        ```  const source = {    set foo(value) {      console.log(value);    }  };     const target2 = {};  Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));  Object.getOwnPropertyDescriptor(target2, 'foo')        const obj = Object.create(    some_obj,    Object.getOwnPropertyDescriptors({      foo: 123,    })  );  ```    #### 11. Object.getOwnPropertyNames()    返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组    ```  var obj = { 0: \"a\", 1: \"b\", 2: \"c\"};     Object.getOwnPropertyNames(obj).forEach(function(val) {    console.log(val);  });        var obj = {      x : 1,      y : 2  }     Object.defineProperty(obj,'z',{      enumerable : false  });  console.log(Object.getOwnPropertyNames(obj)); // [\"x\", \"y\", \"z\"] 包含不可枚举属性 。  console.log(Object.keys(obj)); // [\"x\", \"y\"]      只包含可枚举属性 。  ```    #### 12. Object.getOwnPropertySymbols()    返回一个给定对象自身的所有 Symbol 属性的数组    #### 13. Object.getPrototypeOf()    返回指定对象的原型（内部[[Prototype]]属性的值，即**proto**，而非对象的prototype）    #### 14. isPrototypeOf()    判断一个对象是否存在于另一个对象的原型链上    #### 15. Object.setPrototypeOf(obj,prototype)    设置对象的原型对象    #### 16. Object.is()    判断两个值是否相同    - 如果下列任何一项成立，则两个值相同：    - 两个值都是 `undefined`     - 两个值都是 `null`     - 两个值都是 `true` 或者都是 `false`     - 两个值是由相同个数的字符按照相同的顺序组成的字符串    - 两个值指向同一个对象    - 两个值都是数字并且    - 都是正零 `+0`     - 都是负零 `-0`     - 都是 `NaN`     - 都是除 `0` 和 `NaN` 外的其它同一个数字    ```  Object.is('foo', 'foo'); // true  Object.is(window, window); // true     Object.is('foo', 'bar'); // false  Object.is([], []); // false     var test = { a: 1 };  Object.is(test, test); // true     Object.is(null, null); // true     // 特例  Object.is(0, -0); // false  Object.is(-0, -0); // true  Object.is(NaN, 0/0); // true  ```    #### 17. Object.freeze()    冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象    ```  var obj = {    prop: function() {},    foo: 'bar'  };     // 新的属性会被添加, 已存在的属性可能  // 会被修改或移除  obj.foo = 'baz';  obj.lumpy = 'woof';  delete obj.prop;     // 作为参数传递的对象与返回的对象都被冻结  // 所以不必保存返回的对象（因为两个对象全等）  var o = Object.freeze(obj);     o === obj; // true  Object.isFrozen(obj); // === true     // 现在任何改变都会失效  obj.foo = 'quux'; // 静默地不做任何事  // 静默地不添加此属性  obj.quaxxor = 'the friendly duck';  console.log(obj);  ```    #### 18. Object.isFrozen()    判断一个对象是否被冻结    #### 19. Object.preventExtensions()    对象不能再添加新的属性。可修改，删除现有属性，不能添加新属性    ```  var obj = {      name :'lilei',      age : 30 ,      sex : 'male'  }     obj = Object.preventExtensions(obj);  console.log(obj); // {name: \"lilei\", age: 30, sex: \"male\"}  obj.name = 'haha';  console.log(obj); // {name: \"haha\", age: 30, sex: \"male\"}  delete obj.sex ;  console.log(obj); // {name: \"haha\", age: 30}  obj.address  = 'china';  console.log(obj); // {name: \"haha\", age: 30}  ```    #### 20. Object.isExtensible()    判断对象是否是可扩展的，Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）    #### 21. Object.seal()    Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常. 不会影响从原型链上继承的属性。但 [`__proto__`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) 属性的值也会不能修改    ```  var obj = {      prop: function () {},      foo: \"bar\"    };     // 可以添加新的属性,已有属性的值可以修改,可以删除  obj.foo = \"baz\";  obj.lumpy = \"woof\";  delete obj.prop;     var o = Object.seal(obj);     assert(o === obj);  assert(Object.isSealed(obj) === true);     // 仍然可以修改密封对象上的属性的值.  obj.foo = \"quux\";     // 但你不能把一个数据属性重定义成访问器属性.  Object.defineProperty(obj, \"foo\", { get: function() { return \"g\"; } }); // 抛出TypeError异常     // 现在,任何属性值以外的修改操作都会失败.  obj.quaxxor = \"the friendly duck\"; // 静默失败,新属性没有成功添加  delete obj.foo; // 静默失败,属性没有删除成功     // ...在严格模式中,会抛出TypeError异常  function fail() {    \"use strict\";    delete obj.foo; // 抛出TypeError异常    obj.sparky = \"arf\"; // 抛出TypeError异常  }  fail();     // 使用Object.defineProperty方法同样会抛出异常  Object.defineProperty(obj, \"ohai\", { value: 17 }); // 抛出TypeError异常  Object.defineProperty(obj, \"foo\", { value: \"eit\" }); // 成功将原有值改变  ```    #### ## 22. Object.isSealed()    判断一个对象是否被密封        参考链接：    https://www.jianshu.com/p/64a2a9397f15    <https://xxxgitone.github.io/2017/06/12/JavaScript%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/>"},{title:"数组总结",path:"/posts/JavaScript/array.html",strippedContent:" [[toc]]    ## 数组的创建    数组的创建有三种方式：构造函数方式、字面量方式、ES6新增的Array.of()方法创建。    - 构造函数方式：      ```javascript    let arr = new Array(); // 创建一个空数组    let arr = new Array(10); // 创建长度为10的数组    let arr = new Array('a'); // 创建包含一个字符串元素a的数组    let arr = new Array(10, 'a'); // 创建包含10和字符串a两个元素的数组     ```      > 小结：    > 1.new 关键字是可省略的    > 2.当只传一个number类型参数时，创建的是参数指定长度的数组。**即构造函数形式创建数组，不能创建只包含一个number类型元素的数组**    - 字面量方式：      ```javascript    let arr = [10, 'a'];  // 字面量方式，即直接给数组赋值    ```    - Array.of()方法（ES6新增）：    方法的作用是将一组值（即传进来的参数）转换为数组。    该方法的作用非常类似 Array 构造器，但在使用单个数值参数的时候并不会导致特殊结果。 Array.of() 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。      ```javascript    let arr = Array.of(3);     console.log(arr); // [3]    // 参数可以是各种类型    let arr1 = Array.of(1, 'a', true, null, undefined, {name: \"zhangsan\"}, [45]);    console.log(arr1); // [ 1, 'a', true, null, undefined, { name: 'zhangsan' }, [ 45 ] ]        ```    - Array.from() 方法(es6新增)      从一个类似数组或可迭代对象中创建一个新的数组实例。      语法： `Array.from(arrayLike[, mapFn[, thisArg]])`      参数      - `arrayLike`        想要转换成数组的伪数组对象或可迭代对象。      - `mapFn (可选参数)`        如果指定了该参数，新数组中的每个元素会执行该回调函数。      - `thisArg (可选参数)`        可选参数，执行回调函数 `mapFn` 时 `this` 对象。      返回值：一个新的数组实例      ```javascript    // Array from a String    Array.from('foo');     // [\"f\", \"o\", \"o\"]        //Array from a Set    let s = new Set(['foo', window]);     Array.from(s);     // [\"foo\", window]        // Array from a Map    let m = new Map([[1, 2], [2, 4], [4, 8]]);    Array.from(m);     // [[1, 2], [2, 4], [4, 8]]        // Array from an Array-like object (arguments)    function f() {      return Array.from(arguments);    }    f(1, 2, 3);    // [1, 2, 3]        // 在Array.from中使用箭头函数    Array.from([1, 2, 3], x => x + x);      // [2, 4, 6]    ```    ## 数组的检测    两种较为准确的检测方法：    - 利用对象的toString方法：    Object.prototype.toString.call([]) === \"[object Array]\";  // true    - Array.isArray():    Array.isArray([1, 2, 3]);  // true      ```javascript    let _isArray;    if (Array.isArray) {      _isArray = Array.isArray;    } else {      _isArray = x => Object.prototype.toString.call(x) === '[object Array]';    }        export const isArray = _isArray;    ```    ## 数组的属性    - length属性：      作用：       - 设置或返回数组的长度    - 可用来增加和删除数组项      ```javascript    let arr = [1, 2];      arr.length = 1;      console.log(arr); // [1]      arr.length = 3;        console.log(arr); // [1, , ]     ```    ## 数组的方法    JavaScript的数组方法包括数组原型的方法、构造函数的方法（ES6新增部分）    ![](<https://img.dubiqc.com/chrome_WIlkQ23Fpm.png>)    上图可知通过 Array 构造函数有 Array.from() 、Array.isArray()、Array.of()三个方法。上面已经讲过。    所有数组实例都会从 [`Array.prototype`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype) 继承属性和方法。    方法可以分为**访问器方法、修改器方法以及迭代方法**。**访问器方法绝对不会改变调用它们的对象的值**，只会返回一个新的数组或者返回一个其它的期望值，**修改器方法会改变调用它们的对象自身的值**，迭代方法中有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，新添加的元素是不会被访问到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的访问操作可能会受到未预期的影响。总之，**不要尝试在迭代过程中对原数组进行任何修改**，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，不要依赖他。如果必须修改数组，则复制到一个新数组中。     针对每一个方法我们主要了解四个方面：**作用、参数、返回值、原数组是否改变**   **（一）. 原型上的方法**    1. **push()：**       作用：向数组的末尾添加一项或多项       语法：arr.push(element1, ..., elementN)       返回值：添加元素后数组的长度       分类：修改器       ```javascript     let arr = [1, 2, 3];     let temp = arr.push('a', 'b');     console.log(arr, temp); // [1, 2, 3, 'a', 'b'] 5     ```    2. **pop():**       作用：删除数组最后一项       语法：arr.pop()       返回值：从数组中删除的元素(当数组为空时返回`undefined`)。       分类：修改器       ```javascript     let arr = [1, 2, 3];     let temp = arr.pop();     console.log(arr, temp); // [1, 2] 3     ```    3. **unshift():**       作用：向数组开头添加一项或多项       语法：arr.unshift(element1, ..., elementN)       返回值：添加元素后数组的长度       分类：修改器       ```javascript     let arr = [1, 2, 3];     let temp = arr.unshift('a', 'b');     console.log(arr, temp); // ['a', 'b', 1, 2, 3] 5     ```    4. **shift():**       作用：删除数组第一项       语法：arr.shift()       返回值：从数组中删除的元素; 如果数组为空则返回`undefined` 。        分类：修改器       ```     let arr = [1, 2, 3];       let temp = arr.shift();     console.log(arr, temp); // [2, 3] 1     ```    5. **splice():**       作用：删除、插入、替换数组项。可以说是数组界的瑞士军刀，它可以做所有事情。       语法：`arr.splice(index[, deleteCount, elem1, ..., elemN])`       说明：从 `index` 开始，删除 `deleteCount` 个元素并在当前位置插入 `elem1, ..., elemN`。最后返回已删除元素的数组。       返回值：由被删除的元素组成的一个数组，如果没有删除元素，则返回空数组。       分类：修改器       ```javascript     let arr = [1, 2, 3];          //插入元素 将 deleteCount 设置为 0，就能够插入元素而不用删除：     let temp = arr.splice(1, 0, 'a', 'b'); // 在索引1的位置插入元素'a'和'b'      console.log(arr, temp); // [1, 'a', 'b', 2, 3] []          // 删除元素     let temp1 = arr.splice(1, 2); // 删除从索引1的位置开始的2项      console.log(arr, temp1); // [1, 2, 3] ['a', 'b']          // 替换一个元素     let temp2 = arr.splice(1, 1, 'a'); // 将索引1的位置的元素替换为'a'     console.log(arr, temp2); // [1, 'a', 3 ] [2]          // 替换多个元素     let temp3 = arr.splice(0, 2, 'b', 'c'); // 将索引0的位置开始的两项，替换成’b‘和’c‘     console.log(arr, temp3); // [’b‘, 'c', 3] [1, 'a']          // 只传第一个参数，则删除从第一个参数指定的位置到数组结尾的所有项     let temp4 = arr.splice(0); //从索引0的位置开始，删除后面的所有项     console.log(arr, temp4); // [] [’b‘, 'c', 3]     ```    6. **copyWithin()**       作用：将数组指定位置（start到end）的元素复制到当前数组的其他位置（target开始），这种复制会替换原位置的元素（ES6新增）       语法：arr.copyWithin(target[, start[, end]])       参数说明：       - target: 复制的目标位置（包括），即要被替换的元素开始的位置     - start: 要copy的元素的开始位置，默认0     - end: 要copy的元素的结束位置，默认为数组最后一个元素       返回值：复制替换之后的数组       分类：修改器       ```JavaScript     let arr = [1, 2, 3, 4, 5];     // 用索引0~4范围内的元素，替换索引3~4范围内的元素，因为要替换的位置只有两个，所以只将4，5替换为了1，2     let temp = arr.copyWithin(3);     console.log(arr, temp); //  [1, 2, 3, 1, 2] [1, 2, 3, 1, 2]          let arr1 = [1, 2, 3, 4, 5];     // 用索引2~4范围内的元素，替换索引3~4范围内的元素，因为要替换的位置只有两个，所以只将4，5替换为了3，4     let temp1 = arr1.copyWithin(3, 2);     console.log(arr1, temp1); // [1, 2, 3, 3, 4] [1, 2, 3, 3, 4]     ```       > 小结：     >     > > 总结上述的描述，copyWithin的作用就是在**数组长度的范围内**，复制start(包括)到end(不包括)范围内的元素，然后用上述的元替换掉从target（包括）开始到数组结尾的元素，能替换多少就替换多少    7. **reverse():**       作用：`reverse` 方法颠倒数组中元素的位置，并返回该数组的引用。       语法：：arr.reverse()       返回值：该数组的引用       分类：修改器       ```JavaScript     let arr = [1, 2, 3];     let temp = arr.reverse();     console.log(arr, temp); // [ 3, 2, 1 ] [ 3, 2, 1 ]     ```    8. **sort():**       作用：数组排序       语法：arr.sort([compareFunction])       参数说明：       - compareFunction返回值大于0时调换当前比对项的顺序，否则顺序不 变;     - 如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。       返回值：排序后的数组       分类：修改器       ```JavaScript      // 数组从小到大排序     let arr = [1, 4, 6, 7, 8, 3, 2];     let temp = arr.sort((a, b) => {         return a - b;     })     console.log(arr, temp); // [ 1, 2, 3, 4, 6, 7, 8 ] [ 1, 2, 3, 4, 6, 7, 8 ]          // 一个实用的数组排序的例子，根据对象元素的排序，排序对象在数组中的位置     let objArr = [{id: 3, name: \"lilei\"},{id: 1, name: \"hanmeimei\"},{id: 2, name: \"yimi\"}];     let tempArr = objArr.sort((a, b) => {         // 按照id从小到大的顺序，对数组中的对象进行排序         // 这个示例说明回调函数的形参a,b实际就是数组中当前进行比对的两个元素         return a.id - b.id;     });      console.log(objArr); //  [{id: 1, name: 'hanmeimei'}, {id: 2, name: 'yimi'}, { id: 3, name: 'lilei' }]     console.log(tempArr); // [{id: 1, name: 'hanmeimei'}, {id: 2, name: 'yimi'}, { id: 3, name: 'lilei'}]          ```    9. **concat():**       作用：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。       语法：var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])       参数说明：       - 参数的类型可以是任意类型。     - 不是数组类型直接按顺序拼接到数组末尾，数组类型的则将数组元素逐一取出拼接到数组末尾     - 不传则相当于复制数组       返回值：拼接后的数组       分类：访问器       ```javascript     let arr = [1,2];     let temp = arr.concat('a', {id:1}, ['lilei', 'hanmeimei']);     console.log(arr, temp); // [ 1, 2 ] [ 1, 2, 'a', { id: 1 }, 'lilei', 'hanmeimei']          // 用于复制数组     let arr = [1, 2];     let temp = arr.concat();     console.log(arr, temp);  // [ 1, 2 ] [ 1, 2 ]     ```    10. **slice():**        作用：切片，基于当前数组的一项或多项创建一个新的数组        语法：        ```js      arr.slice();      // [0, end]            arr.slice(begin);      // [begin, end]            arr.slice(begin, end);      // [begin, end)      ```         参数说明：        - `begin` 可选          从该索引处开始提取原数组中的元素（从0开始）。          如果该参数为负数，`则表示从原数组中的倒数第几个元素开始提取，``slice(-2)`表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。          如果省略 `begin`，则 `slice` 从索引 0 开始。        - `end`可选          在该索引处结束提取原数组元素（从0开始）。`slice`会提取原数组中索引从 `begin` 到 `end `的所有元素（包含begin，但不包含end）。          `slice(1,4)` 提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。          如果该参数为负数， `则它表示在原数组中的倒数第几个元素结束抽取`。 `slice(-2,-1)`表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。          如果 `end` 被省略，`则slice` 会一直提取到原数组末尾。          如果 `end 大于数组长度，slice 也会一直提取到原数组末尾。`        返回值：含有提取元素的新数组        分类：访问器        说明：`slice` 不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：        - 如果该元素是个对象引用 （不是实际的对象），`slice` 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。      - 对于字符串、数字及布尔值来说（不是 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)、[`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 或者 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean) 对象），`slice` 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。        ```JavaScript      let arr = [0, 1, 2, 3, 4];      let temp = arr.slice(1,3); // 返回从索引1（包括）位置到索引3（不包括）位置之前的元素      console.log(arr, temp); // [0, 1, 2, 3, 4] [1, 2]            // 用于复制数组      let arr = [0, 1, 2, 3, 4];      let temp = arr.slice(0); // 返回从索引0（包括）位置到数组结尾的所有元素      console.log(arr, temp); // [0, 1, 2, 3, 4] [0, 1, 2, 3, 4]      ```    11. **indexOf():**        作用：从数组开头查找元素在数组中的索引位置（ES5的方法）        语法：：`arr.indexOf(searchElement[, fromIndex = 0])`        返回值：searchElement在数组中的索引，没找到searchElement则返回-1。fromIndex开始查找的位置，其默认值为0.          分类：访问器方法        ```JavaScript       let arr = [1, 2, 3, 4, 5, 6, 2];       // 从数组开头开始查找       let temp = arr.indexOf(2);       console.log(arr, temp); // [ 1, 2, 3, 4, 5, 6, 2 ] 1       // 从指定的位置开始查找       let temp1 = arr.indexOf(2,3); // 从索引3(包括)的位置向后查找元素2       console.log(arr, temp1); // [ 1, 2, 3, 4, 5, 6, 2 ] 6      ```    12. **lastIndexOf():**        作用：从数组结尾查找元素在数组中的索引位置（ES5的方法）        语法：arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])        返回值：searchElement在数组中的索引，没找到searchElement则返回-1         分类：访问器        ```JavaScript       let arr = [1, 2, 3, 4, 5, 6, 2];       // 从数组末尾开始查找       let temp = arr.lastIndexOf(2);       console.log(arr, temp); // [ 1, 2, 3, 4, 5, 6, 2 ] 6       // 从指定的位置开始查找       let temp1 = arr.lastIndexOf(2,3); // 从索引3(包括)的位置向前查找元素2       console.log(arr, temp1); // [ 1, 2, 3, 4, 5, 6, 2 ] 1      ```    13. **every():**        作用：对数组中的每一项运行给定函数，如果该函数对每一项都返回true,则返回true（ES5方法）        语法：callback[, thisArg]        参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)        返回值：true 或 false      分类： 迭代方法        ```JavaScript       let arr = [1, 2, 3, 4];       let temp = arr.every((item, index, array) => {           return item > 2;       });       console.log(arr, temp); // [ 1, 2, 3, 4 ] false              // 方法的第二个参数可选，作用是设定第一个参数中的this指向，如果使用第二个参数，注意callback不能是箭头函数       // 后面的迭代方法涉及此参数的，用法相同，不在赘述       let arr = [1, 2, 3, 4];       let temp = arr.every(function(item, index, array) {           return item > this.id;       }, {id: 2});       console.log(arr, temp); // [ 1, 2, 3, 4 ] false      ```    14. **some():**        作用：对数组中的每一项运行给定函数，如果该函数对任意一项返回true,则返回true（ES5方法）        语法：callback[, thisArg]      参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)      返回值：true 或 false      分类： 迭代方法        ```js       let arr = [1, 2, 3, 4];       let temp = arr.some((item, index, array) => {           return item > 2;       });       console.log(arr, temp); // [ 1, 2, 3, 4 ] true      ```    15. **filter():**        作用：对数组中的每一项运行给定函数，返回该函数返回true的项组成的数组（ES5方法）        语法：callback[, thisArg]        参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)        返回值：函数返回true的项组成的数组      分类： 迭代方法        ```js       let arr = [1, 2, 3, 4];       let temp = arr.filter((item, index, array) => {           return item > 2;       });       console.log(arr, temp); // [ 1, 2, 3, 4 ] [3, 4]      ```    16. **map():**        作用：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组（ES5方法）        语法：callback[, thisArg]        参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)        返回值：函数每次调用结果组成的数组        分类： 迭代方法        ```JavaScript       let arr = [1, 2, 3, 4];       let temp = arr.map((item, index, array) => {           return item * item;       });       console.log(arr, temp); // [ 1, 2, 3, 4 ] [ 1, 4, 9, 16]      ```    17. **forEach():**        作用：对数组中的每一项运行给定函数。无返回值（ES5方法）        语法：callback[, thisArg]        参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)        返回值：无        原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。        ```JavaScript       let arr = [1, 2, 3, 4];       let temp = arr.forEach((item, index, array) => {           // 不会有返回值，但可在这里执行某些操作           return item * item;       });       console.log(arr, temp); // [ 1, 2, 3, 4 ] undefined      ```        > 注意：      > forEach在所有项都遍历完成之前，无法像for循环一样提前终止循环    18. **reduce():**        作用：从数组的第一项开始，逐步遍历到最后，迭代数组的所有项（ES5方法）        语法：callback[, initialValue]        参数说明：        - callback迭代函数，有四个参数（prev, cur, index, array）         - prev 前一个值，（initialValue || 数组第一项 || 上一次迭代的结果）        - cur 当前迭代项        - index 当前迭代项索引        - array 迭代的原数组      - initialValue 迭代的基础值，不传基础值是数组第一项         返回值：数组迭代后，整体的迭代结果        原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。        ```JavaScript       // 数组求和       let arr = [1, 2, 3];       let sum = arr.reduce((prev, cur, index, array) => {           return prev + cur;       });       console.log(arr, sum); // [ 1, 2, 3 ] 6              // 传initialValue 基础值的示例       let sum1 = arr.reduce((prev, cur, index, array) => {           return prev + cur;       }, 10);       // 返回的值是：10+1+2+3       console.log(arr, sum1); // [ 1, 2, 3 ] 16             ```        > **reduce源码的实现**：      >      > ```      > Array.prototype.myReduce = function(callback, initialVal){      > let prev = initialVal || this[0];       >  for(var i = pre ? 0 : 1; i < this.length; i++){      >      prev = callback(prev, this[i], i, this);      > }      > return prev      > }      >       > ```    19. **reduceRight():**        作用：从数组的最后一项开始，逐步遍历到第一项，迭代数组的所有项（ES5方法）       语法：callback[, initialValue]        参数说明：        - callback迭代函数，有四个参数（prev, cur, index, array）         - prev 前一个值，（initialValue || 数组第一项 || 上一次迭代的结果）        - cur 当前迭代项        - index 当前迭代项索引        - array 迭代的原数组      - initialValue 迭代的基础值，不传基础值是数组第一项         返回值：数组迭代后，整体的迭代结果        原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。        ```       // 拼接字符串,从后向前迭代数组进行拼接       let arr = ['h', 'e', 'l', 'l', 'o'];       let str = arr.reduceRight((prev, cur, index, array) => {           return prev + cur;       });       console.log(arr, str); // [ 'h', 'e', 'l', 'l', 'o' ] 'olleh'             ```    20. **find():**        作用：查找数组中第一个符合条件的元素，返回该元素 (ES6新增)       语法：callback[, thisArg]        参数说明：参数的使用同上述的forEach、every、map、some、filter方法一致        返回值：查找到则返回该元素，没找到返回undefined        原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。        ```       let arr = [1, 2, 3, 4, 5];       let temp = arr.find((item, index, array) => {           return item > 2;       })       console.log(arr, temp); // [1, 2, 3, 4, 5] 3             ```    21. **findIndex():**        作用：查找数组中第一个符合条件的元素所在位置的索引，并返回该索引值       语法：callback[, thisArg]        参数说明：参数的使用同上述的forEach、every、map、some、filter方法一致        返回值：查找到则返回该索引值，没找到返回-1        原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。        ```       let arr = [1, 2, 3, 4, 5];       let temp = arr.findIndex((item, index, array) => {           return item > 2;       })       console.log(arr, temp); // [1, 2, 3, 4, 5] 2             ```    22. **fill():**        作用：用指定元素，填充数组从start(包括)到end（不包括）之间的元素，如果该区间内已经有元素，直接替换掉（ES6新增）       语法：value[, start[, end]]        返回值：填充后的数组       分类：修改器        ```       let arr = [1, 2, 3, 4, 5];       let temp = arr.fill('a', 2, 4);       console.log(arr, temp); // [1, 2, 'a', 'a', 5] [1, 2, 'a', 'a', 5]             ```    23. **includes():**        作用：判断数组中是否包含指定的元素（ES7新增）       语法：searchElement[, fromIndex]        返回值：true或false        原数组是否改变：否        ```       let arr = [1, 2, 3, 4, 5];       let temp = arr.includes(5);       console.log(arr, temp); // [1, 2, 3, 4, 5] true              // 这个方法弥补了indexOf查看元素时的一个不足，即查找NaN的误差       let arr1 = [NaN, 'a'];       let temp1 = arr1.includes(NaN);       let temp2 = arr1.indexOf(NaN);       console.log(temp1, temp2); // true -1             ```    24. **toString()、toLocalString():**        作用：调用数组每一项的toString()方法，返回的是以逗号分隔的字符串       语法：无        返回值：转化后的字符串        原字数组是否改变：否        ```       let arr = [1, [1, 2, [4]], {name: \"zhangsan\"}, 3];       let temp = arr.toString();       console.log(arr); [ 1, [ 1, 2, [ 4 ] ], { name: 'zhangsan' }, 3 ]        console.log(temp); // '1,1,2,4,[object Object],3'             ```    25. **join():**        作用：将数组元素转化为字符串(调用每个元素的toString方法)，并使用指定的分隔符（默认为逗号）进行拼接，返回拼接后的字符串         语法：分隔符，默认为逗号（，）        返回值：拼接后的字符串        原数组是否改变：否        ```JavaScript       let arr = [1, [1, 2, [4]], {name: \"zhangsan\"}, 3];       let temp = arr.join();       console.log(arr); [ 1, [ 1, 2, [ 4 ] ], { name: 'zhangsan' }, 3 ]        console.log(temp); // '1,1,2,4,[object Object],3'              // 数组求和       let arr1 = [1, 2, 3];       console.log(eval(arr1.join('+'))); // 6             ```    > 原型方法的总结：  > \\1. 数组的方法无外乎是对数组的增删改查、转换、迭代。增、删、改都会改变原有的数组，查、转换的方法不涉及callback参数的不会改变原数组，涉及到的则视情况而定，迭代方法因为均涉及到callback参数，因此也不确定。  > 那么为什么涉及到callback就不确定了呢？？？  > 首先如果直接在callback中操作原数组，那肯定原数组会改变。例如：  >  > ```JavaScript  > let arr = [1,2,3,4];      > let temp = arr.forEach((item,index,array) => {    > // 直接通过索引操作原数组    > array[index] *= item;  > });    > console.log(arr,temp); // [1, 4, 9, 16] undefined    >   > ```  >  > 如果不是直接操作原数组，而是操作callback的item参数的时,如果item是基本数据类型则原数组中对应的该项元素不会改变，如果是引用类型（数组，对象、函数等）则改变，因为操作引用类型的值，实质是操作该值所在存贮地址的内容，而item对应的原数组中的元素和item是同一引用地址，因此会导致原数组中对应元素改变。(小伙伴们对这里如果还是不理解，可以看下数组方法polyfill的实现，这里不再赘述)  > \\2. 所有涉及索引的方法，开始位置都是在操作范畴的，结束位置都是不包括在操作范围内的    **（二）.构造函数的方法**    - **Array.from():**    作用：将类数组转化为数组    参数：arrayLike[, mapFn[, thisArg]]    参数说明：      - arrayLike：类数组对象，可以是我们常见的nodeList、arguments、字符串、iterable对象等    - mapFn: 对转化后的数组进行操作的回调函数    - thisArg: 指定mapFun中的this      返回值：转化后的数组，如果有mapFn,则返回结果是经过mapFn处理的数组     原类数组是否改变：不使用mapFn，则类数组不改变。使用mapFn则结果同上述迭代方法中使用callback的情况一致。      ```javascript    let str = 'hello';    let temp = Array.from(str);    console.log(str, temp); // hello [ 'h', 'e', 'l', 'l', 'o' ]    let temp1 = Array.from(str, (item, index) => {        return item.toUpperCase();    });    console.log(str, temp1); // hello [ 'H', 'E', 'L', 'L', 'O' ]    ```      > 小结：    >    > > Array.from() 等价于 Array.prototype.slice.call(arguments,0)    ### 数组扩展运算符（ES6新增）    ------    数组的扩展运算符可以将数组转化为以逗号分割的参数序列。   几个简单使用的应用场景：    1. 将数组通过扩展运算符转化为参数序列直接传参，无需使用apply转化了       ```JavaScript     let arr = [1, 2, 3];          // apply写法     Math.min.apply(null, arr)          // 扩展运算符写法     Math.min(...arr)     ```    2. 可以用于复制和拼接数组       ```JavaScript     let arr1 = [2, 3, 4];     let arr2 = ['a', 'b', 'c'];          // 拼接数组arr1和arr2     console.log([...arr1, ...arr2]); // [2, 3, 4, 'a', 'b', 'c']     ```    3. 可用于将字符串分解为真正的数组，       ```JavaScript     […'hello']  // [ 'h', 'e', 'l', 'l', 'o' ]     ```            参考链接：https://juejin.im/post/5acb6186518825556a72b79b    ## 数组技巧    ### 去重    方法一、set +扩展符    ```javascript  const array = ['🐑', 1,  2, '🐑','🐑', 3];    // Step 1  const uniqueSet = new Set(array);  // Set { '🐑', 1, 2, 3 }    // Step 2  const backToArray = [...uniqueSet];  // ['🐑', 1, 2, 3]    //or   const backToArray1 = [...new Set(array)];  ```    方法二、set + Array.from    ```js  const array = ['🐑', 1,  2, '🐑','🐑', 3];    Array.from(new Set(array));    // ['🐑', 1, 2, 3]  ```    方法三、array.filter    ```javascript  const array = ['🐑', 1,  2, '🐑','🐑', 3];    array.filter((item, index) => array.indexOf(item) === index);  ```    方法四、reduce    ```javascript  const array = ['🐑', 1,  2, '🐑','🐑', 3];    array.reduce((unique, item) => {    return unique.includes(item) ? unique : [...unique, item]  }, []); // 👈 The initial value of our Accumulator is an empty array     // RESULT:  // ['🐑', 1, 2, 3];  ```    方法五、循环    ```javascript  function unique(arr) {    let result = [];      for (let str of arr) {      if (!result.includes(str)) {        result.push(str);      }    }      return result;  }    let strings = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",    \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"  ];    alert( unique(strings) ); // Hare, Krishna, :-O  ```    "},{title:"前端跨域问题各种解决方案（开发环境中）",path:"/posts/%E8%B7%A8%E5%9F%9F.html",strippedContent:" ### 什么是跨域      域（Domain）是网络中独立运行的单位，域之间相互访问则需要建立信任关系（即Trust Relation）。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配资源，使不同的域之间实现网络资源的共享与管理。跨域访问是指，没有建立信任关系的两个域之间通讯，但是由于安全原因，跨域访问是被各大浏览器所默认禁止的。    ### 哪些属于跨域      浏览器遵循同源次略，非同源即为跨域，非同源分为三种。    - host不一致。  - 端口不一致。  - 协议不一致。      上面三种，任意满足一种都是跨域，在请求的时候就会报错。根据上面的原理，我们可以发现在开发中，我们在浏览器打开的我们本地页面地址和请求地址不在一个源中，所以产生了跨域。    下表给出了相对 <http://store.company.com/dir/page.html> 同源检测的示例:    | URL                                               | 结果 | 原因                 |  | ------------------------------------------------- | ---- | -------------------- |  | <http://store.company.com/dir/inner/another.html> | 成功 | 同一域名             |  | <http://store.company.com/dir2/other.html>        | 成功 | 同一域名下不同文件夹 |  | <https://store.company.com/secure.html>           | 失败 | 不同的协议 ( https ) |  | <http://store.company.com:81/dir/etc.html>        | 失败 | 不同的端口 ( 81 )    |  | <http://news.company.com/dir/other.html>          | 失败 | 不同的主机 ( news )  |        ### 解决跨域的方法和原理    \x3c!--more--\x3e       我们知道了跨域的原理，那么开发中，应该如何解决这个问题呢？    #### 反向代理    前面我们了解了，跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制，反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收internet上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给internet上请求链接的客户端。比如，我们常用的gulp、grunt、webpack这些脚手架都是通过这种原理解决的跨域。    具体实现：    **1.使用gulp脚手架解决跨域**    gulp中有两个解决跨域的包有gulp-connect-proxy、http-proxy-middleware，拿http-proxy-middleware为例，需要与gulp-connect一起使用：    ```js      var gulp = require('gulp');              var proxy = require('http-proxy-middleware');          var connect = require('gulp-connect');          gulp.task('server', function() {              connect.server({                   root: 'app',                   livereload: true,                   host: 'localhost',                   port: \"8080\",                   middleware: function(req, res, next) {                     return [                               proxy('/', {                               target: 'targeturl',                               changeOrigin: true                                  })                              ];                          }                      });                  });      gulp.task('default', ['server'], function() {                    });  ```    **2.使用grunt脚手架解决跨域**    grunt和gulp其实是类似的，都是需要先连接本地服务，然后设置代理，grunt使用的的跨域插件是grunt-connect-proxy，需要与grunt-contrib-connect一起使用：    ```js      connect: {      options: {                 port: ‘8080‘,                 hostname: ‘localhost‘,                 protocol: ‘http‘,                 open: true,                 base: {                 path: ‘./‘,                  options: {                  index: ‘html/index.html‘                          }                      },                      livereload: true                  },                  proxies: [                      {                          context: ‘/‘ + API_NAME,                          host: ‘localhost‘,                          port: ‘8080‘,                          https: false,                          changeOrigin: true,                          rewrite: proxyRewrite                      }                  ],                  default: {},                  proxy: {                      options: {                          middleware: function (connect, options) {                          if (!Array.isArray(options.base)) {                                  options.base = [options.base];                              }              // Setup the proxy              var middlewares = [require(‘grunt-connect-proxy/lib/utils‘).proxyRequest];              // Serve static files.              options.base.forEach(function (base) {                  middlewares.push(serveStatic(base.path, base.options));              });              // Make directory browse-able.              /*var directory = options.directory || options.base[options.base.length - 1];               middlewares.push(connect.directory(directory));               */              return middlewares;           }         }       }      }             ```    **3.使用grunt脚手架解决跨域**    webpack如今在前端的三大框架中使用的比较广泛，我们以vue为例子，vue-cli中config/index.js中是这样配置代理的：    ```js  port: 8090,      proxyTable: {                  '/': {                   target: targeturl,                   changeOrigin: true,                   pathRewrite: {                        '^/': '/'                        },                     }           }js  ```    我们可以看到，这三种方式都是需要本地先开启服务的，target配置请求服务器的地址， Rewrite配置代理规则， changeOrigin设为true意思是同意将主机头的来源更改为目标URL。    这种代理解决跨域，前端正常写ajax就行。    #### Jsonp    Jsonp是通过web页面所有拥有src属性的标签都拥有跨域能力的属性，使客户端通过像调用脚本一样的方式，调用跨域服务器生成的js格式文件来获取数据。    具体实现如下。    服务端代码：    ```js      router.get('/jsonp', function(req, res, next) {      var userName = req.query.uname;      var password = req.query.pwd;      var data = {          code: 200,          user: userName,          password: password      }      res.jsonp(data);      });  ```    前端端代码：    ```js      $.ajax({      async: true,      url: \"http://localhost:3000/jsonp\",      type: \"GET\",      dataType: \"jsonp\", // 返回的数据类型，设置为JSONP方式      jsonp: 'callback', //指定一个查询参数名称来覆盖默认的 jsonp 回调参数名 callback      jsonpCallback: 'xxx', //设置回调函数名      data: {          \"uname\": 'jsonp',          \"pwd\": \"456\"      },      success: function(response, status, xhr) {          console.log(response);      },      });  ```    #### Cors    Cross-Origin Rseouce Sharing（cors）跨域资源共享是W3C定义的通过使用自定义的http请求头，实现跨域访问资源时，浏览器和服务器之间的正常通讯，相比jsonp，cors更加先进方便可靠。    具体实现如下。    服务端代码：    ```js      router.get('/cors', function(req, res, next) {      var userName = req.query.uname;      var password = req.query.pwd;      var data = {          code: 200,          user: userName,          password: password      }      res.header(\"Access-Control-Allow-Origin\", \"*\"); // *代表接受任何域名跨域,可使用指定ip替换*      res.header('Access-Control-Allow-Methods', 'GET, POST');//用来列出浏览器的cors请求还会用到那些http方法.      res.header('Access-Control-Allow-Headers', 'X-Requested-With,content-type, Authorization');//用来指定浏览器cors请求发送的头信息字段,可不写      res.send(data);  });  ```    前端端代码：    ```js      $.ajax({      url: \"http://localhost:3000/cors\",      type: \"get\",      data: {          \"uname\": 'cors',          \"pwd\": \"123\"      },      success: function(data) {          console.log(data);      },      error: function() {          console.log('fail');      }      });  ```    #### 端口转发映射    端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为，其使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。当我们把端口转发到与请求服务器相同的时候，就同源了，也不会出现跨域。    具体实现：    过程:    （1）启动网卡的转发功能：1 > /proc/sys/net/ipv4/ip_forward    （2）增加转发规则    ```js     iptables -t nat -A PREROUTING -p tcp -i eth0 --dport 本机端口 -j DNAT --to 需转发的ip:端口     iptables -t nat -A POSTROUTING -j MASQUERADE     for example: 我们当前ip为123.0.0.1我们想通过1230.0.0.1访问2340.0.0.1:90的服务     iptables -t nat -A PREROUTING -p tcp -i eth0 --dport 80 -j DNAT --to 2340.0.0.1:90     iptables -t nat -A POSTROUTING -j MASQUERADE  ```    （3）查询本机转发规则    ```js     iptables -t nat -L -n  | grep 80     这会出现所有80端口转发的规则  ```    （4）删除规则    ```js     iptables -t nat -D PREROUTING -p tcp -i eth0 --dport 本机端口 -j DNAT --to 需转发的ip:端口  ```    另外，做本机端口转发，需要配置output链本机访问外网的端口会转发到本地，导致访不到外网，如访问woniuchiyum.top，实际上是访问到本地，建议不做80端口的转发或者指定目的 -d localhost)：    ```js     iptables -t nat -A OUTPUT -d localhost -p tcp --dport 80 -j REDIRECT --to-ports 8080  ```    > PS：同一端口可以转发至多个ip，优先访问的是规则第一条，如果找不到会找下一个，全部找不到才会爆404。    如本机端口在转发时已被使用，那么域名解析时，优先指向本机ip，然后才是被转发ip，但是使用IP访问的时候，是转发ip的服务。    #### 内网穿透    内网穿透其实就是高性能的反向代理服务器是一样的。但是是想方式和gulp，Grunt等等不同，配置更为简单方便。    具体实现：    （1）在frp官网下载源码，[中文网址详见这里](http://getfrp.yzxx-soft.com/)。    （2）我们将 frps 及 frps.ini 放到具有公网 IP 的服务器上，修改frps.ini 文件：    ```js  [common]  bind_port = 7000   //绑定端口,自定义,需要与 frp.ini 中server_port保持一致  vhost_http_port = 8080  //访问端口,自定义  ```    （3）启动frps，Windows 直接点击 frps.exe 运行，mac 根目录下终端运行./frps -c ./frps.ini。    （4）将frp 及 frpc.ini 放到本地，修改frpc.ini 文件：    ```js  [common]  server_addr = xxxx //服务器公网ip  server_port =  7000 //需要与 frps.ini 中server_port保持一致  [web]  type = http    local_port = 8080   //本地服务端口  local_addr = 10.10.50.37  //本机的ip windows cmd运行ipconfig mac 终端运行 ifconfig查看本机ip  custom_domains = 服务器域名  ```    （5）本地启动frp，windows直接点击frp.exe运行，mac 根目录下终端运行./frpc -c ./frpc.ini。    （6）浏览器输入 frp.ini中设置的服务器域名：frps.ini中设置的访问端口，即可访问。    附：    - 本地启动frp之前，需要先启动本地的web服务。  - frp官网中frp.ini文件没有设置 local_addr，但是不设置这个运行frps.ini 会报错get hostname error，这个大家自己测试。    #### 修改浏览器配置    除了上述的代码修改意外，有个超级简单，但是不怎么推荐大家使用的方法，就是修改浏览器配置，关闭安全策略。前面说了跨域访问是被各大浏览器所默认禁止的，但是如果我们在开发的时候不禁止也是可以的。    chrome是前端开发中很好的调试浏览器，里面就有关闭安全策略，允许访问的设置。    注意，设置关闭安全策略之前，请先关掉chrome。    mac:    打开终端输入命令行    ```js  //chrome 浏览器  open -a \"Google Chrome\" --args --disable-web-security  --user-data-dir  //safari mac电脑safari也可以设置  open -a '/Applications/Safari.app' --args --disable-web-security --user-data-dir   ```    windows下：    **1.命令行打开**    首先找到chrome.exe图标，查看当前路径，粘贴保存路径，然后在cmd输入    chrome.exe路径 --disable-web-security --user-data-dir    **2.配置快捷方式打开**    新建桌面快捷方式，快捷方式后面空一格加上下面这句话 --disable-web-security --user-data-dir 然后就ok了。    注意：除了jsonp ，端口映射，cors这三种方式外，别的跨域解决方式只是在我们开发环境中解决了跨域，发布环境如果存在某一种非同源条件还是有跨域问题的。所以，需要根据不同场景，选择适合我们的跨域解决方案。那么如何选择适合我们的跨域方式呢？    - 普通html页面开发，代码部署路径和后端服务在同一服务器下面。 荐使用gulp，理由：简单容易搭建，gulp还可扩展打包，压缩等等服务。第二推荐grunt，grunt和gulp本来就相同，但是相对写gulp的server和watch操作更简单。  - 使用vue angular react框架，代码部署路径和后端服务在同一服务器下面。    建议使用webpack，框架中一般vue-cli angular-cli都带已经有webpack的配置了，我们只用配置代理路径就可以。    - 微信公众号的开发，代码部署路径和后端服务在同一服务器下面。    建议使用内网穿透，微信公众号的开发相对来说比较麻烦，因为我们除了要解决前后端分离的跨域问题，我们调试微信jdk的时候，必须在微信开发工具中调试，也就是说，每次更改代码都需要部署到服务器，然后才可以调试，使用内网穿透可以很好解决这个问题。因为内网穿透直接把我们本地代码映射到了服务器。    - sso等等后端服务和前端服务不在同一台服务器上    建议使用cors，当多个在不同服务器的前端系统共用一个接口，或者别的前后端在不同服务器上时候，cors是一劳永逸的最便捷的方式。"},{title:"组件：通信 angular、vue组件间通信",path:"/posts/component/%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF.html",strippedContent:" ## 组件：组件间通讯    ![enter image description here](http://images.gitbook.cn/08a931a0-ae67-11e7-8003-dd1d9d56caa7)    组件就像零散的积木，我们需要把这些积木按照一定的规则拼装起来，而且要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。    在真实的应用中，组件最终会构成树形结构，就像人类社会中的家族树一样：    ![enter image description here](http://images.gitbook.cn/891636a0-af23-11e7-b111-4d6e630f480d)    在树形结构里面，组件之间有几种典型的关系：父子关系、兄弟关系、没有直接关系。    相应地，组件之间有以下几种典型的通讯方案：    - 直接的父子关系：父组件直接访问子组件的 public 属性和方法。  - 直接的父子关系：借助于 @Input 和 @Output 进行通讯  - 没有直接关系：借助于 Service 单例进行通讯。  - 利用 cookie 和 localstorage 进行通讯。  - 利用 session 进行通讯。    无论你使用什么前端框架，组件之间的通讯都离开不以上几种方案，这些方案与具体框架无关。    \x3c!--more--\x3e     ## Angular组件间通讯    ### 直接调用    对于有直接父子关系的组件，父组件可以直接访问子组件里面 public 型的属性和方法，示例代码片段如下：    ```  <child #child></child>  <button (click)=\"child.childFn()\" class=\"btn btn-success\">调用子组件方法</button>  ```    显然，子组件里面必须暴露一个 public 型的 childFn 方法，就像这样：    ```  public childFn():void{      console.log(\"子组件的名字是>\"+this.panelTitle);  }  ```    以上是通过在模板里面定义局部变量的方式来直接调用子组件里面的 public 型方法。在父组件的内部也可以访问到子组件的实例，需要利用到 @ViewChild 装饰器，示例如下：    ```  @ViewChild(ChildComponent)  private childComponent: ChildComponent;  ```    关于 @ViewChild 在后面的内容里面会有更详细的解释。    很明显，如果父组件直接访问子组件，那么两个组件之间的关系就被固定死了。父子两个组件紧密依赖，谁也离不开谁，也就都不能单独使用了。所以，除非你知道自己在做什么，最好不要直接在父组件里面直接访问子组件上的属性和方法，以免未来一改一大片。    ### @Input 和 @Output    我们可以利用 @Input 装饰器，让父组件直接给子组件传递参数，子组件上这样写：    ```  @Input()  public panelTitle:string;  ```    父组件上可以这样设置 panelTitle 这个参数：    ```  <child panelTitle=\"一个新的标题\"></child>  ```    @Output 的本质是事件机制，我们可以利用它来监听子组件上派发的事件，子组件上这样写：    ```  @Output()  public follow=new EventEmitter<string>();  ```    触发 follow 事件的方式如下：    ```  this.follow.emit(\"follow\");  ```    父组件上可以这样监听 follow 事件：    ```  <child (follow)=\"doSomething()\"></child>  ```    我们可以利用 @Output 来自定义事件，监听自定义事件的方式也是通过小圆括号，与监听 HTML 原生事件的方式一模一样。    ### 利用 Service 单例进行通讯    ![enter image description here](http://images.gitbook.cn/d2615600-af23-11e7-9203-4582e2e80f6b)    如果你在根模块（一般是 app.module.ts）的 providers 里面注册一个 Service，那么这个 Service 就是全局单例的，这样一来我们就可以利用这个单例的 Service 在不同的组件之间进行通讯了。    - 比较粗暴的方式：我们可以在 Service 里面定义 public 型的共享变量，然后让不同的组件都来访问这块变量，从而达到共享数据的目的。  - 优雅一点的方式：利用 RxJS，在 Service 里面定义一个 public 型的 Subject（主题），然后让所有组件都来subscribe（订阅）这个主题，类似于一种“事件总线”的效果。    实例代码片段：    ```  import { Injectable } from '@angular/core';  import { Observable } from 'rxjs/Observable';  import { Subject } from 'rxjs/Subject';    /**   * 用来充当事件总线的Service   */  @Injectable()  export class EventBusService {    public eventBus:Subject<string> = new Subject<string>();      constructor() { }    }  import { Component, OnInit } from '@angular/core';  import { EventBusService } from '../service/event-bus.service';    @Component({    selector: 'child-1',    templateUrl: './child-1.component.html',    styleUrls: ['./child-1.component.css']  })  export class Child1Component implements OnInit {      constructor(public eventBusService:EventBusService) { }      ngOnInit() {    }      public triggerEventBus():void{      this.eventBusService.eventBus.next(\"第一个组件触发的事件\");    }  }  import { Component, OnInit } from '@angular/core';  import { EventBusService } from '../service/event-bus.service';    @Component({    selector: 'child-2',    templateUrl: './child-2.component.html',    styleUrls: ['./child-2.component.css']  })  export class Child2Component implements OnInit {    public events:Array<any>=[];      constructor(public eventBusService:EventBusService) {      }      ngOnInit() {      this.eventBusService.eventBus.subscribe((value)=>{        this.events.push(value+\"-\"+new Date());      });    }  }  ```    ### 利用 cookie 或者 localstorage 进行通讯    ![enter image description here](http://images.gitbook.cn/e9aaf1e0-af23-11e7-b111-4d6e630f480d)    示例代码片段：    ```  public writeData():void{      window.localStorage.setItem(\"json\",JSON.stringify({name:'jinjun',age:18}));  }  var json=window.localStorage.getItem(\"json\");  // window.localStorage.removeItem(\"json\");  var obj=JSON.parse(json);  console.log(obj.name);  console.log(obj.age);  ```    **很多朋友写 Angular 代码的时候出现了思维定势，总感觉 Angular 会封装所有东西，实际上并非如此。比如 cookie、localstorage 这些东西都可以直接用原生的 API 进行操作的。千万别忘记原生的那些 API 啊，都能用的！**    ### 利用 session 进行通讯    ![enter image description here](http://images.gitbook.cn/79246040-af24-11e7-b111-4d6e630f480d)    ## Vue组件间通讯    ###  现代通信方式: FLUX VUEX    **FLUX将一个应用分成四个部分**:[文档](https://link.juejin.im/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F01%2Fflux.html)    1. View： 视图层  2. Action（动作）：视图层发出的消息（比如mouseClick）  3. Dispatcher（派发器）：用来接收Actions、执行回调函数  4. Store（数据层Model）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面    flux最大的特性是“单向数据流”，具体流程：    1. 用户访问 View,  2. View 发出用户的 Action,  3. Dispatcher 收到 Action，要求 Store 进行相应的更新  4. Store 更新后，发出一个”change”事件  5. View 收到”change”事件后，更新页面     [![img](https://user-gold-cdn.xitu.io/2017/10/23/37363e31f10108cfbebdd300193fe6dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)](https://link.juejin.im/?target=http%3A%2F%2Fzhentaoo.com%2Fimg%2Fflux.png)    **VUEX**:[官方文档](https://link.juejin.im/?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh-cn%2Fintro.html)  Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。  我们把组件的共享状态抽取出来，以一个全局单例模式管理,在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！  注：action可以是异步的，但mutations一定是同步的    对于一个的VUEX应用来说,FLUX的概念被具化成：    1. VUE: 视图层  2. Action（动作）：视图层发出的消息（比如mouseClick）  3. Mutations（派发器）：用来接收Actions、执行回调函数  4. State（数据层Model）：用来存放应用的状态，一旦发生变动，就提醒Vue要更新页面     [![vuex](https://user-gold-cdn.xitu.io/2017/10/23/45f2d7c2f94cfdc3fe3c72041319ce85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)](https://link.juejin.im/?target=http%3A%2F%2Fzhentaoo.com%2Fimg%2Fvuex.png)vuex    ### 父子组件通信:props，events    **父->子**: 父组件使用 props 把数据传给子组件,文档如下  [cn.vuejs.org/v2/guide/co…](https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html%23%E4%BD%BF%E7%94%A8-Prop-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE)    ```  <child message=\"hello!\"></child>  ```    ```  Vue.component('child', {    // 声明 props    props: ['message'],    // 就像 data 一样，prop 可以用在模板内    // 同样也可以在 vm 实例中像 “this.message” 这样使用    template: '<span>{{ message }}</span>'  })  ```    需要**注意**的是，子组件不能修改父组件的props  因为一个父组件下可能有多个子组件，如果某个子组件修改了父组件传递的props，  很可能导致其他子组件也就跟着变化，最终导致整个应用的状态难以管理和维护  所以不允许子组件修改props    **子->父**: 子组件自定义事件，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件    ```  <div id=\"counter-event-example\">    <p>{{ total }}</p>    <button-counter v-on:increment=\"incrementTotal\"></button-counter>    <button-counter v-on:increment=\"incrementTotal\"></button-counter>  </div>  ```    ```  Vue.component('button-counter', {    template: '<button v-on:click=\"increment\">{{ counter }}</button>',    data: function () {      return {        counter: 0      }    },    methods: {      increment: function () {        this.counter += 1        this.$emit('increment')      }    },  })  new Vue({    el: '#counter-event-example',    data: {      total: 0    },    methods: {      incrementTotal: function () {        this.total += 1      }    }  })  ```    ### 非父子组件通信: event bus    官方文档：[cn.vuejs.org/v2/guide/co…](https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html%23%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1)  有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线  在这两个组件之间引入这个中央事件总线，然后emit，on相应的事件    ```  var bus = new Vue()  // 触发组件 A 中的事件  bus.$emit('id-selected', 1)  // 在组件 B 创建的钩子中监听事件  bus.$on('id-selected', function (id) {    // ...  })  ```    ### 小结    组件间的通讯方案是通用的，无论你使用什么样的前端框架，都会面临这个问题，而解决的方案无外乎本文所列出的几种。"},{title:"组件：插槽 Angular内容投影与Vue插槽",path:"/posts/component/%E7%BB%84%E4%BB%B6%EF%BC%9A%E5%86%85%E5%AE%B9%E6%8A%95%E5%BD%B1%EF%BC%88Angular%EF%BC%89%E3%80%81%E6%8F%92%E6%A7%BD%EF%BC%88Vue%EF%BC%89.html",strippedContent:' ## 内容投影（Angular）    组件对应的模板代码是这样的：    ```html  <div class="panel panel-primary">    <div class="panel-heading">标题</div>    <div class="panel-body">        内容    </div>    <div class="panel-footer">        底部    </div>  </div>  ```    ### 投影一块内容    但是，你希望把面板里面的标题设计成可变的，让调用者能把这个标题传进来，而不是直接写死。这时候“内容投影”机制就可以派上用场了，我们可以这样来编写组件的模板：    ```html  <div class="panel panel-primary">    <div class="panel-heading">      <ng-content></ng-content>    </div>    <div class="panel-body">        内容    </div>    <div class="panel-footer">        底部    </div>  </div>  ```    \x3c!--more--\x3e     请注意以上模板里面的 <ng-content></ng-content>，你看可以把它想象成一个占位符，我们用它来先占住一块空间，等使用方把参数传递进来之后，再用真实的内容来替换它。使用方可以这样来传递参数：    ```html  <test-child-two>      <h3>这是父层投影进来的内容</h3>  </test-child-two>  ```    运行起来的效果是这样的：    ![enter image description here](http://images.gitbook.cn/3bc89540-b1a9-11e7-a796-5fbad02195f1)    可以看到，标题的部分是由使用方从外部传递进来的。    ### 投影多块内容    接着，问题又来了，你不仅希望面板的标题部分是动态的，你还希望面板的主体区域和底部区域全部都是动态的，应该怎么实现呢？    你可以这样编写组件的模板：    ```html  <div class="panel panel-primary">    <div class="panel-heading">        <ng-content select="h3"></ng-content>    </div>    <div class="panel-body">        <ng-content select=".my-class"></ng-content>    </div>    <div class="panel-footer">        <ng-content select="p"></ng-content>    </div>  </div>  ```    然后使用方可以这样来使用你所编写的组件：    ```html  <test-child-two>      <h3>这是父层投影进来的内容</h3>      <p class="my-class">利用CSS选择器</p>      <p>这是底部内容</p>  </test-child-two>  ```    运行起来的效果是这样的：    ![enter image description here](http://images.gitbook.cn/5b418760-b1a9-11e7-a56a-2b0687e97e1c)    你可能已经猜出来了，<ng-content></ng-content> 里面的那个 select 参数，其作用和 CSS 选择器非常类似。    这种投影多块内容的方式叫“多插槽模式”（ multi-slot ），你可以把 <ng-content></ng-content> 想象成一个一个的插槽，内容会被插入到这些插槽里面。    ### 投影一个复杂的组件    到这里还没完，你不仅仅想投影简单的 HTML 标签到子层组件里面，你还希望把自己编写的一个组件投影进去，那又应该怎么办呢？    请看：    ```html  <div class="panel panel-primary">    <div class="panel-heading">        <ng-content select="h3"></ng-content>    </div>    <div class="panel-body">        <ng-content select="test-child-three"></ng-content>    </div>    <div class="panel-footer">        <ng-content select="p"></ng-content>    </div>  </div>  ```    使用方可以这样来使用这个组件：    ```html  <test-child-two>      <h3>这是父层投影进来的内容</h3>      <test-child-three (sayhello)="doSomething()"></test-child-three>      <p>这是底部内容</p>  </test-child-two>  ```    运行起来的效果是这样的：    ![enter image description here](http://images.gitbook.cn/8736e2c0-b1a9-11e7-b94f-7986eefa7bc7)    请注意 <ng-content select="test-child-three"></ng-content> 里面的内容，你把 select 属性设置成了子组件的名称。    同时，对于被投影的组件 <test-child-three></test-child-three> 来说，我们同样可以利用小圆括号的方式来进行事件绑定，就像上面例子里的 (sayhello)="doSomething()" 这样。    ### 内容投影这个特性存在的意义是什么？    如果没有“内容投影”特性我们也能活得很好，那么它就没有存在的必要了，而事实并非如此，如果没有“内容投影”，有些事情我们就没法做了，典型的有两类：    - 组件标签不能嵌套使用。  - 不能优雅地包装原生的 HTML 标签。    依次解释如下：    比如你自己编写了两个组件 my-comp-1 和 my-comp-2，如果没有内容投影，这两个组件就没办法嵌套使用，比如你想这样用就不行：    ```html  <my-comp-1>      <my-comp-2></my-comp-2>  </my-comp-1>  ```    因为没有“内容投影”机制，my-comp-1 无法感知到 my-comp-2 的存在，也无法和它进行交互。这明显有违 HTML 设计的初衷，因为 HTML 的本质是一种 XML 格式，标签能嵌套是最基本的特性，原生的 HTML 本身就有很多嵌套的情况：    ```html  <ul>    <li>神族</li>    <li>人族</li>    <li>虫族</li>  </ul>  ```    在真实的业务开发里面，另一个典型的嵌套组件就是 Tab 页，以下代码是很常见的：    ```html  <tab>      <pane title="第一个标签页"/>      <pane title="第二个标签页"/>      <pane title="第三个标签页"/>  </tab>  ```    如果没有内容投影机制，想要这样嵌套地使用自定义标签也是不可能的。    内容投影存在的第二个意义与组件的封装有关。    虽然 Angular 提供了 @Component 装饰器让开发者可以自定义标签，但是请不要忘记，自定义标签毕竟与 HTML 原生标签不一样，原生 HTML 标签上面默认带有很多属性、事件，而你自己定义标签是没有的。原生 HTML 标签上面暴露的属性和事件列表[请参见 W3C 的规范](https://www.w3schools.com/tags/ref_attributes.asp)。    从宏观的角度看，所有的自定义标签都只不过是一层“虚拟的壳子”，浏览器并不认识自定义标签，真正渲染出来的还是 div、form、input 之类的原生标签。所以，自定义标签只不过是一层逻辑上的抽象和包装，让人类更容易理解和组织自己的代码而已。    既然如此，自定义标签和 HTML 原生标签之间的关系是什么呢？本质上说，这是“装饰模式”的一种应用，而内容投影存在的意义就是可以让这个“装饰”的过程做得更加省力、更加优雅一些。        ## 内容分发slot插槽(Vue)    为了让组件可以组合，需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 **内容分发** (或 “transclusion” )。Vue实现了一个内容分发 API，参照了当前 Web 组件规范草案，使用特殊的 `<slot>` 元素作为原始内容的插槽。    ### 编译作用域      在深入内容分发 API 之前，先明确内容在哪个作用域里编译。假定模板为    ```js  <child-component>    {{ message }}  </child-component>  ```      `message`应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。      一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：    ```js  \x3c!-- 无效 --\x3e  <child-component v-show="someChildProperty"></child-component>  ```      假定`someChildProperty`是子组件的属性，上例不会如预期工作。父组件模板不应该知道子组件的状态      如果要绑定作用域内的指令到一个组件的根节点，应当在组件自己的模板上做：    ```js  Vue.component(\'child-component\', {    // 有效，因为是在正确的作用域内    template: \'<div v-show="someChildProperty">Child</div>\',    data: function () {      return {        someChildProperty: true      }    }  })  ```      类似地，分发内容是在父作用域内编译    ### 默认丢弃      一般地，如果子组件模板不包含`<slot>`插口，父组件的内容将会被**丢弃**    ```js  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child>        <p>测试内容</p>      </child>    </div>    `,    components: {      \'child\': childNode    },  };  ```    ```js  <div id="example">    <parent></parent>  </div>  <script src="https://unpkg.com/vue"><\/script>  <script>  var childNode = {    template: `    <div class="child">      <p>子组件</p>    </div>    `,  };  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child>        <p>测试内容</p>      </child>    </div>    `,    components: {      \'child\': childNode    },  };  // 创建根实例  new Vue({    el: \'#example\',    components: {      \'parent\': parentNode    }  })  <\/script>  ```      如下图所示，<child>所包含的<p>测试内容</p>被丢弃    ![vue_components_slot1](https://pic.xiaohuochai.site/blog/vue_components_slot1.png)         ### 内联模板      如果子组件有 `inline-template` 特性，组件将把它的内容当作它的模板，而忽略真实的模板内容      但是 `inline-template` 让模板的作用域难以理解    ```js  var childNode = {    template: `    <div class="child">      <p>子组件</p>    </div>    `,  };  ```    ```js  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child inline-template>        <p>测试内容</p>      </child>    </div>    `,    components: {      \'child\': childNode    },  };  ```    ![vue_components_slot2](https://pic.xiaohuochai.site/blog/vue_components_slot2.png)         ### 匿名slot      当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身    ```js  var childNode = {    template: `    <div class="child">      <p>子组件</p>      <slot></slot>    </div>    `,  };  ```    ```  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child>        <p>测试内容</p>      </child>    </div>    `,    components: {      \'child\': childNode    },  };  ```    ![vue_components_slot3](https://pic.xiaohuochai.site/blog/vue_components_slot3.png)      如果出现多于1个的匿名slot，vue将报错    ```js  var childNode = {    template: `    <div class="child">      <p>子组件</p>      <slot></slot>      <slot></slot>    </div>    `,  };  ```    ![vue_components_slot4](https://pic.xiaohuochai.site/blog/vue_components_slot4.png)    【默认值】      最初在 <slot> 标签中的任何内容都被视为**备用内容**，或者称为默认值。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容      当slot存在默认值，且父元素在<child>中没有要插入的内容时，显示默认值    ```js  var childNode = {    template: `    <div class="child">      <p>子组件</p>      <slot><p>我是默认值</p></slot>    </div>    `,  };  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child></child>    </div>    `,    components: {      \'child\': childNode    },  };  ```    ![vue_components_slot5](https://pic.xiaohuochai.site/blog/vue_components_slot5.png)      当slot存在默认值，且父元素在<child>中存在要插入的内容时，则显示设置值    ```js  var childNode = {    template: `    <div class="child">      <p>子组件</p>      <slot><p>我是默认值</p></slot>    </div>    `,  };  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child>        <p>我是设置值</p>      </child>    </div>    `,    components: {      \'child\': childNode    },  };  ```    ![vue_components_slot6](https://pic.xiaohuochai.site/blog/vue_components_slot6.png)         ### 具名Slot      <slot> 元素可以用一个特殊的属性 `name` 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 `slot` 特性的元素    ```js  var childNode = {    template: `    <div class="child">      <p>子组件</p>      <slot name="my-header">头部默认值</slot>      <slot name="my-body">主体默认值</slot>      <slot name="my-footer">尾部默认值</slot>    </div>    `,  };  ```    ```js  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child>        <p slot="my-header">我是头部</p>        <p slot="my-footer">我是尾部</p>      </child>    </div>    `,    components: {      \'child\': childNode    },  };  ```    ![vue_components_slot7](https://pic.xiaohuochai.site/blog/vue_components_slot7.png)      仍然可以有一个匿名 slot，它是**默认 slot**，作为找不到匹配的内容片段的备用插槽。匿名slot只能作为没有slot属性的元素的插槽，有slot属性的元素如果没有配置slot，则会被抛弃    ```js  var childNode = {    template: `    <div class="child">      <p>子组件</p>      <slot name="my-body">主体默认值</slot>      <slot></slot>    </div>    `,  };  ```    ```js  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child>        <p slot="my-body">我是主体</p>        <p>我是其他内容</p>        <p slot="my-footer">我是尾部</p>      </child>    </div>    `,    components: {      \'child\': childNode    },  };  ```    `<p slot="my-body">`插入`<slot name="my-body">`中，    `<p>`我是其他内容`</p>`插入`<slot>`中，  ​    而`<p slot="my-footer">`被丢弃    ![vue_components_slot8](https://pic.xiaohuochai.site/blog/vue_components_slot8.png)      如果没有默认的 slot，这些找不到匹配的内容片段也将被抛弃    ```js  var childNode = {    template: `    <div class="child">      <p>子组件</p>      <slot name="my-body">主体默认值</slot>    </div>    `,  };  ```    ```js  var parentNode = {    template: `    <div class="parent">      <p>父组件</p>      <child>        <p slot="my-body">我是主体</p>        <p>我是其他内容</p>        <p slot="my-footer">我是尾部</p>      </child>    </div>    `,    components: {      \'child\': childNode    },  };  ```    `<p>` 我是其他内容 `</p>`    和`<p slot="my-footer">`都被抛弃    ![vue_components_slot9](https://pic.xiaohuochai.site/blog/vue_components_slot9.png)         '},{title:"DOM总结",path:"/posts/JavaScript/dom.html",strippedContent:' [[toc]]    ## dom操作总结    ### 节点查找API    > document.getElementById ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；  >  > document.getElementsByClassName ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。注意兼容性为IE9+（含）。另外，不仅仅是document，其它元素也支持 getElementsByClassName 方法；  >  > document.getElementsByTagName ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。  >  > document.getElementsByName ：根据元素的name属性查找，返回一个 NodeList 。  >  > document.querySelector ：返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个。  >  > document.querySelectorAll ：返回一个 NodeList ，IE8+(含）。  >  > document.forms ：获取当前页面所有form，返回一个 HTMLCollection ；    ### 节点创建API    #### createElement创建元素：    ```javascript  var elem = document.createElement("div");    elem.id = \'haorooms\';    elem.style = \'color: red\';    elem.innerHTML = \'我是新创建的haorooms测试节点\';    document.body.appendChild(elem);    ```    通过 createElement 创建的元素并不属于 document 对象，它只是创建出来，并未添加到html文档中，要调用 appendChild 或 insertBefore 等方法将其添加到HTML文档中。    #### createTextNode创建文本节点：    ```javascript  var node = document.createTextNode("我是文本节点");    document.body.appendChild(node);    ```    #### cloneNode 克隆一个节点：    node.cloneNode(true/false) ，它接收一个bool参数，用来表示是否复制子元素。    ```javascript  var from = document.getElementById("test");    var clone = from.cloneNode(true);    clone.id = "test2";    document.body.appendChild(clone);    ```    克隆节点并不会克隆事件，除非事件是用这种方式绑定的，用 addEventListener 和 node.onclick=xxx; 方式绑定的都不会复制。    #### createDocumentFragment    本方法用来创建一个 DocumentFragment ，也就是文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，大量操作DOM时用它可以大大提升性能。    ### 节点修改API    **1、appendChild**    语法：    ```js  parent.appendChild(child);  ```    **2、insertBefore**    ```js  parentNode.insertBefore(newNode, refNode);    ```    **3、insertAdjacentHTML**    ```js  //js谷歌浏览器，火狐浏览器，IE8+  el.insertAdjacentHTML(\'beforebegin\', htmlString);  ```    关于insertAdjacentHTML，这个API比较好用，具体可以看：<https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML>    ```js  \x3c!-- beforebegin --\x3e  <p>    \x3c!-- afterbegin --\x3e    foo    \x3c!-- beforeend --\x3e  </p>  \x3c!-- afterend --\x3e  ```    **4、Element.insertAdjacentElement()**    用法和上面类似，    ```js  targetElement.insertAdjacentElement(position, element);  ```    **5、removeChild**    removeChild用于删除指定的子节点并返回子节点，语法：    ```js  var deletedChild = parent.removeChild(node);    ```    deletedChild指向被删除节点的引用，它仍然存在于内存中，可以对其进行下一步操作。另外，如果被删除的节点不是其子节点，则将会报错。一般删除节点都是这么删的：    ```js  function removeNode(node)    {        if(!node) return;        if(node.parentNode) node.parentNode.removeChild(node);    }    ```    **6、replaceChild**    replaceChild用于将一个节点替换另一个节点，语法：    ```js  parent.replaceChild(newChild, oldChild);    ```    ### 节点关系API    **1、父关系API**    > parentNode ：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment；  >  > parentElement ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；    **2、子关系API**    > children ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持；  >  > childNodes ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；  >  > firstChild ：返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild ；  >  > lastChild ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild ；    **3、兄弟关系型API**    > previousSibling ：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。  >  > nextSibling ：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。  >  > previousElementSibling ：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。  >  > nextElementSibling ：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。    ### 元素属性型API    **1、setAttribute 给元素设置属性：**    ```js  element.setAttribute(name, value);    ```    其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。    **2、getAttribute**    getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null：    ```js  var value = element.getAttribute("id");   ```    **3、hasAttribute**    ```js  var result = element.hasAttribute(name);    var foo = document.getElementById("foo");   if (foo.hasAttribute("bar")) {       // do something  }  ```    **4、dataset**    获取html data-开头的属性，用法如下：    ```js  <div id="user" data-id="1234567890" data-user="johndoe" data-date-of-birth>John Doe</div>    let el = document.querySelector(\'#user\');    // el.id == \'user\'  // el.dataset.id === \'1234567890\'  // el.dataset.user === \'johndoe\'  // el.dataset.dateOfBirth === \'\'    el.dataset.dateOfBirth = \'1960-10-03\'; // set the DOB.    // \'someDataAttr\' in el.dataset === false  el.dataset.someDataAttr = \'mydata\';  // \'someDataAttr\' in el.dataset === true  ```    ### 样式相关API    **1、直接修改元素的样式**    ```js  elem.style.color = \'red\';    elem.style.setProperty(\'font-size\', \'16px\');    elem.style.removeProperty(\'color\');    ```    **2、动态添加样式规则**    ```js  var style = document.createElement(\'style\');    style.innerHTML = \'body{color:red} #top:hover{background-color: red;color: white;}\';    document.head.appendChild(style);    ```    **3、classList获取样式class**    ```js  // div is an object reference to a <div> element with class="foo bar"  div.classList.remove("foo");  div.classList.add("anotherclass");    // if visible is set remove it, otherwise add it  div.classList.toggle("visible");    // add/remove visible, depending on test conditional, i less than 10  div.classList.toggle("visible", i < 10 );    alert(div.classList.contains("foo"));    // add or remove multiple classes  div.classList.add("foo", "bar", "baz");  div.classList.remove("foo", "bar", "baz");    // add or remove multiple classes using spread syntax  let cls = ["foo", "bar"];  div.classList.add(...cls);   div.classList.remove(...cls);    // replace class "foo" with class "bar"  div.classList.replace("foo", "bar");  ```    **4、window.getComputedStyle**    通过 element.sytle.xxx 只能获取到内联样式，借助 window.getComputedStyle 可以获取应用到元素上的所有样式，IE8或更低版本不支持此方法。    ```js  var style = window.getComputedStyle(element[, pseudoElt]);    ```    ### 获取相关高度API    这里主要讲一下：    #### getBoundingClientRect    getBoundingClientRect 用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：    ```  var clientRect = element.getBoundingClientRect();    ```    clientRect是一个 DOMRect 对象，包含width、height、left、top、right、bottom，它是相对于窗口顶部而不是文档顶部，滚动页面时它们的值是会发生变化的。'},{title:"女生需要的安全感究竟是什么？",path:"/posts/psychology/safe.html",strippedContent:" 本文从依恋理论出发，首先剖析女性缺乏安全感的原因，然后以依恋理论为基础，探究安全感是什么，及其对于女生的四层意义，其次从四种依恋类型研究不同女生的安全感水平，再次批判了“安全感是自己给自己的”这一观念，最后对于男女生给出提高安全感及恋爱质量的建议。    #### 1 为什么女生普遍缺乏安全感？  > 男人的极大幸运在于，他，不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这又是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；每一种事物都在诱使她走容易走的道路；她不是被要求奋发向上，走自己的路，而是听说只要滑下去，就可以到达极乐的天堂。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。                      ——Simone de Beauvoir  演化过程中男性提供生存资料，女性则依附于男性，必须确定自己不会被抛弃； 国内严重的重男轻女现象，以及不健康的教育模式，女生青少年时期往往被忽视，甚至受到情感及躯体虐待。  缺乏无条件的爱和接纳，没有自我意识，自我认知混乱，对自我的认知建立在他人的评价上。因为匮乏，所以一生都在寻找爱，依靠他人的关注认知自己，且未解决的创伤严重破坏亲密关系。  曾经被爱过的人伤害、背叛、抛弃，改变了对亲密关系的看法，不再相信他人，专注于不要再次受到伤害。  调查表明国人不安全依恋类型超过六成，社会对男女的要求也不同，种种因素导致女性在亲密关系中普遍缺乏安全感。  ### 2 究竟什么是安全感？ 要回答这个问题，必须先了解依恋理论。 #### 2.1 依恋理论 > 依恋理论认为，早期亲子关系的经验形成了人的“内部工作模式”，这种模式是人的一种对他人的预期，决定了人的处世方式。内部工作模式会在以后的其他关系、特别是成年以后亲密关系和婚恋关系中起作用。大量的研究表明，早期亲子依恋的质量会对个体的人格和心理产生重要的影响。  依恋理论之父Bowlby认识到儿童对其照看者的依恋具有基于生物基础的进化需求。作为动机系统的依恋其原始的本性来自于婴儿绝对需要保持自己与照看者之间,的身体亲近,这不仅是为了促进情绪的安全,而且更重要的是保证婴儿确实能存活下来。  在我们人类祖先不得不适应的自然环境中,大量的掠食者以及其他各种致命的威胁,使得人类的婴儿离开其他人的保护几乎存活不了几分钟,更不用说几小时了,因此,Bowlby所称的依恋行为系统是由进化“设计”的,用来提高成功存活和繁衍的几率。如此而言,依恋系统作为人类遗传程序中的一个组成部分,其重要性并不比进食及交配小多少。  下列的三种行为类型,可以证明这种对威胁和不安全的反应,是天生的，依靠本能指引的:    1.**寻求**(seeking)、**监测**(monitoring),并试图和提供保护的依恋对象(attachment figure )或者是一个微小的依恋对象层级系统中的一员**保持亲近**，这个依恋对象通常是一个亲属，但并非必然。尽管看起来与婴儿卷人最多的人(母亲，父亲，或者其他的照看者)应该会处于依恋层级系统的最顶层，但是这个婴儿更喜欢接近的位置实际上通常会是母亲一不管婴儿和她的卷人程度如何。向依恋对象哭泣、粘缠、呼唤，还有爬向他们，这些都是年幼儿童为了建立安全的亲近性，而表现出的根深蒂固的和与生俱来的技能。    2.**将依恋对象作为“安全基地”而使用，从这个地方开始，去探索其他陌生的环境和体验。**作为安全基地现象的例子，可以考虑Margaret Mahler所做的著名观察，观察那些短暂离开母亲去进行探险的婴儿和幼儿，总是要回到母亲身边待上片刻，“加加油”，从而让他们自己开始下一轮的探索活动。Bowlby所称的探索行为系统与依恋系统密切相关。如果依恋对象在场，可以作为儿童的安全基地，在儿童需要时提供保护和支持，儿童一般会觉得可以自由去探索。另一方面，如果依恋对象暂时离开，儿童的这种探索就会突然中断。    3.**将依恋对象作为“安全港”，在面对危险情境和受到惊吓的时候逃向此处。**人类和其他生活在地面上的灵长类动物相似，但是不同于很多其他物种，当人类受到威胁的时候，他们不是要寻找一个地方(比如地洞或者窝巢) 来确保安全，而是要寻求一个觉得比自己“更强壮和/或更智慧”的人的陪伴，从而获取安全感(Bowlby,1988，121页)。影响婴儿存活的内部及外部的威胁、“危险的自然线索”(比如黑暗、大的响声和不熟悉的环境)，以及实际的或即将发生的与母亲的分离，这些都会引发儿童寻求亲近，这是依恋行为的显著标志。    Bowlby最初阐释他的依恋理论时，认为身体的亲近性本身就是依恋的“设定目标”，这个看法后来一直被不停地丰富和修正。**身体上的亲近不仅有其自身的重要作用，也是一个重要的象征，表明那个可以安慰自己的照看者是可获得性的(availbility).**    根据这个观点，**依恋行为的目的，不仅是要从照看者那里获得保护以避免当前的危险，而且还要一再地确保照看者持续的可获得性**。考虑到照看者的身体可以被接触到，但与此同时照看者的情绪有可能缺失的情形，Bowlby将依恋对象的“可获得性”定义为不仅是身体上的可接触性，而且也是情绪上的反应性。    对依恋的理解得以拓展之后，Bowlby最终增加了依恋特定的内在维度。他宣称，**实际上儿童对照看者可获得性的评估才是关键，而且儿童对当下的评估，主要是根据过去对照看者可获得性的体验而定。**    **依恋系统的设定目标首先不是空间距离的调节，而是“感到安全”，是一种主体的状态**，这种状态不仅随着照看者的行为而发生变化，还会随着儿童的内在体验而发生变化，包括他们自身的心境、身体状况、想象等。       尽管Bowlby最初关注的是婴儿和幼儿的行为，但他后来逐渐相信，由生物需要驱动的各种依恋表现，很显著地贯穿了人的整个生命周期。这个信念间接地得到了统计数据和日常经验的证实。保险统计的数据表明，有伴侣和(或)有亲密朋友的人比那些孤独的人寿命长。    此外几乎是大家都有的经验，即在遇到危险的时候，比如发生地震时候，我们都会去找那些和我们关系密切的人。危险越强烈，我们就越渴望和人联接，通常是通过皮肤与皮肤之间的接触，获得实实在在的亲近。显然身体的亲近是婴儿存活的基础，这种亲近对年龄较大的儿童以及成人而言，通常被体验为一种情绪的需要。   **  在一生的生命历程中，我们都会倾向于监测着我们最依恋的对象，他们的身体和情绪位于何处，也就是可接近性和反应性**。因此，尤其当“感到安全”也被增加为亲近性的设定目标后，就必须将依恋看成是人类持续一生的需求，而不是一种儿童般的依赖，长大后就可以不再倚靠了。    就如Bowlby (1980)所写的那样:   对其他人的来依恋是一个枢纽中心，人的一生都国绕它而发展，不仅在他只是一个婴儿或蹒跚学步的幼儿时，而且贯穿于他的青少年期，还有成熟期，并伴随其步入老年期。   #### 2.2依恋理论与安全感 **安全感可以被定义为，一种主体的状态，根据过去依恋对象可得性的体验，对当下可得性的评估。**该状态不仅随着依恋对象的行为而发生变化，还会随着主体的内在体验而发生变化，包括她（他）们自身的心境、身体状况、想象等。 安全感对主体而言，有四重意义：  1**探索陌生环境与体验的“安全基地“**  2**危险和惊吓时的“安全港”**     3**可获得性：身体上的亲近性与情绪上的反应性**（相似性）  4 生存资料与安全感（存疑？） ##### 2.2.1安全基地 生物具有与生而来的好奇心，喜欢探索陌生环境与体验，养过宠物的人会发现，宠物会以主人为中心去探索环境。人也是如此，有**不断探索的需求，体验不同的人生、学习新的事物与知识、开拓眼界、些微的堕落、不同的情绪体验、甚至单纯的觉得好玩有趣**。  若她涉世未深，就带她看尽人间繁华；若她心已沧桑，就带她坐旋转木马；而陪伴，引领女生的这个人，则会被女生认为是“安全基地”，从而产生依恋。  学生时代女生往往会被班级、学生会、社团等群体中较强，可以引领她的人所吸引。而学生情侣在毕业后很容易分手，因为此时女生普遍比男生成熟，而又容易在公司中遇到年纪较大的，能帮助其工作的较成熟男性，甚至是其上级领导，带其领略学生时代负担不起，或未曾体验的新鲜事物，或是未曾体验过的宠爱。  **藉由这个人发现新大陆，感觉到刺激、新奇、新鲜感以及被引领和照顾的感觉**。而此人再有拥有丰富的情感经历和追求手段，温柔体贴女生很容易移情别恋。这也是部分女生喜欢大叔的原因之一。  此处**女生需万分注意，初入职场切勿卷入与大叔，甚至是已婚人士的情感**，从深刻了解男性劣根性的男人来看，岁月给大部分男性以虚伪的面具和伪装的伎俩，只给小部分男性以睿智和魅力。   而女生常说的没有感觉，部分源于此，“老实的男人”——不抽烟、不喝酒、不赌博、不去夜店、生活单纯，无不良嗜好，喜欢电子产品、打打游戏。不讲究吃，也不讲究穿，理发与外在打扮等更不觉得重要。这样的男生往往自觉 专情、认真、正直，然而不幸的是女生对这样男生毫无兴趣，因为无聊乏味，没有新鲜感，不能被引领与照顾。  很不幸，这样的男生，碰到喜欢的女生竭尽所能去讨好，平时的嘘寒问暖，以及节日的礼物之类，为彰显自己尊重女生，所以去哪里也好、吃甚么也好、都努力询问女生的意思。而女生需要的是被男生引领，被男生照顾，以及惊喜与浪漫的新奇体验，而不是平淡无奇。  然而生活终究是平淡的，靠新鲜感与激情开始，总会厌倦，所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。维持长久，需要双方认知同步共同成长，在平凡里创造惊喜和浪漫。  就像王小波对李银河说的： > 我们就像两个在海边玩耍的孩子。一会儿发现个贝壳，一会儿又发现个贝壳，乐此不疲的。哪有时间去厌倦？    你渴了，别人给你一杯温水。你嫌弃它无味寡淡。你喜欢汽水带给你的舌尖的刺激可是越喝越渴。等你想起来那杯温水才能解决你的欲求时，它已经凉了。 用你的心去温暖那杯可以永远让你不会干渴的水，而别用你的贪婪让它变得冰凉。最后你喝下的只能是自己的眼泪。    ##### 2.2.2安全港 人类受到威胁的时候，不同的安全状态，会逐层激发三种生理状态，第一层是**社会参与**，我们会向周围的人求助、呼救、寻求安慰，需要寻求一个人的陪伴，从而获取安全感。“英雄救美，以身相许”的佳话屡见不鲜，女生处于危险境况中，乃至于生命受到威胁时，如果此时有人能给予陪伴、帮助，则会被视为“安全港”，将之视为拯救自己的上帝，产生极强的依恋。人质的生命被绑匪完全掌控，甚至事后会产生斯德哥尔摩综合征，  日常生活中并不需要有生命危险才会产生这种依恋，人生而孤独，他人的陪伴是我们毕生的追求，能够从他人身上感觉到安全，是精神健康最重要的一点：安全的联系是有意义和令人满足的生活的基础。  心理学家科恩与同事一起模拟了一个压力场景测试。他们对参与实验的已婚妇女说，她们将受到一阵微电流刺激，同时使用功能性磁共振成像技术扫描她们的大脑活动。当人体处于压力和刺激性环境中，下丘脑会活跃起来。  这些妇女独自等待电流刺激的时候，她们的下丘脑出现了明显的活动现象。当她们握着一位陌生人的手等待电流刺激的时候，下丘脑的活动稍微减弱。实验最后，她们将握着丈夫的手等待电流刺激。结果会如何呢? 扫描结果显示，下丘脑的活动状况并不明显，说明她们这一次感到的压力很小。实验结果同时显示，对婚姻满足度越高的女女，握着丈夫的手时感觉越放松。    这项研究证明，当恋人的感情亲密时，双方身心健康都会受到积极的影响。一段亲密的感情，能帮助我们减轻心理压力，便我们更有安全感，更勇敢，更加具有创造力。亲密关系影响着我们的身心健康。  另外由于大脑分辨真伪的能力较差，可人为制造危险信息，使得他人产生错误的依恋感觉。  ”吊桥效应“就是典型的案例，当一个人提心吊胆地过吊桥的时候，会不由自主地心跳加快。如果这个时候，身边有一个异性，则会视之为”安全港“，并错把由这种情境引起的心跳加快理解为对方使自己心动，才产生的生理反应，故而对对方滋生出爱情的情愫。  臭名昭著的pua理论中也有很多技巧让女生产生依恋错觉，以下引叙其一： >  > 与女生约会逛街，两人一起走路的时候，你叫她闭上眼睛，你牵着她的手走，定个目的地，走到就完成。然后换她牵你手，带你到一个地方。你牵着她的时候记得在她耳边说“记得什么时候都要相信我哦”！后面的时候，你牵着女孩在街上走，她会有很复杂的心理活动，紧张，刺激，冒险，安全感，就像坐过山车一样。能听见周围声音，但是看不到东西，唯一能相信的就是你牵着她的手，这里可以产生很好的信任感。如果情况好，你还可以偷吻她，或者当她睁开眼的时候，送她一份小礼物。  此法亦被使用在心理治疗中，通过牵着闭上眼睛的患者，行走数分钟，重建在创伤中被破坏的安全感。    ##### 2.2.3 可获得性：身体上的亲近性与情绪上的反应性  ##### 2.2.4 生存资料与安全感  ### 3 安全感真的是自己给自己的吗？  #### 3.1 依恋类型与安全感水平 已有研究发现相比于安全型成人依恋，不安全型成人依恋的个体在恋爱关系中容易遭遇困难和挫折，难以维持长期满意的恋爱关系。 ####  3.2自我认知与安全感水平 ####  3.3 心理创伤与安全感水平 ####  3.3 依恋对象的依恋类型 不安全型难以维持长期关系，婚恋市场遇到的单身多为不安全型...   ####  3.4 依恋对象的可得性  #### 3.5总结  ### 4女生怎样获得安全感？（读懂恋人心 错误模式）   ### 5男生如何吸引女生及给女生安全感？（曾奇峰 优秀（基地，港湾） 承接情绪 只有你懂我） ####  5.1优秀的悖论 #### 5.2成为女生的安全基地，安全湾 #### 5.3情绪的反应性（如何接纳女生情绪及作出适当回应）   试图以依恋理论为框架，整合其他心理学知识，解释成人依恋中的各种问题，以指导恋爱，提高亲密关系质量。  本文为系列文章第一篇，由于水平有限，尚未完成，急需一名女性配合实践研究，有意联系。  未完待续。。。。。。  参考资料：  《理工科大学生依恋类型与主观幸福感的相关性研究》  《大学生如何有效应对“不安全型成人依恋” 恋人的探索性研究》  《依恋理论与社会工作实践》  《母婴互动及成人心理治疗中的主体间形式》  《心智化临床实践》  《依恋理论与社会工作实践》  《Attachment in Psychotherapy 》  《Memory biases of attachment styles: Based on the interpretation of two processing modes》  《he Body Keeps the Score: Brain, Mind, and Body in the Healing of Trauma》  《Trauma and Recovery: The Aftermath of Violence - From Domestic Abuse to Political Terror》"},{title:"恋爱与婚姻的意义是什么？",path:"/posts/psychology/marriage.html",strippedContent:' 恋爱与婚姻的意义是什么？我们究竟想从恋爱与婚姻中得到什么？以下论文将告诉你答案。        该论文研究了美国婚姻变化的三个阶段，并对婚姻制度未来发展做出预测。美国婚姻第一个阶段是**制度化婚姻**，提供性交和繁衍后代的合理场所。从20世纪50年代开始，逐渐变成了一种基于**相互陪伴的关系**，双方是朋友恋人，男人赚钱女人顾家，最后发展成**个人式婚姻**，注重个人的成长和深层次的亲密感。        而中国婚姻模式发展太快，本世纪初，迅速从第一种往第三种转变，三种模式并存，人们往往不知道自己到底想要从恋爱和婚姻里收获什么。        有人这样描述中国的婚姻：现代婚姻的不堪重负在于，人们希望在一个人身上一次性地解决情感的问题，性的问题，生育的问题，生活照顾的问题，甚至钱的问题和阶级提升的问题……难度之大，可想而知……出问题的概率之大，也可想而知……        ------        **美国婚姻的去制度化（****The Deinstitutionalization of American Marriage****）**        本文认为，婚姻已经失去了一个去制度化的过程——在过去的几十年里，社会规范的弱化，定义了部分人的行为。提出的问题包括同居关系的数量和复杂性以及同性婚姻的出现。20世纪美国发生的两种婚姻意义的转变创造了非制度化的社会环境。        欧内斯特伯吉斯指出，第一个转变来自于制度婚姻与伴侣婚姻。第二种转变是对个人选择和自我发展的强调。尽管婚姻的实际重要性已经下降，但它的象征意义仍然很高，甚至可能还在增加。它已经成为声望和个人成就的标志。其具有象征意义的实例被提出。讨论了对婚姻现状及其未来发展方向的影响。        四分之一个世纪以前，在一篇名为“再婚是不完整的制度”的文章（切林，1978年）中，我认为美国社会缺乏关于再婚家庭成员应该如何对待彼此的规范。相比之下，第一次婚姻中的孩子和孩子可以依赖于既定的规范，例如在适当的时候管教孩子。        我预测，随着时间的推移，随着离婚后再婚的普遍现象，规范将开始出现，关于家庭中适当的行为——例如，继父应该和他的继子女们有什么样的关系。换句话说，我期望再婚会变得制度化，它会变得更像第一次婚姻。        但事实恰恰相反。再婚并没有变得更像第一次婚姻;更确切地说，第一次婚姻更像是再婚。在过去的几十年里，婚姻的非制度化化，而不是再婚的制度化。是的，婚姻是一个不完整的制度，但是现在，第一个婚姻也是如此，这是一个共同的婚姻。通过非制度化，我指的是在婚姻等社会制度中定义人们行为的社会规范的弱化。        在社会稳定时期，人们理所当然地认为，规范的本质允许人们在不质疑他们的行为或他人行为的情况下生活。但是，当社会变革产生的情况超出了规范的范围时，个人就不能再依赖于对如何行动的共同理解了。相反，他们必须谈判新的行动方式，这是一个潜在的冲突和机会的来源。一方面，新规则的制定可能会引起相关行为者之间的分歧和紧张。另一方面，像婚姻这样的性别制度的旧规则的瓦解可能会导致夫妻之间建立一个更加平等的关系。        我认为，这种观点可以帮助我们理解当代婚姻的现状。它甚至可以帮助预测未来婚姻的风险。在某种程度上，美国、加拿大和欧洲大部分地区的婚姻都发生了变化，但美国的情况可能是不同的。很好地，尽管我包含了关于加拿大和欧洲家庭的信息，但我主要关注的是美国。        **一、去制度化的婚姻**        就在我写1978年的文章的时候，家庭劳动分工的变化和婚外生育的增加正在破坏制度化的“破坏”的基础。随着越来越多的已婚妇女进入有偿劳动大军，家庭主妇和养家糊口的人的独特角色正在消失。展望未来，我认为也许一个平等的家庭劳动分工可能会被制度化。但取而代之的是“停滞的革命”，在霍克希尔德（1989）的著名短语中。男人做的家务比以前多了，但是有很大的变化，每对夫妇都必须在没有明确的指导方针的情况下制定自己的安排。        此外，当我写这篇文章的时候，在美国出生的6个孩子中就有1个发生在婚外，这个比例已经比上世纪中期高了很多（美国国家健康统计中心，1982）。今天，这个数字是3分之一（美国国家卫生统计中心，2003年）。在加拿大（加拿大统计局，2003年）和英国和爱尔兰（基兰，2002年）的百分比是相似的。在丹麦、冰岛、挪威和瑞典的北欧国家，这个数字从45%到65%（Kieman）。婚姻已经不再是半个世纪前的孩子们的普遍环境了。        我在1978年的文章中写道，这两种发展——家庭劳动分工的变化和婚外生育的增加——都在进行中，离婚率也在急剧上升。这里我将讨论两个最近的家庭生活的变化,两者都造成了婚姻的去机构化。1970年代后:cohabi——界定的发展,始于1970年代,但没有充分重视,直到它加速在1990年代和1980年代,和同性婚姻,这成为一个问题在1990年代和在当前十年已经脱颖而出。        - **同居的增长**          在20世纪70年代，我和其他大多数美国研究人员都没有预见到同居在成人生活中的作用会大大增加。我们认为，除了穷人之外，同居仍然是一种短期的安排，在那些不太年轻的成年人中，他们很快就会分手或结婚。但它已成为一种更为普遍和更为复杂的现象。例如，同居在再婚家庭中创造了额外的复杂性。当我写这篇文章的时候，几乎所有的再婚家庭都是由一个或两个配偶的再婚所形成的。        现在，在美国，大约四分之一的再婚家庭，以及加拿大所有再婚家庭的一半，都是由同居而不是婚姻形成的（Bumpass，雷利，&甜,1995;Sta - tistics加拿大,2002)。在低收入人群中，女性在婚姻之外有一个孩子，结束了与伴侣的关系，然后开始与另一个伴侣同居，这种情况并不少见。这个新联盟在结构上相当于一个步骤——家庭，但不涉及婚姻。有些时候，这对夫妇后来结婚了，如果他们之前都没有结婚，他们的婚姻就会和继子女们建立起第一次婚姻。因此，我们现在看到越来越多的再婚家庭不涉及婚姻，越来越多的第一次婚姻涉及再婚家庭。        更普遍的是，同居正被接受为婚姻的替代选择。英国人口统计学家Kathleen Kieran（2002）写道，在欧洲国家中，接受同居的现象正在发生，有些国家的情况比其他国家更早。在第一阶段，同居是一种边缘或先锋的非;在第二阶段，它被认为是婚姻的试验田;在第三阶段，作为婚姻的替代品，它变得可以接受;在第四阶段，它和婚姻变得难以区分。她认为，瑞典和丹麦已经进入了第四阶段;在过去的一段时间里，西班牙、意大利和希腊等地中海国家仍处于第一阶段。        在21世纪初，美国似乎正在从第二阶段过渡到第三阶段（Smock&古普塔,2002)。一些指标显示，同居和婚姻之间的联系正在减弱。在3年内结束婚姻的同居联盟的比例从20世纪70年代的60%下降到20世纪90年代的33%（Smock&Gupta)，这表明同居的婚姻较少是试婚（或者更少的试婚成功）。        事实上，曼宁和斯莫克（2003）报告说，在接受深度采访的115名同居工薪阶层和下层中产阶级成年人中，没有人说他或她在婚姻开始时决定婚姻和同居。此外，在2002年的美国社会调查中，只有36%的成年人不同意政府的观点，“一对夫妇在不打算结婚的情况下同居是可以的”（戴维斯，史密斯，&马斯登,2003)。在美国，未婚女性生育的比例越来越高（在20世纪90年代，约为40%）是对同居夫妇（Bumpass&陆,2000)。在英国，这一比例约为60%（Ermisch，2001）。        加拿大似乎已经进入了第三阶段（Smock&古普塔,2002)。在1997年和1998年，未婚女性生育的比例为69%（Juby，Marcil-Gratton，&在媒体Le Bourdais)。更重要的是，加拿大的国家数据掩盖了各省的巨大差异。特别是，魁北克的同居人数比加拿大其他地方要大得多。在1997年和1998年，魁北克的未婚妇女中有84%的人同居（Juby，Marcil-Gratton，&Le Bourdais)。五分之四的魁北克人加入了第一个联盟，他们是通过同居而不是结婚（Le Bourdais&Juby,2002)。在魁北克，人们更容易接受“共同生活”，这似乎是一种文化基础。        讲法语的魁北克人比其他说英语的省份的说英语的魁北克人或加拿大人（加拿大统计局，1997年）的同居比例要高得多。席琳勒布尔达斯和妮可玛西-格拉顿（1996）认为，讲法语的魁北克人使用的是法国人，而不是盎格鲁撒克逊人的家庭生活模式。事实上，魁北克的同居水平与法国的水平相似，而在英国，加拿大和美国的水平与英国的低水平相似（Kieran，2002）。        可以肯定的是，同居正变得越来越制度化。在美国，各州和市政当局正在向同居伴侣提供一些已婚夫妇的权利和责任。加拿大走得更远：根据2000年福利和义务法案的现代化，已婚和未婚的同性伴侣和异性夫妇之间的法律差别被消除了，因为他们已经在一起生活了至少一年。        尽管如此，加拿大最高法院在2002年裁定，当同居伴侣解散他们的联盟时，他们不需要平等地分配他们的财产，也不能强迫一个合伙人向另一方支付抚养费，即使涉及到儿童（新斯科舍省总检察长诉沃尔什，2002）。在法国，未婚情侣可能会签订民事团结协议，这将使他们在结婚3年之后（戴利，2000）的大部分权利和责任。其他几个国家已经建立了注册伙伴关系（Lyall，2004）。        - **同性婚姻的出现**          婚姻非制度化的最新发展是使同性婚姻合法化的运动。1993年，夏威夷最高法院裁定，一项限制同性伴侣婚姻的州法律违反了夏威夷州宪法（Baehr v.Lewin，1993），这在1993年成为了美国的一个公共问题。随后，夏威夷选民通过了州宪法修正案，禁止同性婚姻。1996年，美国国会通过了《婚姻保护法》，该法案允许各州拒绝承认在其他州获得许可的同性婚姻。该法案的合宪性还没有在这篇文章中被测试过，因为直到最近，还没有州承认同性婚姻。        然而，在2003年，马萨诸塞州最高法院废除了一项限制异性夫妇婚姻的州法律，同性婚姻在2004年5月成为合法（尽管反对者可能最终会通过州的宪法修正案来禁止同性婚姻）。        这个问题在加拿大进一步发展：在21世纪初，不列颠哥伦比亚省、安大略省和魁北克省的法院裁定，限制同性婚姻的法律是歧视性的，而且联邦政府很可能会在全国范围内使同性婚姻合法化。尽管美国的社会保守派正在寻求一项联邦宪法修正案，但我认为，有理由认为，未来至少在一些北美地区，同性婚姻将被允许。在欧洲，同性婚姻在比利时和荷兰合法化。        选择结婚的女同性恋和同性恋伴侣必须积极地构建一个几乎没有任何机构支持的婚姻世界。女同性恋者和男同性恋者已经用“家庭”这个词来描述他们的亲密关系，但他们通常指的是与标准的婚姻家庭不同的东西。        相反，他们通常指的是社会学家所说的“选择家庭”：一个主要是通过非生物或法律相关的个体之间的自愿联系形成的（周，Heaphy，&多诺万,2001;韦斯顿,1991)。        现在，他们面临的任务是将婚姻融入到这些更大的朋友和亲属网络中。这些合作伙伴甚至都不可能放弃异性婚姻中性别差异的角色。这并不是说不会有劳动分工;一项针对同性恋伴侣的研究发现，在一个伴侣工作时间更长、收入比另一个伴侣高得多的家庭中，那些要求较低、薪水较低的家庭做了更多的家务，更多的工作是与家人和朋友保持联系。作者建议，持有一份苛刻的专业或魔法工作可能会让一个人很难完全投入到在家里分享工作，而不考虑性别或性取向（林顿，1999）。        我们可能会认为，有孩子的同性伴侣，或者希望通过收养或捐赠的方式生育孩子的同性伴侣，很可能会利用婚姻的选择。（美国人口普查局2003b，33%的同性伴侣，2000年，同性伴侣中有22%的男性和同性伴侣有过同居关系。）基本问题，如谁会照顾孩子，必须由家庭来解决。合作伙伴对彼此的义务也尚未得到解决。在这些和许多其他方式中，在不久的将来结婚的男女同性恋者需要通过讨论、谈判和实验来建立一个以婚姻为中心的亲属网络。        - **婚姻意义上的两个转变**          从更大的意义上说，所有这些发展——改变劳动分工、婚外生育、同居和同性婚姻——都是在20世纪改变婚姻意义的长期文化和物质趋势的结果。文化的发展趋势首先是强调情感满足和浪漫爱情，这在本世纪初变得更加强烈。        然后，在这个世纪的最后几十年里，一种富有表现力的个人主义的道德观——贝拉，马斯登，沙利文，斯威德勒，&蒂普顿（1985）描述了这样一种信念：“每个人都有一种独特的感觉和直觉，如果要实现个性，就应该发展或表达”（第334页）——变得更加重要。在物质方面，趋势包括农业劳动力的减少和工资劳动的相应增加;儿童和成人死亡率的下降;生活水平的上升;在20世纪后半叶，已婚妇女进入有偿劳动力的运动。        这些发展，以及大萧条和第二次世界大战等历史事件，在20世纪对婚姻的意义产生了两大变化。欧内斯特布尔-格斯曾将第一个称为“从一个机构到一个伙伴”的转变（伯吉斯&洛克,1945)。在描述伴侣婚姻的兴起时，伯吉斯指的是在20世纪50年代蓬勃发展的单身挣钱、养家糊口的家庭婚姻。尽管在伴侣婚姻中，丈夫和妻子通常都坚持劳动分工，但他们应该是彼此的伴侣——朋友，爱人——在某种程度上，在上一个时代的制度婚姻中，配偶是无法想象的。        越来越多地关注核心家庭的情感纽带是家庭生活个性化的重要但有限的一步。与19世纪相比，配偶的情感满足成为婚姻成功的重要标准。然而，在20世纪50年代，妻子和丈夫们倾向于从他们在婚姻生活的核心家庭中获得满足感（Roussel，1989）。也就是说，他们把自己的快乐建立在良好的婚姻角色上：成为好的提供者，好的家庭主妇，和有责任的父母。        在这第一次意义上的改变中，婚姻仍然是在美国、加拿大和欧洲建立性关系和抚养孩子的唯一社会可接受的方式，北欧国家可能例外。在他的英国婚姻史中，Gillis（1985）将从1850年到1960年的这段时期称为“强制婚姻的时代”。在美国，婚姻并且只有婚姻是家庭生活的入场券。        在结婚之前，除了穷人和先锋之外，几乎没有人与伴侣同居。就在20世纪50年代，美国的婚前同居仅限于少数（可能是5%）的受教育程度较低的人（Bumpass，Sweet，&切尔林,1991)。在20世纪50年代早期，只有4%的孩子是在婚外出生的（美国国家健康统计中心，1982）。        事实上，在20世纪40年代末和50年代，提高婚姻重要性的重大变化发生在年轻人的生活中。在20世纪50年代，美国有95%的年轻人结婚，而在本世纪初，这一比例约为90%（切尔林，1992年）——他们在年轻时结婚。        从1900年到1960年，美国第一次婚姻的平均年龄从26岁降至23岁，女性为22岁至20岁（美国人口普查局，2003a）。出生率已经下降了一个世纪或更长时间，急剧上升，创造了“婴儿潮”。第二次世界大战之后，在许多欧洲国家（Roussel，1989年）也出现了增长。        但从20世纪60年代开始，婚姻的主导地位开始下降，婚姻意义的第二个重大变化发生了。在美国，结婚年龄的中位数回到了20世纪初的水平。2000年，男性的平均年龄为27岁，女性为25岁（美国人口普查局，2003a）。        许多年轻人在20多岁的时候都保持单身，有些人完成了大学教育，开始了职业生涯。婚前同居（和婚后）更容易被接受。婚外生育不再受到歧视，更容易被接受。在大多数国家，出生率恢复了长期下降，降至历史最低水平。离婚率上升到前所未有的水平。同性婚姻也得到了更大的认可。        在这一转变过程中，同伴婚姻不仅作为人口标准，而且作为一种文化理想，失去了根基。它逐渐被伯吉斯没有预见到的婚姻（和非婚家庭）的形式所取代，尤其是丈夫和妻子在外面工作的婚姻。尽管妇女继续承担大部分家务和照顾孩子的责任，但妻子和丈夫的角色变得更加灵活，更容易进行谈判。        而且，对婚姻的回报更加个人主义的观点根深蒂固。当人们评价他们与他们的婚姻有多满意时,他们开始考虑自己的自我意识的发展和表达自己的感情,而不是满足他们通过建立一个家庭,扮演一个配偶或父母的角色。其结果是，从伙伴关系的婚姻过渡到我们所说的“个性化婚姻”。        从20世纪60年代开始，向个性化婚姻的过渡开始于20世纪70年代，美国的一项研究表明，在1900年至1979年的每十年里，在流行杂志文章中提供婚姻建议的主题不断变化（can西恩，1987）。作者确定了三个主题，这些主题是关于后60年风格的婚姻的。        第一个是自我发展：每个人都应该发展一个充实的、独立的自我，而不是仅仅是把自己变成一个人的伴侣。        第二，婚姻中的角色应该是灵活和可协商的。        第三，在面对问题时，沟通和开放是最重要的。然后她计算了每十年中包含一个或多个这三个主题的文章的百分比。        本世纪头十年的三分之一的文章，以及20世纪中期的文章，都展示了这些主题，而在20世纪70年代，大约三分之二的主题展示了这些主题。作者将这种转变描述为强调“从角色到自我”的转变。        在婚姻意义的第二个变化中，法律的作用也发生了很大的变化。这种转变在离婚法中最为明显。在美国和大多数其他发达国家，对离婚的法律限制被那些承认双方同意甚至单方面离婚的法律所取代。        过渡到“私人定制”（Mnookin&Korhauser，1979年）允许在广泛的范围内协商离婚协议的细节。大多数欧洲国家都经历了类似的法律发展（Glendon，1989;延伸,1993)。事实上，法国社会人口学家Louis Roussel（1989）在行为和法律上写了一份“双重去机构化”：年轻人更大的犹豫要结婚，再加上婚姻的法律规定的放松。        晚期现代主义（或后现代主义）的社会学理论家，如安东尼-登斯登（1991年，1992年）在英国和德国的李晶贝克和伊丽莎白贝克希姆海姆（1995年，2002年）也写过关于个人生活的不断增长的文章。与去机构化的理念相一致，他们注意到社会规范和法律作为家庭生活的重组机制的力量正在下降，他们强调个人选择的作用越来越大。        他们认为，由于传统的身份来源，如阶级、宗教和社区失去了影响力，一个人的亲密关系成为自我认同的核心。（1991年，1992年）写了“纯粹的关系-船”的出现：一种亲密的伙伴关系是为了它自己的利益而进入的，只要双方都能满足于他们从它得到的回报（大部分是来自于梅西和爱）。        从某种程度上说，这是20世纪发生的“增加个人主义”的逻辑延伸，以及婚姻的非制度化。纯洁的关系不与婚姻或抚养孩子的愿望联系在一起。相反，它是“自由浮动的”，独立于社会机构或经济生活。与婚姻不同的是，它不受法律的约束，其成员也不享有特殊的法律权利。它主要存在于情感和自我认同的领域。        尽管晚期现代性的理论家们认为，对亲密关系的追求正成为个人生活的中心焦点，但他们并没有预言婚姻将保持独特和重要。他们声称，对于想要亲密、陪伴和孩子的成年人来说，婚姻已经成为一种选择，而不是一种必需品。        根据Beck和Beck-Gersheim（1995）的说法，我们将看到“各种各样的生活方式，它们将继续共存”（第141-142页）。（1992年）甚至认为婚姻已经成为“一种生活方式”（第154页），尽管人们可能还没有意识到这是由于制度上的滞后。        - **目前的婚姻状况**            总的来说，关于婚姻的变化意义的研究和写作表明，它现在处于一个与过去完全不同的环境中。这至少在两种意义上是正确的。首先，个人在个人生活中有很大的选择余地。更多形式的婚姻和更多的婚姻选择在社会上是可以接受的。此外，一个人可以在很多方面把婚姻融入到自己的生活中:一个人可能会先和一个伴侣一起生活，或者和几个伙伴一起生活，而没有明确地考虑是否会发生婚姻。        一个人可能在结婚前生下一个人的最终配偶或与他人的孩子。在某些司法管辖区，人们可能会与同性结婚，建立一个共同的婚姻世界，几乎没有什么可依赖的准则。在婚姻中，角色更灵活，更有商量余地，尽管女性在家务劳动和抚养孩子中所占的比例仍然高于她们的份额。        第二个不同之处在于人们通过婚姻和其他亲密关系寻求的回报的本质。个人的目标是通过更开放的交流和与合作伙伴共同分享的信息来实现个人成长和加深亲密关系。他们可能会觉得坚持改变一段关系，不再为他们提供个性化的奖励，这是有道理的。        与此相反，他们比过去更不可能专注于在满足社会价值的角色中获得的回报，比如好的父母或忠诚的和支持的配偶。这些变化的背景是婚姻的非制度化，在这种情况下，家庭和个人生活的社会规范比在伴侣婚姻的鼎盛时期要少，而且远低于制度婚姻时期。相反，个人选择和自我发展在人们的婚姻事业中显得很重要。        **二、为什么人们还会结婚?**        在这个需要解决的问题的故事中有一个谜题。根据最近的一项估计，尽管美国人结婚的人数比20世纪中期的高峰时期要少，但接近90%-大多数会结婚。自1976年以来，每年对高中毕业生的调查显示，他们对婚姻的重视程度没有下降。年轻女性的预期结婚比例保持在大约80%的水平（年轻男性的比例从71%上升到78%）。        对“有良好的婚姻和家庭生活”的人来说，“拥有良好的婚姻和家庭生活”的比例也保持不变，年轻女性的比例约为80%，年轻男性为70%（Thorton&Young-DeMarco,2001)。        更重要的是，在20世纪90年代和21世纪初，在美国的男同性恋者中出现了一场强烈的宣传运动，他们寻求结婚的权利，并取得了越来越大的成功。显然，婚姻对美国的许多人来说仍然很重要。        因此，我认为有趣的问题不是为什么很少有人结婚，而是为什么这么多人结婚，或者计划结婚，或者想结婚，同居和单亲家庭是可以接受的选择。（在加拿大和许多欧洲国家，这一问题可能不那么重要，因为在这些国家中，会结婚的人更低。）        - **婚姻的好处**          在20世纪，关于婚姻的主流理论观点并没有提供太多关于婚姻为何如此受欢迎的问题的指导。社会人类学和社会学的结构功能主义者在20世纪早期到20世纪中期强调了婚姻在确保一个孩子与一个人的地位、他的保护权和继承他的财产的权利之间的联系（Mair，1971）。        但是，随着法律开始承认婚外生育的孩子的权利，以及母亲通过在有偿劳动大军中获得资源，这些婚姻的原因变得不那么重要了。        进化理论也不是很有帮助。尽管可能对家庭行为有重要的进化影响，但人类不太可能像我们所知道的那样，发展出天生的对婚姻的偏爱。对我们进化遗产的经典描述是，女性的生育能力受到怀孕和哺乳的限制（这延缓了排卵的回归），寻求与男性稳定的配对关系，而男性则通过让许多女性受孕来最大化自己的生育能力。        在20世纪早期和20世纪中期的人类学著作中，人们描述了以婚姻为中心的亲属关系，而不是“自然的”，这是一种社会发明，解决了性游荡的男性的问题（Tiger&狐狸,1971)        此外，如果没有可靠的男性提供者，女性可能更倾向于依靠女性亲属和不止一个男性的生殖策略（Hrdy，1999）。此外，在孩子出生后，婚姻的形成也越来越多，然而进化理论认为，当新生的孩子需要支持和保护时，结婚的动力应该是最大的。在20世纪50年代，在美国未婚的未婚女性中，有一半在孩子出生之前就结婚了，而在20世纪90年代，只有四分之一的已婚妇女（美国人口普查局，1999年）。        最后，进化理论无法解释人们仍在结婚的正式婚礼方式的持久性（见下文）。对工业化前社会的研究发现，尽管许多人都有精心的仪式，但其他人很少或根本没有仪式（灰烬，灰烬，&游隼,2002;史蒂芬斯,1963)。        20世纪中期的经济学家加里贝克尔（1965年，1981年）的专业化模式似乎也不像它被引入时那么重要。贝克尔认为，女性在家里的生产力比男性要高，而且男性的工作效率更高（也就是说，男性的工作效率更高。在劳动力市场上，他们可以获得更高的工资）。他认为，通过婚姻、妇女的家务劳动来换取男性劳动力市场的工作，女性和男性可以增加他们的效用。        这种专业化模式可以预测，在当今时代，劳动力市场潜力较小的女性更有可能结婚，因为她们在寻找丈夫方面会获得最大的经济收益。但几项研究表明，近几十年来，美国和加拿大的女性受教育程度较低（在劳动力市场潜力较小的情况下）不太可能结婚（利奇特、麦克劳克林、凯菲特和兰德里,1992;奥本海默,Blossfeld,,Wackerow,1995;钱,普雷斯顿,1993;《理发师陶德》,2002;Turcotte,Goldscheider,1998)。        这一发现表明，专业化模式可能不再适用。此外，这种专业化模式是在同居之前发展起来的，并没有解释为什么夫妻会结婚而不是同居。        从理性的选择角度来看，当代婚姻能带来什么好处，从而导致同居伴侣结婚而不是同居？    我认为主要的好处是我们可以称之为可执行的信任（Cherlin，2000;波茨,杉司勃伦纳移民,1993)。婚姻仍然需要公开承诺，以长期的、可能终生的关系。这种承诺通常是在亲戚、朋友和宗教信仰的人面前表达的。相比之下，同居只需要一个私人的承诺，这更容易打破。因此，婚姻比同居更重要，降低了伴侣违背协议的风险。        在经济理论的语言中，婚姻降低合作伙伴之间达成协议的交易成本（Pollak，1985）。它允许个人投资于合伙企业，减少对被抛弃的恐惧。例如，它允许合作伙伴投资于家庭和汽车等长期的长期购买。它使护理人员能够做出与船相关的投资（英格兰&Farkas，1986年）在这对夫妇的孩子们的时间和努力上，不像加强自己的工作技能，不容易移植到另一段亲密的关系中。        然而，与同居相比，婚姻带来的可执行的信任程度的差异正在消失。尽管亲戚和朋友会对离婚感到失望，但他们会比两代人更容易接受离婚。正如我所指出的，同居伴侣越来越多地获得了以前为已婚夫妇保留的权利。        随着时间的推移，在美国、加拿大和许多欧洲国家，同居和婚姻之间的法律差异将变得微乎其微。婚姻在增进信任方面的优势，将取决于合作伙伴的世俗和宗教承诺的力量。总的来说，流行的理论观点更有价值解释为什么婚姻会下降，而不是为什么婚姻持续。        随着越来越多的女性在户外工作，这种专业化模式的预测就不那么重要了。尽管理性选择理论家提醒我们，婚姻仍然提供可执行的信任，但很明显，它的执行力正在下降。        最近，进化理论家们认为，那些很难找到可靠的提供者的女性可能会选择一个涉及单亲家庭和亲属网络的生育策略，这一策略与低收入家庭发生的变化是一致的。尽管晚期现代性理论家的见解帮助我们理解婚姻的变化意义，但他们预测婚姻将失去其独特的地位，事实上，婚姻可能已经成为了一种生活方式。那么，为什么还有那么多人还在结婚呢？        - **婚姻的象征意义**          事实是，尽管结婚的实际重要性已经下降，但它的象征意义仍然很高，甚至可能还在增加。婚姻比以前更不重要，也更有特色。它已经从一种一致性的标记演变为一种威望的标志。婚姻是一种地位，通常是通过与伴侣一起生活，        通过获得稳定的就业或开始职业生涯，通过存一些储蓄，甚至是生孩子。在这些投资之前，婚姻在生活中所处的位置曾经是过去的，但现在往往是在之后。它曾经是成人个人生活的基础;现在，它有时是顶点。这是通过自己的努力来实现的，而不是一个例行公事地去做的事情。        - **低收入者如何看待婚姻**          矛盾的是，美国较低的社会阶层之一，结婚率最低，对婚姻的持久偏好和其变化的意义似乎最为明显。虽然婚姻是可选的，而且经常是被放弃的，但在穷人和穷人中，婚姻并没有消失。相反，它是一个非常受欢迎但却难以捉摸的目标。        他们告诉观察家,他们希望结婚,但只有当他们确信他们可以成功:当对方已经证明的能力持有一份体面的工作,公平的对待他们,没有滥用,当他们有一个保证金或首付一个像样的公寓或家里,当他们在银行有足够支付一个家人和朋友的婚礼。        艾丁Kefalas和(即将到来的),研究生育和亲密关系现状，费城在8 165名母亲中低收入社区,写道,“从某种意义上说,婚姻是一种社会吹嘘这对夫妻关系的质量,有力地象征性的方式提升一个高于其他社区的关系,特别是在一个社区,婚姻是罕见的。        我和几个合作者一起，对美国三个城市的低收入家庭进行了一项研究。这项研究的人种学部分是由宾夕法尼亚州立大学的琳达伯顿指导的。一位27岁的母亲告诉我们的一位民族志学者：        *我的一生都很贫穷，雷金纳德也是如此。当我怀孕的时候，我们同意在未来的某一天结婚因为我们彼此相爱并且想要一起抚养我们的孩子。但是我们不会结婚，除非我们能负担得起一所房子，并按时支付所有的公用事业费用。我有关于公用事业帐单的事情。在我们成长的过程中，我们的煤气和电力都被关闭了，我们想要确保在我们结婚的时候不会发生这种情况。这是我们最大的担忧……我们一起工作，积累了积蓄，然后我们结婚了。我们是永远的。*        在我们的研究中，另一个女人，已经和她订婚的男人住在一起，和她一起生活，她告诉一位民族志学者她还没有准备好嫁给他：        *但我还没准备好。我告诉他，我们还没准备好。他知道。我在今年年底告诉他，也许吧。我去年就告诉他了。另外，你可以说，我们都需要学会控制自己的脾气。他不明白账单、孩子和我们的关系是第一位的，而不是他出去买新衣服，或者他做这件事。是孩子们，然后是我们。他得到的报酬很好，每周大约500美元。给我钱，帮我付账单有多难？*        请注意，对于这个女人来说，在他结婚之前，更需要的是一个男人而不是一个稳定的工作。他必须学会把大部分的薪水交给他的家人，而不是把钱花在他的朋友和他自己身上。在和他的单身男性朋友一起跑步之前，他必须把他和他的伴侣放在一起，这是一种说法，即丈夫必须优先考虑为妻子提供陪伴和亲密关系，以及对性忠诚。他和他的伴侣必须学会控制自己的脾气，这是一种模糊的说法，指的是这种关系中存在肉体虐待的可能性。        总而言之，低收入女性对男性的要求不仅包括可靠的收入，也包括重要的收入，同时也承诺将家庭放在第一位，提供陪伴，忠诚，避免虐待行为。        - **一般的年轻人是如何看待这个问题的**          婚姻的变化意义并不局限于低收入人群。考虑一项全国代表性的调查，调查对象为1 003名年龄在20-29岁之间的成年人，他们在2001年对婚姻的态度进行了调查（怀特海德&Popenoe,2001)。大多数人的回应方式暗示了婚姻是一种建立起来的地位。62%的人同意这样的说法：“婚前同居是避免最终离婚的好方法”，82%的人认为“在结婚前经济上的安排是非常重要的。”此外，大多数人认为婚姻以亲密和爱为中心而不是像财务和孩子这样的实际问题。        百分之九十四的从未结过婚的人都同意“当你结婚的时候，你希望你的配偶成为你的灵魂伴侣，首先也是最重要的。”相比之下，只有16%的人认为“现在婚姻的主要目的是生孩子。”超过80%的女性认为，“有一个丈夫能够表达自己最深切的感受，而不是拥有一个能过上好日子的丈夫，这一点更为重要。”该报告的作者总结道：“虽然婚姻正在失去其广泛的公共和制度特征，但它作为一种超级关系，一种高度私人的精神化的结合，将性忠诚、浪漫爱情、情感亲密和归属感结合在一起，越来越受欢迎。”（第13页）。        - **婚礼作为一种身份象征**          甚至婚礼也成为了个人的成就。在遥远的过去，一场婚礼是两个亲属团体组成联盟的事件。最近，这是一个由家长组织和支付的活动，在这一活动中，他们对孩子的婚姻表示认可和支持。在这两种情况下，都是为生孩子提供法律和社会认可的仪式。        但是，与婚姻的非制度化相一致，它现在正成为一个以夫妻双方为中心的活动，而不是过去的家庭批准或生孩子。人们可能会认为，婚礼会变得更小，许多夫妇会完全放弃一场公共婚礼。但对大多数夫妇来说，这似乎并没有发生。婚礼似乎已经成为合作伙伴个人成就的重要标志，也是他们自我发展的一个阶段（Bulcroft、Bulcroft、布拉德利和辛普森,2000)。        1984年，底特律都市地区的459名已婚妇女进行了一项调查，调查了20世纪大部分时间美国婚礼的发展趋势。Whyte（1990）将这些妇女分成了一个战前的群体，她们在1925年到1944年间结婚，这是一个在1945年到1964年间结婚的婴儿潮群体，另一个是在1965年到1984年间结婚的群体。在这项调查所引发的半个多世纪的生活史中，一些婚礼仪式和活动的指标随着时间的推移而增加。        在宗教机构（如教堂或犹太教堂）中报告婚礼的妇女比例从68个增加到74个;参加婚礼的比例从64%上升到88%;有新娘淋浴或其配偶有单身派对的比例急剧上升;而度蜜月的百分比从47%上升到60%。其中一些趋势可能是由日益富裕引起的，但不是全部。为什么富裕会导致更多的宗教婚礼，这一点并不明显。事实上，人们可能期望富裕会导致婚姻过程的世俗化和公民婚礼的增加。        在最近的几十年里，当伴侣们决定他们的关系终于到了可以结婚的阶段时，他们通常想要一场充满仪式的婚礼来庆祝。关于当代婚礼和蜜月的小型文献正在北美和欧洲发展，并将其视为消费和浪漫庆典的场合（Boden，2003;Bulcroft et al .,2000;Bulcroft、Bulcroft Smeins,,吊车费1997;英格拉,1999)。即使是低收入和中等收入的夫妇，他们的资金有限，而且可能已经有了孩子，可能还住在一起，他们似乎把一场婚礼看作是婚姻的必要条件。        在我们的研究中，许多女性说她们不会在没有教堂婚礼的情况下结婚。只是去市政厅参加一个民事仪式，这对他们来说是不可接受的。同样，在曼宁和斯莫克（2003）的研究中，一些工人阶级和下层中产阶级的夫妇说，仅仅是去“市中心”参加一个民事仪式并不构成一个可以接受的婚礼（Smock，2004;工作服,曼宁,,波特,2004)。艾丁和凯法拉斯（即将出版）写了他们所研究的母亲们的态度，“有足够的钱来举办一场盛大的婚礼，这是一个生动的展示，表明这对夫妇已经获得了足够的经济保障，不仅仅是靠薪水过活。”        在我们的研究中，夫妻们想要通过他们的婚礼发表声明，这是对他们自己和他们的朋友和家人的一种声明，他们在自我身份的发展过程中经历了一个里程碑。通过结婚仪式、买房子、以及获得其他婚姻生活的机会，个人希望展示他们获得一种享有声望、舒适、稳定的生活方式。他们还期望婚姻能提供一些可执行的信任。但正如我所言，婚姻的执行价值比过去要小。现在人们为了婚姻所提供的社会福利而结婚的次数少于其代表的个人成就。        **三、未来发展趋势预测**        这些发展对婚姻的未来有什么影响？社会人口统计学家通常预测，目前的任何事情都是偶然的，而且他们通常是正确的，但有时是大错特错的。例如，在20世纪30年代，美国的每一位人口统计学专家都满怀信心地预测，低出生率将继续下去。没有人预测在第二次世界大战后，婴儿潮已经超过了他们。        与金斯利戴维斯（1937）一样，学者认为，作为一个社会机构，家庭的未来正处于危险之中，因为人们没有足够的孩子来取代自己。20世纪50年代或60年代的社会学家没有预测到同居的增加。由于这一不令人印象深刻的记录，我将初步勾画出一些未来的方向。        第一种选择是将婚姻重新制度化，回归到20世纪中期的地位，类似于它的主导地位。这将导致结婚的比例上升，出生人口比例的上升，已婚夫妇的比例上升，以及离婚率的下降。这将需要逆转个人主义倾向于家庭和个人生活，而这正是过去几十年推动家庭变革的主要文化力量。这可能还需要减少妇女的劳动力参与率，并回归到更多性别类型的家庭角色。我认为这种选择很不一样，但话说回来，婴儿潮也是如此。        第二种选择是继续当前的状况，在这种情况下，婚姻仍然是不制度化的，但却是普遍和独特的。这不仅仅是一种家庭关系;相反，它是最具声望的形式。人们通常渴望结婚。但这是一个个人的选择，个人通过一个越来越长的过程来构建婚姻，这通常包括婚前同居和生育。        它的传统好处，比如可执行的信任，但它正日益成为声望的标志，展示的区别，个人主义的成就，这是Beck和beck-gemim（2002）所称的“自己动手的传记”的一部分。在这种情况下，结婚的人的比例可能会进一步下降;特别是，我们可以看到，美国白人的婚姻概率与今天非洲裔美国人的概率相似。此外，由于高水平的非婚生子、同居和离婚，人们在成年后的生活中所占的比例要比过去少。尽管如此，婚姻仍将保持其在家庭系统中的特殊和高度重视的地位。        但我承认，对于这种替代方案能否在美国长期占据上风，我也持怀疑态度。相对于同居，婚姻的特权和物质优势一直在下降。伴侣的承诺是值得信赖的，这一承诺被频繁的离婚所破坏。如果婚姻曾经是一种文化资本的形式，那就需要结婚来提升自己的事业，那就是资本也减少了。        我认为，剩下的就是声望和成就的展示。但也有可能是婚姻保留了它的象征光环，很大程度上是因为它在半个世纪前的社会规范中占据了主导地位。可能是这个光环正在减弱，就像峡谷里的回声。这可能是，尽管婚礼行业付出了努力，但需要一个高度仪式化的仪式和合法化的地位将会消失。在21世纪初，没有什么其他的支持婚姻。        这就导致了第三种选择，即婚姻的消失。这里的论点是，由于制度上的滞后，人们仍然大量结婚;他们还没有意识到婚姻不再重要。一种非婚姻的纯关系，利用了多登斯的理想类型，可以提供更多的亲密和爱，可以让双方都处于平等的地位，并能让他们发展出独立的自我意识。这些特点在后期的社会中被高度重视。        然而，这一选择也表明，脆弱的关系的主导地位不断地处于分裂的危险之中，因为它们完全由每个合作伙伴的自愿承诺维系在一起。人们可能仍然会在道德上承诺一段关系，但他们越来越倾向于自愿而不是按照法律或社会规范来承担义务。合作伙伴可以随时撤销他们的承诺。        因此，纯粹的关系似乎是一个承诺并不重要的世界的最典型特征。因此，它似乎最适合中产阶级、受过良好教育、没有孩子的成年人。他们有自己的资源，可以独立地成为独立的参与者，或者在民主的伙伴关系中，没有生育责任，他们可以自由浮动。纯关系似乎不太适用于面临物质限制的夫妇（Jamieson，1999）。特别是，当孩子是现在的时候，或者当他们被期待的时候，就会考虑到承诺和支持的问题。在他的关于亲密关系的书中，他（1992）对孩子们的描述很少，他试图把孩子们融入到纯粹的关系中，这是不令人信服的。        那些或认为自己将成为孩子的主要照顾者的人更愿意承诺，并将寻求来自他们的伴侣的物质支持。他们可能愿意生孩子，在没有承诺的情况下开始同居，但如果没有这种关系，这种关系可能不会长久。如果他们认为自己能做得更好，他们会对纯粹的自愿承诺保持警惕。因此，只有当婚姻在提供信任和承诺的优势消失后，我必须承认，这可能会发生——我们可能会看到同居和婚姻的平等。        总而言之，我看到了目前的婚姻状况，以及它可能的未来：目前，婚姻不再像以前那样占主导地位，但在象征性的层面上，婚姻仍然很重要。它已经从一个家庭和社区机构转变为一个个性化的、基于选择的成就。它是声望的标志，在创造可执行的信任方面仍然有一定的用处。        至于未来，我已经草拟了三种备选方案。        第一个，回归到一种更主流的，制度化的婚姻形式，似乎不太可能。        在第二种情况下，目前的情况仍在继续;婚姻仍然很重要，但不是占主导地位，并保持其较高的象征地位。        在第三种情况下，婚姻逐渐变成了多种人际关系中的一种。我认为，到目前为止，在美国，婚姻已经成为许多关系中的一种，这一说法在美国是不正确的，但在未来可能会成为现实。        我们有可能生活在一个过渡阶段婚姻正逐渐失去其独特性。如果让人眼花和现代理论家是正确的，那么第三种改变将会胜利，而婚姻将失去其在美国家庭系统中的特殊地位。如果他们不这样做，第二种选择就会继续存在，婚姻转变和被制度化，但不可辨认的永远都是与众不同的。        **备注：**    我要感谢弗兰克弗斯滕伯格、约书亚戈德斯坦、凯思琳基曼和塞琳勒布尔达斯，感谢她对一个预防版本的评论，以及琳达伯顿在三城研究人种学方面的合作研究。        （英文版回复 婚姻 获取）    **参考文献：**    Baehr v. Lewin  (74  Haw.  530,  74 Haw.  645,  852    P.2d 44  1993).    Beck, U.,  &  Beck-Gersheim,  E.  (1995).  The nor-    mal chaos  of  love.  Cambridge, England: Polity    Press.    Beck, U.,  &  Beck-Gersheim,  E.  (2002).  Individuali-    zation: Institutionalized individualism and its    social and  political consequences.  London:  Sage.    Becker,  G. S.  (1965).  A  theory  of the allocation of    time. Economic  Journal, 75,  493-517.    Becker,  G. S.  (1981).  A treatise on the  family.    Cambridge,  MA: Harvard  University  Press.    Bellah, R., Marsden, R., Sullivan,  W.  M., Swidler,    A.,  &  Tipton,  S. M.  (1985).  Habits  of  the heart:    Individualism and commitment in America. Berke-    ley: University  of California Press.    Boden,  S.  (2003). Consumerism,  romance and the    wedding experience. Hampshire, England: Palgrave    Macmillan.    Bulcroft, R., Bulcroft, K., Bradley,  K.,  &  Simpson,    C.  (2000).  The  management  and  production  of risk    in romantic  relationships:  A  postmodern paradox.    Journal  of Family History, 25,  63-92.    Bulcroft, K., Bulcroft, R., Smeins, L.,  &  Cranage,  H.    (1997).  The social construction of the North Amer-    ican  honeymoon,  1880-1995. Journal  of Family    History, 22,  462-490.    Bumpass,  L.  L.,  &  Lu,  H.-H.  (2000).  Trends in    cohabitation and  implications  for children\'s  family    contexts in the United States.  Population Studies,    54,  19-41.    Bumpass,  L.  L., Raley, K.,  &  Sweet,  J. A.  (1995).    The  changing  character of  stepfamilies: Implica-    tions of cohabitation and nonmarital  childbearing.    Demography, 32,  1-12.    Bumpass,  L.  L., Sweet,  J.  A.,  &  Cherlin,  A. J.  (1991).    The role of cohabitation in  declining  rates of mar-    riage.  Journal  of Marriage  and the  Family, 53,    338-355.    Burgess,  E.  W.,  &  Locke,  H. J.  (1945).  The  family:    From institution to  companionship.  New York:    American Book.    Cancian,  F. M.  (1987).  Love in America: Gender and    self-development. Cambridge, England: Cambridge    University  Press.    Carrington,    C.  (1999).  No  place  like home: Relation-    ships  and  family life among  lesbians and  gay  men.    Chicago: University  of  Chicago  Press.    Cherlin,  A.  (1978). Remarriage  as an  incomplete  insti-    tution. American Journal  of Sociology, 84,  634-650.    Cherlin,  A. J.  (1992). Marriage, divorce, remarriage    (Rev. ed.) Cambridge,  MA: Harvard  University    Press.    Cherlin,  A. J.  (2000).  Toward a new home so-    cioeconomics of union formation. In L. Waite,    C.  Bachrach,  M.  Hindin,  E.  Thomson,  &    A. Thorton  (Eds.),  Ties that bind:  Perspectives    on  marriage  and cohabitation  (pp. 126-144).    Hawthorne,  NY: Aldine de  Gruyter.    Daley,  S.  (2000, April 18).  French  couples  take    plunge  that falls short of  marriage.  The New York    Times, pp. Al,  A4.    Davis,  J.  A., Smith,  T.  W.,  &  Marsden,  P.  (2003).    General social  surveys,  1972-2002 cumulative    codebook.  Chicago:  National  Opinion  Research    Center, University  of  Chicago.    Davis,  K.  (1937). Reproductive  institutions and the    pressure  for  population. Sociological Review, 29,    289-306.    Edin,  K.  J.,  &  Kefalas,  M. J.  (forthcoming).  Promises    I can  keep: Why poor  women  put  motherhood    before marriage. Berkeley: University    of    California Press.    Ember,  C.  R., Ember, M.,  &  Peregrine,  P. N.  (2002).    Anthropology (10th ed.). Upper  Saddle  River,  NJ:    Prentice-Hall.    England, P.,  &  Farkas,  G.  (1986). Households,    employment,  and  gender:  A  social, economic, and    demographic  view. New York: Aldine.    Ermisch,  J.  (2001).  Cohabitation and  childbearing    outside  marriage  in Britain. In L. L. Wu &    B. Wolfe  (Eds.),  Out  of  wedlock: Causes and    consequences of  nonmarital  fertility (pp.  109-    139).  New York: Russell  Sage  Foundation.    Giddens,  A.  (1991). Modernity  and  self-identity.    Stanford,  CA: Stanford  University  Press.    Giddens,  A.  (1992).  The  transformation of intimacy.    Stanford,  CA: Stanford  University  Press.    Gillis,  J. R.  (1985).  For better or worse: British mar-    riages,  1600 to the  present. Oxford, England:    Oxford  University  Press.    Glendon,  M. A.  (1989).  Abortion and divorce in    Western law.  Cambridge,  MA: Harvard    University    Press.    Goldstein,  J.  R.,  &  Kenney,  C. T.  (2001). Marriage    delayed  or  marriage forgone?  New cohort forecasts    of first  marriage  for U.S. women. American Socio-    logical Review, 66,  506-519.    Hochschild,  A.  (1989).  The second  shift: Working    parents  and the revolution at home. New York:    Viking.    Hrdy,  S. B.  (1999).  Mother nature: Maternal instincts    and how  they shape  the human  species.  New York:    Ballantine Books.    Ingraham,  C.  (1999).  White  weddings: Romancing    heterosexuality  in  popular  culture. New York:    Routledge.    Jamieson,  L.  (1999). Intimacy  transformed? A criti-    cal look at the  "pure relationship." Sociology, 33,    477-494.    Juby, H., Marcil-Gratton, N.,  & Le  Bourdais,    C. (in    press).  When  parents separate.  Further  findings    from  the National  Longitudinal Survey of  Children    and Youth. Phase 2 research  report  of the  project,    "The  Impact  of Parents\'  Family  Transitions on    Children\'s  Family  Environment and Economic    Well-Being:  A  Longitudinal  Assessment."  Ottawa,    Ontario:  Department  of Justice  Canada,  Child  Sup-    port  Team.    Kieran,  K.  (2002).  Cohabitation in Western  Europe:    Trends, issues,  and  implications.  In A. Booth &    A. C. Crouter  (Eds.),  Just  living together: Implica-    tion  of  cohabitation on  families, children,  and    social  policy (pp. 3-31). Mahwah,  NJ: Erlbaum.    Le  Bourdais, C.,  &  Juby,  H.  (2002).  The  impact  of    cohabitation on the  family  life course in  contempo-    rary  North America:  Insights  from across the bor-    der. In A. Booth & A. C. Crouter  (Eds.),  Just    living together. Implications of  cohabitation on    families, children,  and social  policy (pp.  107-    118). Mahwah,  NJ: Erlbaum.    Le  Bourdais, C.,  &  Marcil-Gratton, N.  (1996).  Fam-    ily  transformations across the  Canadian/American    border: When the  laggard  becomes the leader.    Journal  of Comparative Family Studies, 27,  415-    436.    Lichter,  D.  T.,  McLaughlin,  D.  K., Kephart, G.,  &    Landry,  D. J.  (1992).  Race and the retreat from    marriage:    A  shortage  of  marriageable  men? Ameri-    can  Sociological Review, 57, 781-799.    Lyall,  S.  (2004, February 15).  In  Europe,  lovers now    propose: Marry  me a little. The New York  Times,    p.  A3.    Mair,  L.  (1971). Marriage. Middlesex, England:  Pen-    guin Books.    Manning, W.,  &  Smock,  P. J.  (2003, May).  Measur-    ing  and  modeling  cohabitation: New  perspectives    from qualitative  data.  Paper presented  at the    annual  meeting  of the  Population  Association of    America, Minneapolis,  MN.    Mnookin,  R.  H.,  &  Komhauser,  L.  (1979). Bargain-    ing  in the shadow of the law: The case of divorce.    Yale Law  Journal, 88, 950-997.    Nova Scotia  (Attorney General)  v. Walsh.  (2002).    SCC 83.    Oppenheimer,  V.  K., Blossfeld, H.-P., &  Wackerow,    A.  (1995).  United States of America. In H. P.    Blossfeld  (Ed.),  The new role  of  women:  Family    fbrmation  in modern societies  (pp. 150-173).    Boulder, CO: Westview Press.    Pollak, R. A.  (1985).  A transaction costs  approach    to families and households. Journal  of  Economic    Literature, 23, 581-608.    Portes, A.,  &  Sensenbrenner, J.  (1993).  Embedded-    ness and  immigration:  Notes on the social determi-    nants of economic action. American Journal  of    Sociology, 98, 1320-1350.    Qian, Z.,  &  Preston,  S. H.  (1993). Changes  in Ameri-    can  marriage,  1972 to 1987:  Availability  and    forces of attraction  by age  and education.  Ameri-    can  Sociological Review, 58, 482495.    Roussel,  L.  (1989).  La  famille  incertaine. Paris:    Editions Odile Jacob.    Smock, P. J.  (2004).  The wax and wane of  marriage:    Prospects  for  marriage  in the 21st  century.  Journal    of Marriage  and  Family, 66, 966-979.    Smock, P. J., &  Gupta,  S.  (2002).  Cohabitation in    contemporary  North America. In A. Booth &    A. C. Crouter  (Eds.),  Just  living together:  Im-    plications of  cohabitation on  families, children,    and social  policy (pp. 53-84). Mahwah,  NJ:    Erlbaum.    Smock,  P.  J.,  Manning,  W.  D.,  &  Porter,  M.  (2004,    April). "Everything\'s  there  except money":  How    money shapes  orientations towards  marriage among    cohabitors.    Paper presented  at the annual  meeting  of    the  Population  Association of  America, Boston.    Statistics Canada.  (1997). Report  on the  demographic    situation in Canada 1996  (No. 91-209-XPE).    Ottawa, Ontario: Statistical Reference Centre.    Statistics Canada.  (2002). Changing conjugal life  in    Canada  (No. 89-576-XIE). Ottawa, Ontario: Sta-    tistical Reference Centre.    Statistics Canada.  (2003).  Annual  Demographic  Sta-    tistics, 2002  (No. 91-213-XIB). Ottawa, Ontario:    Statistical Reference Centre.    Stephens,  William N.  (1963).  The  family  in cross-    cultural  perspective.  New York:  Holt, Rinehart    and Winston.    Glendon,  M. A.  (1989).  Abortion and divorce in    Western law.  Cambridge,  MA: Harvard    University    Press.    Goldstein,  J.  R.,  &  Kenney,  C. T.  (2001). Marriage    delayed  or  marriage forgone?  New cohort forecasts    of first  marriage  for U.S. women. American Socio-    logical Review, 66,  506-519.    Hochschild,  A.  (1989).  The second  shift: Working    parents  and the revolution at home. New York:    Viking.    Hrdy,  S. B.  (1999).  Mother nature: Maternal instincts    and how  they shape  the human  species.  New York:    Ballantine Books.    Ingraham,  C.  (1999).  White  weddings: Romancing    heterosexuality  in  popular  culture. New York:    Routledge.    Jamieson,  L.  (1999). Intimacy  transformed? A criti-    cal look at the  "pure relationship." Sociology, 33,    477-494.    Juby, H., Marcil-Gratton, N.,  & Le  Bourdais,    C. (in    press).  When  parents separate.  Further  findings    from  the National  Longitudinal Survey of  Children    and Youth. Phase 2 research  report  of the  project,    "The  Impact  of Parents\'  Family  Transitions on    Children\'s  Family  Environment and Economic    Well-Being:  A  Longitudinal  Assessment."  Ottawa,    Ontario:  Department  of Justice  Canada,  Child  Sup-    port  Team.    Kieran,  K.  (2002).  Cohabitation in Western  Europe:    Trends, issues,  and  implications.  In A. Booth &    A. C. Crouter  (Eds.),  Just  living together: Implica-    tion  of  cohabitation on  families, children,  and    social  policy (pp. 3-31). Mahwah,  NJ: Erlbaum.    Le  Bourdais, C.,  &  Juby,  H.  (2002).  The  impact  of    cohabitation on the  family  life course in  contempo-    rary  North America:  Insights  from across the bor-    der. In A. Booth & A. C. Crouter  (Eds.),  Just    living together. Implications of  cohabitation on    families, children,  and social  policy (pp.  107-    118). Mahwah,  NJ: Erlbaum.    Le  Bourdais, C.,  &  Marcil-Gratton, N.  (1996).  Fam-    ily  transformations across the  Canadian/American    border: When the  laggard  becomes the leader.    Journal  of Comparative Family Studies, 27,  415-    436.    Lichter,  D.  T.,  McLaughlin,  D.  K., Kephart, G.,  &    Landry,  D. J.  (1992).  Race and the retreat from    marriage:    A  shortage  of  marriageable  men? Ameri-    can  Sociological Review, 57, 781-799.    Lyall,  S.  (2004, February 15).  In  Europe,  lovers now    propose: Marry  me a little. The New York  Times,    p.  A3.    Mair,  L.  (1971). Marriage. Middlesex, England:  Pen-    guin Books.    Manning, W.,  &  Smock,  P. J.  (2003, May).  Measur-    ing  and  modeling  cohabitation: New  perspectives    from qualitative  data.  Paper presented  at the    annual  meeting  of the  Population  Association of    America, Minneapolis,  MN.    Mnookin,  R.  H.,  &  Komhauser,  L.  (1979). Bargain-    ing  in the shadow of the law: The case of divorce.    Yale Law  Journal, 88, 950-997.    Nova Scotia  (Attorney General)  v. Walsh.  (2002).    SCC 83.    Oppenheimer,  V.  K., Blossfeld, H.-P., &  Wackerow,    A.  (1995).  United States of America. In H. P.    Blossfeld  (Ed.),  The new role  of  women:  Family    fbrmation  in modern societies  (pp. 150-173).    Boulder, CO: Westview Press.    Pollak, R. A.  (1985).  A transaction costs  approach    to families and households. Journal  of  Economic    Literature, 23, 581-608.    Portes, A.,  &  Sensenbrenner, J.  (1993).  Embedded-    ness and  immigration:  Notes on the social determi-    nants of economic action. American Journal  of    Sociology, 98, 1320-1350.    Qian, Z.,  &  Preston,  S. H.  (1993). Changes  in Ameri-    can  marriage,  1972 to 1987:  Availability  and    forces of attraction  by age  and education.  Ameri-    can  Sociological Review, 58, 482495.    Roussel,  L.  (1989).  La  famille  incertaine. Paris:    Editions Odile Jacob.    Smock, P. J.  (2004).  The wax and wane of  marriage:    Prospects  for  marriage  in the 21st  century.  Journal    of Marriage  and  Family, 66, 966-979.    Smock, P. J., &  Gupta,  S.  (2002).  Cohabitation in    contemporary  North America. In A. Booth &    A. C. Crouter  (Eds.),  Just  living together:  Im-    plications of  cohabitation on  families, children,    and social  policy (pp. 53-84). Mahwah,  NJ:    Erlbaum.    Smock,  P.  J.,  Manning,  W.  D.,  &  Porter,  M.  (2004,    April). "Everything\'s  there  except money":  How    money shapes  orientations towards  marriage among    cohabitors.    Paper presented  at the annual  meeting  of    the  Population  Association of  America, Boston.    Statistics Canada.  (1997). Report  on the  demographic    situation in Canada 1996  (No. 91-209-XPE).    Ottawa, Ontario: Statistical Reference Centre.    Statistics Canada.  (2002). Changing conjugal life  in    Canada  (No. 89-576-XIE). Ottawa, Ontario: Sta-    tistical Reference Centre.    Statistics Canada.  (2003).  Annual  Demographic  Sta-    tistics, 2002  (No. 91-213-XIB). Ottawa, Ontario:    Statistical Reference Centre.    Stephens,  William N.  (1963).  The  family  in cross-    cultural  perspective.  New York:  Holt, Rinehart    and Winston.'},{title:"《JavaScript面向对象精要》读书笔记",path:"/posts/notes/%E3%80%8AJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B2%BE%E8%A6%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html",strippedContent:' ## 1.原始类型和引用类型    ### 1.1 什么是类型    **原始类型** 保存为简单数据值。 **引用类型** 保存为对象，其本质是指向内存位置的引用。    为了让开发者能够把原始类型和引用类型按相同的方式处理，JavaScript花费了很大的努力来保证语言的一致性。    其他编程语言用栈存原始类型，用堆存储引用类型。而JavaScript则完全不同：它使用一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。\x3c!--more--\x3e     ### 1.2 原始类型    原始类型代表照原样保存的一些简单数据。 JavaScript共有 **5** 种原始类型：    - boolean 布尔，值为 `true` or `false`  - number 数字，值为任何整型或浮点数值  - string 字符串，值为由单引号或双引号括住的单个字符或连续字符  - null 空类型，仅有一个值：null  - undefined 未定义，只有一个值：undefined（undefined会被赋给一个还没有初始化的变量）    JavaScript和许多其他语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。    使一个变量等于另一个变量时，每个变量都有自己的一份数据拷贝（深拷贝）。使用自己的存储空间，修改不会影响到其他变量。    ```javascript  var color1 = "red";  var color2 = color1;    console.log(color1); // "red"  console.log(color2); // "red"    color1 = "blue";    console.log(color1); // "blue"  console.log(color2); // "red"  ```    #### 1.2.1鉴别原始类型    鉴别原始类型的最佳方式是使用 `typeof` 操作符。    ```javascript  console.log(typeof "Nicholas"); // "string"  console.log(typeof 10);         // "number"  console.log(typeof true);       // "boolean"  console.log(typeof undefined);  // "undefined"  ```    至于空类型（null）则有些棘手。    ```javascript  console.log(typeof null); // "object"  ```    对于 typeof null，结果是"object"。（其实这已被设计和维护JavaScript的委员会TC39认定是一个错误。在逻辑上，你可以认为 `null` 是一 个空的对象指针，所以结果为"object"，但这还是很令人困惑。）    判断一个值是否为空类型（null）的最佳方式是直接和 `null` 比较：    ```javascript  console.log(value === null); // true or false  ```    > **注意：以上这段代码使用了三等号（全等===）**，因为三等号（全等）不会将变量强制转换为另一种类型。    ```javascript  console.log("5" == 5); // true  console.log("5" === 5); // false    console.log(undefined == null); // true  console.log(undefined === null); // false  ```    #### 1.2.2原始方法    虽然字符串、数字和布尔值是原始类型，但是它们也拥有方法（null和undefined没有方法）。    ```javascript  var name = "Nicholas";  var lowercaseName = name.toLowerCase(); // 转为小写    var count = 10;  var fixedCount = count.toFixed(2); // 转为10.00    var flag = true;  var stringFlag = flag.toString(); // 转为"true"    console.log("YIBU".charAt(0)); // 输出"Y"  ```    > 尽管原始类型拥有方法，但它们不是对象。JavaScript使它们看上去像对象一样，以此来提高语言上的javas一致性体验。    ### 1.3 引用类型    引用类型是指JavaScript中的对象，同时也是你在该语言中能找到最接近类的东西。 引用值是引用类型的实例，也是对象的同义词（后面将用对象指代引用值）。对象是属性的无序列表。属性包含键（始终是字符串）和值。如果一个属性的值是函数，它就被称为方法。除了函数可以运行以外，一个包含数组的属性和一个包含函数的属性没有什么区别。    #### 1.3.1创建对象    把JavaScript对象想象成哈希表可以帮助你更好地理解对象结构。    ![](http://p8xb02d0d.bkt.clouddn.com/18-7-7/36685022.jpg)        JavaScript 有好几种方法可以创建对象，或者说实例化对象。第一种是使用 `new` 操作符和构造函数。 构造函数就是通过 `new`操作符来创建对象的函数——任何函数都可以是构造函数。根据命名规范，JavaScript中的构造函数用**首字母大写**来跟非构造函数进行区分。    ```javascript  var object = new Object();  ```    因为引用类型不再变量中直接保存对象，所以本例中的 `object` 变量实际上并**不包含对象的实例，而是一个指向内存中实际对象所在位置的指针（或者说引用）**。这是对象和原始值之间的一个基本差别，原始值是直接保存在变量中。    当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。这意味着，将一个变量赋值给另外一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的同一个对象（**浅拷贝**）。    ```javascript  var obj1 = new Object();  var obj2 = obj1;  ```    ![](http://p8xb02d0d.bkt.clouddn.com/18-7-7/35723095.jpg)        #### 1.3.2对象引用解除    JavaScript语言有垃圾收集的功能，因此当你使用引用类型时无需担心内存分配。**但最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为 null。**    ```javascript  var obj1 = new Object();  // dosomething  obj1 = null; // dereference  ```    #### 1.3.3添加删除属性    在JavaScript中，可以随时添加和删除其属性。    ```javascript  var obj1 = new Object();  var obj2 = obj1;    obj1.myCustomProperty = "Awsome!";  console.log(obj2.myCustomProperty); // "Awsome!" 因为obj1和obj2指向同一个对象。  ```    ### 1.4 内建类型实例化    内建类型如下：    - Array 数组类型，以数字为索引的一组值的有序列表  - Date 日期和时间类型  - Error 运行期错误类型  - Function 函数类型  - Object 通用对象类型  - RegExp 正则表达式类型    可使用 `new` 来实例化每一个内建引用类型：    ```javascript  var items = new Array();  var new = new Date();  var error = new Error("Something bad happened.");  var func = new Function("console.log(\'HI\');");  var object = new Object();  var re = new RegExp();  ```    #### 1.4.1字面形式    内建引用类型有字面形式。字面形式允许你在不需要使用 `new` 操作符和构造函数显示创建对象的情况下生成引用值。属性的**键**可以是标识符或字符串（若含有空格或其他特殊字符）    #### 1.4.2对象字面形式    ```javascript  var book = {      name: "Book_name",      year: 2016  }  ```    上面代码与下面这段代码等价：    ```javascript  var book = new Object();  book.name = "Book_name";  book.year = 2016;  ```    > 虽然使用字面形式并没有调用 new Object()，但是JavaScript引擎背后做的工作和 new Object()一样，除了没有调用构造函数。其他引用类型的字面形式也是如此。    ### 1.5 访问属性    可通过 `.` 和 `中括号` 访问对象的属性。 中括号`[]`在需要动态决定访问哪个属性时，特别有用。因为你可以用**变量**而不是字符串字面形式来指定访问的属性。    ### 1.6 鉴别引用类型    函数是最容易鉴别的引用类型，因为对函数使用 `typeof` 操作符时，返回"function"。    ```javascript  function reflect(value){      return value;  }  console.log(typeof reflect); // "function"  ```    对其他引用类型的鉴别则较为棘手，因为对于所有非函数的引用类型，`typeof` 返回 `object`。为了更方便地鉴别引用类型，可以使用 JavaScript 的 `instanceof` 操作符。    ```javascript  var items = [];  var obj = {};  function reflect(value){      return value;  }    console.log(items instanceof Array); // true;  console.log(obj instanceof Object); // true;  console.log(reflect instanceof Function); // true;  ```    `instanceof` 操作符可鉴别继承类型。这意味着所有对象都是 `Oject` 的实例，因为所有引用类型都继承自 `Object`。    > 虽然 instanceof 可以鉴别对象类型（如数组），但是有一个列外。JavaScript 的值可以在同一个网页的不用框架之间传来传去。由于每个网页拥有它自己的全局上下文——Object、Array以及其他内建类型的版本。所以当你把一个对象（如数组）从一个框架传到另外一个框架时，instanceof就无法识别它。    ### 1.7鉴别数组    采用Array.isArray()鉴别数组    ```javascript  var items = [];  console.log(Array.isArray(items); // true;  ```    ### 1.8 原始封装类型    原始封装类型有 `3` 种：String、Number 和 Boolean。 当读取字符串、数字或布尔值时，原始封装类型将被自动创建。    ```javascript  var name = "Nicholas";  var firstChar = name.charAt(0); // "N"  ```    这在背后发生的事情如下：    ```javascript  var name = "Nichola";  var temp = new String(name);  var firstChar = temp.charAt(0);  temp = null;  ```    由于第二行把字符串当成对象使用，JavaScript引擎创建了一个字符串的实体让 `charAt(0)` 可以工作。字符串对象的存在仅用于该语句并在随后销毁（一种被称为自动打包的过程）。为了测试这一点，试着给字符串添加一个属性看看它是不是对象。    ```javascript  var name = "Nicholas";  name.last = "Zakas";    console.log(name.last); // undefined;  ```    下面是在JavaScript引擎中实际发生的事情：    ```javascript  var name = "Nicholas";  var temp = new String(name);  temp.last = "Zakas";  temp = null; // temporary object destroyed    var temp = new String(name);  console.log(temp.last);  temp = null;  ```    新属性 `last` 实际上是在一个立刻就被销毁的临时对象上而不是字符串上添加。之后当你试图访问该属性时，另一个不同的临时对象被创建，而新属性并不存在。    虽然原始封装类型会被自动创建，在这些值上进行 `instanceof` 检查对应类型的返回值却是 `false`。 这是因为**临时对象仅在值被读取时创建**。`instanceof` 操作符并没有真的读取任何东西，也就没有临时对象的创建。    当然你也可以手动创建原始封装类型。    ```javascript  var str = new String("me");  str.age = 18;    console.log(typeof str); // object  console.log(str.age); // 18  ```    如你所见，手动创建原始封装类型实际会创建出一个 `object`。这意味着 `typeof` 无法鉴别出你实际保存的数据的类型。    另外，手动创建原始封装类型和使用原始值是有一定区别的。所以尽量避免使用。    ```javascript  var found = new Boolean(false);  if(found){      console.log("Found"); // 执行到了，尽管对象的值为 false  }  ```    这是因为一个对象(如 `{}` )在条件判断语句中总被认为是 `true`;    > MDN:Any object whose value is not undefined or null, including a Boolean oject whose value is false, evaluates to true when passed to a conditional statement.    ### 1.9 总结    - 正确区分原始类型和引用类型  - 对于 `5` 种原始类型都可以用typeof来鉴别，而空类型必须直接跟 `null` 进行全等比较。  - 函数也是对象，可用 `typeof` 鉴别。其它引用类型，可用 `instanceof` 和一个构造函数来鉴别。（当然可以用`Object.prototype.toString.call()` 鉴别，它会返回[object Array]之类的）。  - 为了让原始类型看上去更像引用类型，JavaScript提供了 `3` 种封装类型。JavaScript会在背后创建这些对象使得你能够像使用普通对象那样使用原始值。但这些临时对象在使用它们的语句结束时就立刻被销毁。    ## 2. 函数    JavaScript中函数其实也是对象，使对象不同于其它对象的决定性特点是函数存在一个被称为 `[[Call]]` 的内部属性。 **内部属性无法通过代码访问而是定义了代码执行时的行为**。ECMAScript为JavaScript的对象定义了多种内部属性，这些**内部属性都用双重中括号来标注**。    **[[Call]]属性是函数独有的，表明该对象可以被执行。由于仅函数拥有该属性，ECMAScript 定义typeof操作符对任何具有[[Call]]属性的对象返回"function"**。过去因某些浏览器曾在正则表达式中包含 `[[Call]]` 属性，导致正则表达式被错误鉴别为函数。现在所有浏览器已修复。    > 函数通常是使用函数声明语法定义的，如下面的例子所示。   >  > function sum (num1, num2) {   >     return num1 + num2;   > }   > 这与下面使用函数表达式定义函数的方式几乎相差无几。   >  > var sum = function(num1, num2){   >     return num1 + num2;   > };                                                   --《JavaScript高级程序设计》    ### 2.1 声明还是表达式    两者的一个重要区别是：函数声明会被提升至上下文（要么是该函数被声明时所在的函数范围，要么是全局范围）的顶部。    ### 2.2 函数就是值    可以像使用对象一样使用函数（因为函数本来就是对象，Function构造函数更加容易说明）。    ```javascript  sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐  ```    > 从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语  > 法会导致解析两次代码 （第一次是解析常规 ECMAScript 代码， 第二次是解析传入构造函数中的字符串） ，  > 从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。--《JavaScript高级程序设计》    ### 2.3 参数    函数参数保存在类数组对象 `argument` （`Array.isArray(arguments)` 返回 `false`）中。可以接收任意数量的参数。 函数的 `length` 属性表明其期望的参数个数。    ### 2.4 重载    大多数面向对象语言支持函数重载，它能让一个函数具有多个签名。函数签名由函数的名字、参数的个数及其类型组成。 而JavaScript可以接收任意数量的参数且参数类型完全没有限制。这说明JavaScript函数根本就没有签名，因此也不存在重载。    ```javascript  function sayMessage(message){      console.log(message);  }  function sayMessage(){      console.log("Default Message");  }    sayMessage("Hello!"); // 输出"Default Message";  ```    在Javscript里，当你试图定义多个同名的函数时，只有最后的定义有效，之前的函数声明被完全删除（函数也是对象，变量只是存指针)。    ```javascript  var sayMessage = new Function("message", "console.log(message)");  var sayMessage = new Function("console.log(\\"Default Message\\");");    sayMessage("Hello!");   ```    当然，你可以根据传入参数的数量来模仿重载。    > 将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。以下是曾在第 3  > 章使用过的例子。   >  > ````javascript  > function addSomeNumber(num){   >     return num + 100;   > }   >   > function addSomeNumber(num) {   >     return num + 200;   > }   > var result = addSomeNumber(100); //300   > ````  >  > 显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际  > 上与下面的代码没有什么区别。  >  > ````javascript  > var addSomeNumber = function (num){   >   >     return num + 100;   > };   >   > addSomeNumber = function (num) {   >     return num + 200;   > };   > var result = addSomeNumber(100); //300   >   > ````  >  >   >  > 通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——在创建第二个函数时，实际上覆盖  > 了引用第一个函数的变量 addSomeNumber 。           --《JavaScript高级程序设计》    ### 2.5 对象方法    可以在任何时候给对象添加删除属性的值是函数，则该属性被称为方法。    #### 2.5.1 this对象    JavaScript 所有的函数作用域内都有一个 `this` 对象代表调用该函数的对象。在全局作用域中，`this` 代表全局对象（浏览器里的window）。当一个函数作为对象的方法调用时，默认 `this` 的值等于该对象。 **this在函数调用时才被设置。**    ```javascript  function sayNameForAll(){      console.log(this.name);  }    var person1 = {      name: "Nicholas",      sayName: sayNameForAll  }    var name = "Jack";    person1.sayName(); // 输出 "Nicholas"  sayNameforAll(); // 输出 "Jack"  ```    #### 2.5.2 改变this    有 `3` 种函数方法运行你改变 `this` 值。    1. fun.call(thisArg[, arg1[, arg2[, ...]]]);  2. fun.apply(thisArg, [argsArray]);  3. fun.bind(thisArg[, arg1[, arg2[, ...]]])    使用 `call` 或 `apply` 方法，就不需要将函数加入每个对象——你显示地指定了 `this` 的值而不是让JavaScript引擎自动指定。    `call` 与 `apply` 的不同地方是，`call` 需要把所有参数一个个列出来，而 `apply` 的参数需要一个数组或者类似数组的对象（如 `arguments` 对象）。    `bind` 是ECMAScript 5 新增的，它会创建一个新函数返回。其参数与 `call` 类似，而且其所有参数代表需要被**永久**设置在新函数中的命名参数（绑定了的参数（没绑定的参数依然可以传入），就算调用时再传入其它参数，也不会影响这些绑定的参数）。    ```javascript  function sayNameForAll(label){      console.log(label + ":" + this.name);  }  var person = {      name: "Nicholas"  }    var sayNameForPerson = sayNameForAll.bind(person);  sayNameForPerson("Person"); // 输出"Person:Nicholas"    var sayName = sayNameForAll.bind(person, "Jc");    sayName("change"); // 输出"Jc:Nicholas" 因为绑定的形参，会忽略调用时再传入参数  ```    ### 2.6 总结    - 函数也是对象，所以它可以被访问、复制和覆盖。  - 函数与其他对象最大的区别在于它们有一个特殊的内部属性 `[[Call]]`，包含了该函数的执行指令。  - 函数声明会被提升至上下文的顶部。  - 函数是对象，所以存在一个 `Function` 构造函数。但这会使你的代码难以理解和调试，除非函数的真实形式要直到运行时才能确定的时候才会利用它。    ## 3.理解对象    创建自己的对象的时候,记得**JavaScript中的对象是动态的,可在代码执行的任意时刻发生改变**。    基于类的语言会根 据类的定义锁定对象, JavaScript对象没有这种限制。**JavaScript编程一大重点就是管理那些对象**,这就是为什么理解对象如何运作是理解整个JavaScript的关键。    ### 3.1定义属性    两种创建自己的对象的方式:    使用Object构造函数或使用对象的字面形式。    ````javascript  var person1 = {  name: “Nicholas”  };    var person2 = new 0bject();  person2.name = "Nicholas“;  person1.age = "Redacted“;  person2.age = "Redacted”;  person1.name = "Greg";  person2.name = "Michael";    ````    当一个属性第一次被添加给对象时，JavaScript在对象上调用一个名为[[Put]]的内部方法。[[Put]]方法会在对象上创建一个新节点来保存属性， 就像第一次在哈希表上添加一个键一样。 这个操作不仅指定了初始的值， 也定义了属性的一些特征。 所以在前例中， 当属性name和 age在每个对象上第一次被定义时， [[Put]]方法都在该对  象上被调用了。    调用[[Put]]的结果是在对象上创建了一个**自有属性**。 一个自有属性表明仅仅该指定的对象实例拥有该属性。 该属性被直接保存在实例内, 对该属性的所有操作都必须通过该对象进行。    当一个已有的属性被赋予一个新值时， 调用的是一个名为[[Set]]的方法。 该方法将属性的当前值替换为新值。 上例为 name 设置第二个值时， 调用了[[Set]]方法。 下图分步显示了 person1 的 name和 age属性被改变时内部的变化。    图的第一部分显示了用对象字面形式创建的对象pemonl，它在属性name 上隐式调用了 [[Put]]对person1.age 的赋值是在属性 age上调用了 [[Put]]> 而给 person1.name 设置新值 “Greg” 则是在居性name上调用了[[Set]]， 覆盖了已有的属性值。    ![](http://p8xb02d0d.bkt.clouddn.com/18-7-7/63121700.jpg)    ### 3.2属性探测    属性可以任意时间添加，有时候需要检查对象是否已有一个属性。JavaScript开发新手错误地使用以下模式检测属性是否存在。    ```JavaScript  if(person.age){      // do something with ag  }  ```    上面的问题在于JavaScript的类型强制会影响该模式的输出结果。 当if判断中的值如下时，会判断为**真**：    - 对象  - 非空字符串  - 非零  - true    当if判断中的值如下时，会判断为**假**：    - null  - undefined  - 0  - false  - NaN  - 空字符串    当person1.age为0时，属性存在，但是if条件不满足。    因此判断属性是否存在的方法是使用 `in` 操作符。 `in` 操作符会检查**自有属性和原型属性**。仅仅检查自有属性时，可以使用 所有的对象都拥有的 `hasOwnProperty()` 方法（其实是 `Object.prototype` 原型对象的），该方法在给定的属性存在且为**自有属性**时返回 `true`。    ```JavaScript  var person = {      name: "Nicholas"  }    console.log("name" in person); // true  console.log(person.hasOwnpropert("name")); // true    console.log("toString" in person); // true  console.log(person.hasOwnproperty("toString")); // false  ```    ### 3.3删除属性    设置一个属性的值为 `null` 并不能从对象中彻底移除那个属性，这只是调用 `[[Set]]` 将 `null` 值替换了该属性原来的值而已。    彻底删除使用 `delete` 操作符，针对单个对象属性调用名为 `[[Delete]]` 的内部方法。该操作在哈希表中移除了一个键值对。删除成功时，返回 `true`（某些属性无法移除）。    ```JavaScript  var person = {      name: "Nicholas"  }    person.name = null;  console.log("name" in person); // true  delete person.name;  console.log(person.name); // undefined 访问一个不存在的属性将返回 undefined  console.log("name" in person); // false  ```    ### 3.4属性枚举    人为添加的属性默认都是可枚举的。可枚举的内部特征 `[[Enumerable]]` 都被设置为 `true`。 `for-in` 循环会枚举一个对象所有的可枚举属性，并将属性名赋值给一个变量。    > 在Chrome中，对象属性会按ASCII表排序，而不是定义时的顺序。    ECMAScript 5 的 Object.key() 方法可以获取可枚举属性的名字的数组。    ```javascript  var person = {      name: "Ljc",      age: 18  }    Object.keys(person); // ["name", "age"];  ```    `for-in` 与 `Object.keys()` 的一个区别是：前者也会遍历原型属性，而后者只返回自有(实例)属性。    实际上，对象的大部分原生方法的 `[[Enumerable]]` 特征都被设置为 `false`。可用 `propertyIsEnumerable()` 方法检查一个属性是否为可枚举的。    ```javascript  var arr = ["abc", 2];  console.log(arr.propertyIsEnumerable("length")); // false  ```    ### 3.5属性类型    属性有两种类型：**数据属性**和**访问器属性**。 数据属性包含一个值。`[[Put]]` 方法的默认行为是创建**数据属性**。 访问器属性不包含值而是定义了一个当属性被读取时调用的函数（称为`getter`）和一个当属性被写入时调用的函数（称为`setter`）。访问器属性仅需要 `getter` 或 `setter` 两者中的任意一个，当然也可以两者。    ```javascript  // 对象字面形式中定义访问器属性有特殊的语法：  var person = {      _name: "Nicholas",            get name(){          console.log("Reading name");          return this._name;      },      set name(value){          console.log("Setting name to %s", value);          this._name = value;      }  };    console.log(person.name); // "Reading name" 然后输出 "Nicholas"    person.name = "Greg";  console.log(person.name); // "Setting name to Greg" 然后输出 "Greg"  ```    > 前置下划线_ 是一个约定俗成的命名规范，表示该属性是私有的，实际上它还是公开的。    访问器就是定义了我们在对象读取或设置属性时，触发的动作（函数），`_name` 相当于一个内部变量。    getter被期望返回一个值，而setter则接受一个需要被赋值给属性的值作为参数。     当你希望赋值操作会触发一些行为或者读取的值需要通过计算所需的返回值得到，访问器就会非常有用。    > 当只定义getter或setter其一时，该属性就会变成只读或只写。    ### 3.6属性特质    在ECMAScript 5 之前没有办法指定一个属性是否可枚举。实际上无法访问属性的任何内部特征。为了改变这点，ECMAScript 5引入了多种方法来和属性特征值直接互动。 可以创建出和内建属性一样的自定义属性。    #### 3.6.1通用特征    数据属性和访问器属性均有以下两个属性特征： `[[Enumerable]]` 决定了能否遍历该属性； `[[Configurable]]` 决定了该属性是否可配置。     可以用delete删除可配置属性，或者更改，甚至更改属性类型。    所有自定义的属性默认都是可枚举、可配置的。    可以用 `Object.defineProperty()` 方法改变属性特征。 接受三个参数：拥有该属性的对象、属性名和包含需要设置的特性的属性描述对象。     属性描述对象具有和内部特征同名的属性但名字中不包含中括号。可以用enumerable属性来设置 [[Enumerable]]特征,用configurable属性来设置[[Configurable]]特征。例如,假设你想要让一个对象属性变成不可枚举且不可配置,方法如下。    ```javascript  var person = {      name: "Nicholas"  }  Object.defineProperty(person, "name", {      enumerable: false  })    console.log("name" in person); // true  console.log(person.propertyIsEnumerable("name")); // false    var properties = Object.keys(person);  console.log(properties.length); // 0    Object.defineProperty(person, "name",{      configurable: false  })    delete person.name; // false  console.log("name" in person); // true    Object.defineProperty(person, "name",{ // error!   // chrome：Uncaught TypeError: Cannot redefine property: name      configurable: true  })  ```    首先定义了name属性,然后设置它的[[Enumerable]] , 特征为false。基于这个新值的propertylsEnumerable()方法将返回false。之后name被改为不可配置。从现在起,由于该属性不能被改变,试图删除name将会失败,所以name依然存在于personl中。对name再次调用Object.defineProperty()也不会改变属性。    personl 1对象的属性name被有效地锁定。最后几行代码试图重新定义name为可配置的。然而这将抛出错误。无法将一个不可配置的属性变成可配置。同样,在不可配置的情况下试图将数据属性变为访问器属性或反向变更也会抛出错误。    ### 3.6.2数据属性特质    数据属性额外拥有两个访问器属性不具备的特质。    1.  [[Value]],包含属性的值。在对象上创建属性时该特征被自动赋值。所有的属性的值都保存在[[Value]]中,哪怕该值是一个函数。    2. [[Writable]],该特征是一个布尔值,指示该属性是否可以写入。所有的属性默认都是可写的,除非另外指定。    通过这两个额外特征,可以使用Object.defineProperty()完整定义一个数据属性,即使该属性还不存在。    ````javascript  var person1= {      name："Nicholas"  };  ````    ````javascript  var person1 ={};  object.defineProperty (person1, "name", {       value: "Nicholas",      enumerable: true,       configurable: true,       writable: true   });  ````    以上代码效果相同，当Object.defineProperty()被调用时,它首先检查属性是否存在。, 如果不存在,将根据属性描述对象指定的特征创建。    用Object.defineProperty()定义新的属性时一定记得为**所有的特征指定一个值**,否则布尔型的特征会被默认设置为`false`。    ````javascript  var person1 ={};  object.defineProperty (person1, "name", {       value: "Nicholas"   });  ````    上例name属性不可枚举、不可配置、不可写，除读取name属性值，其他任何操作均被锁定    注意事项：除enumerable，其余打印出来显示undefined，其实值是false    ````JavaScript  var descriptor = Object.getOwnPropertyDescriptor(person1, "name");  console.log(descriptor.enumerable); // false  console.log(descriptor.configuable); // undefined  console.log(descriptor.value); // "Nicholas"  console.log(descriptor.wirtable); // undefined  ````        #### 3.6.3 访问器属性特征    访问器属性额外拥有两个特征。`[[Get]]` 和 `[[Set]]`，内含 `getter` 和 `setter` 函数。     使用访问其属性特征比使用对象字面形式定义访问器属性的优势在于：可以为已有的对象定义这些属性。而后者只能在创建时定义访问器属性。    和数据属性一样，可指定是否为可配置、可枚举。    ```javascript  var person = {      _name: "Nicholas"  };    Object.defineProperty(person, "name", {      get: function(){          return this._name;      },      set: function(value){          this._name = value;      },      enumerable: true,      configurable: true  })    for(var x in person){      console.log(x); // _name \\n(换行) name（访问器属性）  }  ```    设置一个不可配置、不可枚举、不可以写的属性：    ```javascript  Object.defineProperty(person, "name",{      get: function(){          return this._name;      }  })  ```    对于一个新的访问器属性，没有显示设置值为布尔值的属性，默认为 `false`。    #### 3.6.4 定义多重属性    `Object.defineProperties()` 方法可以定义一个对象任意数量的属性，甚至可以同时改变已有的属性并创建新属性。    ```javascript  var person = {};    Object.defineProperties(person, {            // data property to store data      _name: {          value: "Nicholas",          enumerable: true,          configurable: true,          writable: true      },            // accessor property      name: {          get: function(){              return this._name;          },          set: function(value){              this._name = value;          },          enumerable: true,          configurable: true,      }  })  ```    #### 3.6.5 获取属性特征    获取属性特质`Object.getOwnPropertyDescriptor()` 方法。    该方法接受两个参数：对象和属性名。如果属性存在，它会返回一个属性描述对象，内含`4`个属性：`configurable` 和 `enumerable`，另外两个属性则根据属性类型决定。    ```javascript  var person = {      name: "Nicholas"  }    var descriptor = Object.getOwnPropertyDescriptor(person, "name");    console.log(descriptor.enumerable); // true  console.log(descriptor.configuable); // Firefox：true     Chrome，edge，ie：undefined  console.log(descriptor.value); // "Nicholas"  console.log(descriptor.wirtable); //Firefox：true         Chrome，edge，ie：undefined  ```    ### 3.7 禁止修改对象    对象和属性一样具有指导其行为的内部特性。其中， `[[Extensible]]` 是布尔值，指明该对象本身是否可以被修改。默认是 `true`。当值为 `false` 时，就能禁止新属性的添加。    下列三种方法可以锁定对象属性。    #### 3.7.1 禁止扩展    `Object.preventExtensions()` 创建一个不可扩展的对象（即**不能添加新属性**）。 可以用`Object.isExtensible()` 检查 `[[Extensible]]` 的值。    ```javascript  var person1 ={      name: "Nicholas"   };  console.log (object.isExtensible(person1));//true    Object.preventExtensions (person1);  console.log(Object.isExtensible(person1));// false    person1.sayName = function() {       console.log(this.name);  };    console.log("sayName" in person1);// false  ```    创建person1后,这段代码先检查其[[Extensible]]特征,然后将其变得不可扩展。由于不可扩展, sayName()方法永远无法被加到personl上。    > 注意：在严格模式下试图给一个不可扩展对象添加属性会抛出错误,而在非严格模式下则会失败。应该对不可扩展对象使用严格模式,这样, 当一个不可扩展对象被错误使用时你就会知道。    #### 3.7.2 对象封印    一个被封印的对象是不可扩展的且其所有属性都是不可配置的（不能添加、删除属性或修改其属性类型（从数据属性变成访问器属性或相反）），**只能读写它的属性**。    可以用 Object.seal()。调用此方法后，该对象的 `[[Extensible]]` 特征被设置为 `false`，其所有属性的 `[[configurable]]` 特征被设置为 `false`。    可以用 `Object.isSealed()` 判断一个对象是否被封印。    如果你熟悉Java或C++语言,你也应该熟悉被封印对象。当你基于这两种语言的类创建对象时,无法给对象添加新的属性,但可, ,以修改该属性的值。实际上,**封印对象就是JavaScript在没有类的\'情况下允许你做同样的控制**。    > 确保对被封印对象使用严格模式,这样当有人误用该对象时,你会得到一个错误。    #### 3.7.3 对象冻结    创建不可扩展对象的最后一种方法是冻结它。如果一个对象被冻结,则不能在其上添加或删除属性,不能改变属性类型,也不能写入 ,任何数据属性。简而言之,**被冻结对象是一个数据属性都为只读的被封印对象**。**被冻结对象无法解冻**。    可以用Object.freeze()来冻结一个对象,用Object.isFrozen()来判断一个对象是否被冻结。     ### 3.8 总结    1. 将属性视为键值对,对象视为属性的哈希表有助于理解 JavaScript对象。       - 使用点号或中括号访问对象的属性。     - 可以随时用赋值的方式添加新属性,也可以在任何时候用delete操作符删除一个属性。     - 用in操作符检查对象中某个属性是否存在。     - 如果是自有属性,可以用hasOwnProperty(0),这个方法存在于所有对象中。     - 所有对象属性默认都是可枚举的,这意味着它们会出现在for-in循环中或者被Object.keys()获取。    2. 属性有两种类型:数据属性和访问器属性。       - 数据属性保存值,你可以读写它们。     - 当数据属性保存了一个函数的值,该属性被认为 , 是对象的一个方法。     - 不同于数据属性,访问器属性不保存值;它们用getter和setter来进行指定的操作。     - 可以用对象字面形式创建数据属性和访问器属性。    3. 所有属性都有一些相关特征。这些特征定义了属性的工作模式。       - 数据属性和访问器属性都具有[[Enumerable]]和[1Configurable]]特征。     - 数据属性还具有[[Writable]]和[[Value]]特征。     - 访问器属性则具有[[Get]]和[[Set]]特征。     - [[Enumerable]]和[[Configurable]]默认对所有属性置为true, [[Writable]]默认对数据属性置为true。     - 你可以用 Object.defineProperty()或Object.defineProperties()改变这些特征,用 Object.getOwnPropertyDescriptor()获取它们。    4. 有3种方式可以锁定对象的属性。       - Object.prevent Extensions()方法创建不可扩展的对象,无法在其上添加新的属性。     -  Object.seal()方法创建被封印对象,它不可扩展且其属性不可配置。     -  Object.freeze()方法创建被冻结对象,它同时是一个被封印对象且其数据属性不可写。     - 你要当心这些不可扩展对象并始终对它们使用严格模式,这样任何对其错误的使用都会抛出一个错误。           ## 4.构造函数和原型对象    由于JavaScript缺乏类,它用构造函数和原型对象来给对象带来与类相似的功能。但是,这些相似的功能并不一定 "表现的跟类完全一致。在本章中,你会详细看到JavaScript如何使用构造函数和原型对象来创建对象。    ### 4.1构造函数    构造函数就是用new创建对象时调用的函数。例如, Object、Array和Function。    使用构造函数的好处在于所有用 **同一个构造函数创建的对象都具有同样的属性和方法**。如果想创建多个相同的对象,你可以创建自己的构造函数以及引用类型。构造函数也是函数,你会用同样的方法定义它。唯一的区别是构造函数名应该首字母大写,以此区分于其他函数。下例定义了一个空的Person函数。    ````javascript  function Person() {       //intentionally empty  }  ````    以上就是构造函数。构造函数和其他函数并没有绝对的语法上的区别。唯一的线索是首字母大写。定义好构造函数以后,就可以用它来创建对象,例如下面两个Person对象。    ````javascript  var person1 = new Person();  var person2 = new Person();  ````    如果没有需要传递的参数，可以忽略小括号。    personl和 person2成为Person类型的实例。new操作符会自动创建给定类型的对象并返回它们。    可以用 instanceof操作符获取对象的类型。如下所示。    ````javascript  console.log (person1 instanceof Person); //true  ````    也可以用构造函数属性来检查一个对象的类型。**每个对象在创建时都自动拥有一个构造函数属性,其中包含了一个指向其构造函数的引用**。那些通过对象字面形式或Object构造函数创建出来的泛用对象,其构造函数属性指向Object;而通过自定义构造函数创建出来的对象,其构造函数属性指向创建它的构造函数。    使用构造函数可以轻松创建许多拥有相同属性和方法的对象。只需要在构造函数内简单地给this添加任何想要的属性即可,如下例。    ````javascript  function Person (name) {      this.name = name;      this.sayName= function() {           console.log(this.name);      };  }  ````    Person构造函数接受一个命名参数name并将其赋给 this对象的name属性。    同时,构造函数还给对象添加了一个 sayName()方法。当调用构造函数时, new会自动创建this对象, ,且其类型就是构造函数的类型。构造函数本身不需要返回一个值, new操作符会帮你返回。现在可以使用Person构造函数来创建具有初始name属性的对象。    ````javascript  var person1 = new Person ("Nicholas");  var person2 = new Person ("Greg");  console. log (person1.name);//"Nicholas"  console.log (person2.name);// "Greg"    person1.sayName();//  "Nicholas"   person2.sayName();//  "Greg"  ````    > 你可以在构造函数中显式调用return。如果返回的值是一个对,象,它会代替新创建的对象实例返回。如果返回的值是一个原始类型，它会被忽略，新创建的对象实例会被返回。    构造函数可以用一致的方式初始化一个类型的实例,在使用 对象前设置好所有的属性。如下例,可以在构造函数中用Object.defineProperty()方法来初始化。    ````javascript  function Person (name) {      Object.defineProperty(this, "name", {          get: function() {               return name;          },          set: function (newName) {               name= newName;          },          enumerable: true,           configurable: true       });      this.sayName = function() {           console.log(this.name);      };  }  ````    Person构造函数中, name属性是一个访问者属性,利用name参数来存取实际的值。之所以能这样做,是因为命名参数就相当于一个本地变量。    始终确保用new调用构造函数;否则,会冒改变全局对象的风险,而不是创建一个新的对象。考虑如下代码中发生了什么。    ````javascript  var person1 = Person ("Nicholas");         //note: missing "new"  console.log (person1 instanceof Person);  // false   console.log(typeof person1);              //undefined"  console.log(name);                     // "Nicholas"  ````    当Person不是被 new 调用时，构造函数中的 this 对象等于全局 this 对象。     > 在严格模式下,不通过new调用Person构造函数时会出现 ,错误。这是因为严格模式并没有为全局对象设置this, this保持为 undefined,而当试图为undefined添加属性时都会出错。    构造函数允许你给对象配置同样的属性,但是**构造函数并没有消除代码冗余**。在之前的例子中，每一个对象都有自己的sayName()方法。这意味着如果你有100个对象实例,你就有100个函数做相同的事情,只是使用的数据不同。如果**所有的对象实例共享同一个方法会更有效率**,该方法可以使用this.name访问正确的数据,这就需要用到原型对象。    ### 4.2原型对象    可以把原型对象看作是对象的基类。几乎所有的函数(除了一些内建函数)都有一个名为 prototype的属性,该属性是一个原型对象用来创建新的对象实例。所有创建的对象实例共享该原型对象,且这些对象实例可以访问原型对象的属性。例如, hasOwnProperty()方法被定义在泛用对象Object的原型对象中,但却可以被任何对象当作自己的属性访问,如下例。    ````javascript  var book ={      title: "The Principles of Object-oriented JavaScript"  };  console.log("title" in book);                                //true     console.log(book.hasOwnProperty("title"));                   //true  console.log("hasOwnProperty" in book);                       //true  console.log(book.hasOwnProperty ("hasownProperty"));           //false  console.log(Object.prototype.hasOwnProperty("hasOwnProperty"));//true  ````    book.hasOwnProperty()方法存在于Object.prototype中。in操作符对原型属性和自有属性都返回true.    鉴别原型属性：    ````javascript  function hasPrototypeProperty(object, name){      return name in object && !object.hasOwnProperty(name);  }  ````    #### 4.2.1 [[Prototype]] 属性    一个对象实例通过内部属性[[Prototype]]跟踪其原型对象。该属性是一个指向该实例使用的原型对象的指针。用new创建一个新的对象时,构造函数的原型对象会被赋给该对象的[[Prototype]]属性。图4-1显示了[[Prototype]]属性是如何让多个对象实例引用同一个原型对象来减少重复代码的。    ![](http://p8xb02d0d.bkt.clouddn.com/18-7-8/74366479.jpg)    可以调用对象的Object.getPrototypeOf()方法读取[[Prototype]]属性的值。下例代码检查一个泛用空对象的[[Prototype]]属性。    ````javascript  var object = {};  var prototype = object.getPrototypeof(object);  console.log(prototype === Object.prototype); // true  ````    任何一个泛用对象,其[[Prototype]]属性始终指向 Object.prototype。    > 大部分JavaScript引擎在所有对象上都支持一个名为 `__proto__` 的属性。该属性使你可以直接**读写 [[Prototype]] 属性**。     可以用isPrototypeOf()方法检查某个对象是否是另一个对象的原型对象,该方法被包含在所有对象中。    ````javascript  var object = {};  console.log(Object.prototype.isPrototypeOf (object)); // true  ````    因为object是一个泛用对象,原型是Object.prototype,意味着本例中的isPrototypeOf()方法应当返回true。    当读取一个对象的属性时, JavaScript引擎首先在该对象的自有属性中查找属性名字。如果找到则返回。如果自有属性中不包含该名字,则JavaScript会搜索[[Prototype]]中的对象。如果找到则返回。如果找不到,则返回undefined.    ````javascript  var obj = new Object();  console.log(obj.toString()); // "[object Object]"    obj.toString = function(){      return "[object Custom]";  }  console.log(obj.toString()); // "[object Custom]"  // 删除自有属性  delete obj.toString;   console.log(obj.toString()); // "[object Object]"  // 无效，delete不能删除一个对象从原型继承而来的属性  delete obj.toString;   console.log(obj.toString()); //  "[object Object]"  ````    本例最初的toString()方法来自原型对象,默认返回“[object Object]"。如果你定义一个名叫toString()的自有属性,那么每次调用该对象toString()方法都会调用该自有属性。自有属性会覆盖原型 属性。仅当自有属性被删除时,原型属性才会再一次被使用。delete操作符仅对自有属性起作用,你无法删除一个对象的原型属性。图 4-2对本例做了很好的解释。    同时也揭示了一个重要概念:**无法给一个对象的原型属性赋值**。,如你在图4-2中所见,对toString的赋值在对象上创建了一个新的自有属性,而不是改变原型属性。    > MDN：delete 操作符不能删除的属性有：  >  > ①显式声明的全局变量不能被删除,该属性不可配置（not configurable）；  >  >  ②内置对象的内置属性不能被删除；  >  > ③不能删除一个对象从原型继承而来的属性(不过可以从原型上直接删掉它)。     ![](http://p8xb02d0d.bkt.clouddn.com/18-7-8/9054367.jpg)    #### 4.2.2 在构造函数中使用原型对象    原型对象的共享机制使得它们成为一次性为所有对象定义方法一的理想手段。将方法放在原型对象中并用this访问当前实例是更有效的做法。    下例展现了新Person构造函数。    ````javascript  function Person(name) {       this.name = name;}  Person.prototype.sayName = function() {      console.log (this.name);  };  var person1 = new Person ( "Nicholas");  var person2 = new Person ("Greg");    console.log(person1.name);// "Nicholas"  console.log(person2.name); // "Greg"    person1.sayName(); // "Nicholas"  person2.sayName(); // "Greg"  ````    在这个版本的Person构造函数中, sayName()被定义在原型对象上而不是构造函数中。创建出的对象和本章之前的例子中创建的对象别无二致,只不过sayName()现在是一个原型属性而不是自有属性。在person1和person2调用sayName()时,相对的this的值被分别赋上person1或person2.    也可以在原型对象上存储其他类型的数据,但在存储引用值时需要注意。因为这些引用值会被多个实例共享,可能大家不希望一个实例能够改变另一个实例的值。    下例显示当你不注意你的引用值实际指向哪里时会发生的情况。    ````javascript  function Person(name){  \tthis.name = name  }    Person.prototype.sayName = function(){  \tconsole.log(this.name);  }  Person.prototype.favorites= [];    var person1 = new Person ("Nicholas");  var person2 = new Person ("Greg");    person1.favorites.push("pizza");  person2.favorites.push("quinoa");    console.log (person1.favorites);// "pizza, quinoa"  console.log(person2.favorites);//"pizza. quinoa"  ````    favorites属性被定义在原型对象上,意味着person1.favorites和 person2.favorites指向同一个数组。对任一Person对象的favorites插入的值都将成为原型对象上数组的元素。但这可能不是你期望的 行为,所以在原型对象上定义时你需要非常小心。    虽然你可以在原型对象上一一添加属性,但是很多开发者会使用一种更简洁的方式:直接用一个对象字面形式替换原型对象如下。    ```javascript  function Person(name){      this.name  }    Person.prototype = {      sayName: function(){          console.log(this.name);      },      toString: function(){          return "[Person " + this.name + "]";      }  }  ```    这种方式有一个副作用    ````javascript  var person1 = new Person ( "Nicholas");  console.log (person1 instanceof Person); // true   console.log (person1.constructor === Person); // false   console.log(person1.constructor === Object); // true  ````    使用对象字面形式改写原型对象改变了构造函数的属性,因此它现在指向Object而不是Person。这是因为原型对象具有一个 constructor属性,这是其他对象实例所没有的。当一个函数被创建时, ,它的 prototype属性也被创建,且该原型对象的constructor属性指向该函数。当使用对象字面形式改写原型对象Person.prototype时,其 constructor属性将被置为泛用对象Object,为了避免这一点,需要在改写原型对象时手动重置其constructor属性,如下。    ````javascript  function Person(name){      this.name  }    Person.prototype = {      constructor: Person,        sayName: function(){          console.log(this.name);      },      toString: function(){          return "[Person ]" + this.name + "]";      }  };  var person1 = new Person ("Nicholas");  var person2 = new Person("Greg");    console.log (person1 instanceof Person);// true .   console.log (person1.constructor === Person); // true   console.log (person1.constructor === Object); // false  console.log(person2 instanceof Person); //true   console.log (person2.constructor === Person); // true   console.log(person2.constructor === Object); // false  ````    本例显式指定了原型对象的constructor属性。为了不忘记赋值,最好把它设为原型对象的第一个属性。    构造函数、原型对象和对象实例之间的关系最有趣的一个方面 ,也许就是对象实例和构造函数之间没有直接联系。不过对象实例和原型对象以及原型对象和构造函数之间都有直接联系。图4-3描述了这个关系。    ![](http://p8xb02d0d.bkt.clouddn.com/18-7-9/54663476.jpg)    这样的连接关系意味着,如果打断对象实例和原型对象之间的 ,联系,那么也将打断对象实例和其构造函数的联系。    #### 4.2.3改变原型对象    给定类型的所有对象实例共享一个原型对象,所以可以一次性扩充所有对象实例。 [[Prototype]]属性只是包含了一个指向原型对象的指针,**任何对原型对象的改变都立即反映到所有引用它的对象实例**上。这意味着你给原型对象添加的新成员都可以立即被所有已经存在的对象实例使用。    可以随时改变原型对象的能力在封印对象和冻结对象上有一个十分有趣的后果。当你在一个对象上使用Object.seal()或  Object.freeze()时,完全是在操作对象的自有属性。你无法添加自有属性或改变冻结对象的自有属性,但仍然可以通过在原型对象上添加属性来扩展这些对象实例。    #### 4.2.4内建对象的原型对象    原型对象也允许改变JavaScript引擎的标准内建对象。所有内建对象都有构造函数，因此也都有原型对象改变。例如,在所有数组上添加一个新的方法只需要简单地修改Array.prototype即可。    ````javascript  Array.prototype.sum= function() {      return this. reduce(function (previous, current) {           return previous + current;      });  };  var numbers = [ 1, 2, 3, 4, 5, 6];  var result = numbers.sum();  console.log(result);               //21  ````    这个例子在Array.prototype上创建了一个名为sum()的方法,该方法对数组的所有元素求和并返回。numbers数组通过原型对象自动拥有了这个方法。在sum()内部, this指向数组的对象实例numbers,于是该方法也可以自由使用数组的其他方法,比如reduce()。    字符串、数字和布尔类型都有内建的原始封装类型来帮助我们像使用普通对象一样使用它们。如果改变原始封装类型的原型对象,就可以给这些原始值添加更多的功能。    > 修改内建对象来试验各种功能是既有趣又好玩的事,但在生产环境中这么做可不是一个好主意。开发者们都期望一个内建对象具有一定的方法并表现出一定的行为。故意改变内建对象会破坏这种期望并导致其他开发者无法确定这些对象会如何工作。    ### 4.3总结    1. 构造函数就是用new操作符调用的普通函数。可以随时定义自己的构造函数来创建多个具有同样属性的对象。可以用 instanceof操作符或直接访问constructor属性来鉴别对象是被哪个构造函数创建的。  2. 每一个函数都具有prototype属性,它定义了该构造函数创建的所有对象共享的属性。通常,共享的方法和原始值属性被定义在原型对象里,而其他属性都定义在构造函数里。constructor属性实际上被定义在原型对象里供所有对象实例共享。  3. 原型对象被保存在对象实例内部的[[Prototypel1属性中。这个属性是一个引用而不是一个副本。由于JavaScript查找属性的机制,你对原型对象的修改都立刻出现在所有对象实例中。当你试图访问一个对象的某个属性时, JavaScript首先在自有属性里查找该名字,如果在自有属性中没有找到则查找原型属性。这样的机制意味着原型对象可以随时改变而引用它的对象实例则立即反映出这些改变。  4. 内建对象也有可以被修改的原型对象。虽然不建议在生产环境,中这么做,但它们可以被用来做实验以及验证新功能。    ## 5.继承    学习如何创建对象是理解面向对象编程的第一步。第二步是理解继承。在传统面向对象语言中,类从其他类继承属性。然而**在 JavaScript中,继承可以发生在没有类的继承关系的对象之间。这种继承的机制就是原型对象**。    ### 5.1原型对象和Object.prototype    JavaScript内建的继承方法被称为原型对象链,又可称为原型对象继承。原型对象的属性可经由对象实例访问, , 这就是继承的一种形式。对象实例继承了原型对象的属性。因为原型对象也是一个对象,它也有自己的原型对象并继承其属性。这就是原型对象链:对象继承其原型对象,而原型对象继承它的原型对象，依此类推。    所有的对象,包括那些你自己定义的对象都自动继承自Object,除非你另有指定(本章后续会讨论到)。更确切地说,所有对象都继承自Object.prototype。任何以对象字面形式定义的对象,其[[Prototype]]的值都被设为Object.prototype,这意味着它继承Object.prototype的属性,如下例中的book。    ````javascript  var book ={       title: "The Principles of object-oriented JavaScript"  };  var prototype = Object.getPrototypeOf (book);  console.log(prototype === Object.prototype); // true  ````    book的对象原型是Object.prototype。这里不需要多余的代码来 ,指定,因为这是创建新对象的默认行为。这个关系意味着book会自动接收来自Object.prototype的方法。    #### 5.1.1继承自Object.prototype的方法    1. hasOwnProperty() 检测是否存在一个给定名字的自有属性  2. propertyIsemumerable() 检查一个自有属性是否可枚举  3. isPrototypeOf 检查一个对象是否是另一个对象的原型对象  4. valueOf() 返回一个对象的值表达  5. toString() 返回一个对象的字符串表达    这 5 种方法经由继承出现在所有对象中。     #### 5.1.2修改Object.prototype    所有的对象都默认继承自Object.prototype,所以改变Object.. prototype会影响所有的对象,这是非常危险的。第4章告诫过你不要修改内建对象的原型对象,到了Object.prototype,这个告诫就要加倍。查看下面的代码会发生什么。    ````javascript  Object.prototype.add= function(value) {       return this + value;  };  var book ={      title: "The Principles of Object-Oriented JavaScript"  };  console.log(book.add(5));// "[object Object]5"   console.log("title".add ("end"));// "titleend"    // in a web browser  console. log (document.add (true));  // "[object HTMLDocument]true"   console.log(window.add(5));// "[obiect Window]5"  ````    添加Object.prototype.add)会导致所有的对象都有了一个add()方法,不管这样是不是合理。不仅仅给开发者,同时也给JavaScript委员会带来了问题:它不得不把新方法添加到各种不同的地方,因,为给Object.prototype添加方法可能会带来不可预知的结果。    这个问题的另一方面在于给Object.prototype添加可枚举属性。在之前的例子里, Object.prototype.add()是一个可枚举属性,这意味着它会出现在for-in循环中。    考虑到JavaScript中使用 for-in的频繁程度,为Object.prototype添加可枚举属性会影响大量代码。因为这个原因, Douglas Crockford推荐在for-in循环中始终使用hasOwnProperty(),如下。    ````javascript  var empty = {};  for(var property in empty) {      if (empty.hasOwnProperty(property)) {           console.log (property);      }  }  ````    不过这个方法虽然可以有效过滤那些不想要的原型对象的属性, ,但也同时限制了for-in循环,使其只能用于自有属性,这也许不是你想要的。对你来说,最灵活的做法还是不要修改Object.prototype。    ### 5.2对象继承    对象继承是最简单的继承类型。你唯一需要做的就是指定哪个对象是新对象的[[Prototype]]。对象字面形式会隐式指定Object.prototype为其[[Prototype]],你也可以用Object.create()方法显式指定。    Object.create()方法接受两个参数。    第一个参数是需要被设置为新对象的[[Prototype]]的对象。    第二个可选参数是一个属性描述对象,其格式如你在Object.defineProperties()中使用的一样(见第3章)。考虑下面的代码。    ````javascript  var obj = {      name: "The Principles of Object-oriented JavaScript"  };    // 等同于  var obj = Object.create(Object.prototype, {      name: {          value: "The Principles of Object-oriented JavaScript",          configurable: true,          enumberable: true,          writable: true      }  });  ````    两种声明具有相同的效果。    第一种声明使用对象字面形式来定义一个具有单一属性title的对象。该对象自动继承自Object prototype,且其属性被默认设置为可配置、可枚举和可写。    第二种 ,声明使用Object.create()显式做了同样的操作。两个book对象的行为完全一致。但你可能永远不会这样写出直接继承自Object.prototype的代码,毕竟那是默认行为。继承自其他对象则有趣多了,如下。    ````javascript  var person1 = {      name: "Nicholas",       sayName: function() {           console.log(this.name);      }  };  var person2 = Object.create(person1, {       name: {           configurable: true,           enumerable: true,           value: "Greg",           writable: true      }  });  person1. sayName();// outputs "Nicholas"  person2. sayName();// outputs "Greg"  console.log(person1.hasOwnProperty("sayName"));// true  console.log(person1.isPrototypeOf(person2)); // true  console.log(person2.hasOwnProperty("sayName")); // false  ````    这段代码创建了一个对象person1,具有一个name属性和一个 sayName()方法。对象person2继承自person1,也就继承了name和 sayName()。然而person2在通过Object.create()创建时还定义了一个自有属性name。该自有属性隐藏并代替了原型对象的同名属性。所以, person1.sayName()输出"Nicholas ",而person2.sayName()输出"Greg"。    请记住, sayName()依然只存在于personl并被person2继承。本例person2的继承链长于person1。对象person2继承自person1而person1继承自Object.prototype。如图5-1所示。    ![](http://p8xb02d0d.bkt.clouddn.com/18-7-9/94219659.jpg)    当访问一个对象的属性时, JavaScript引擎会执行一个搜索过程。如果在对象实例上发现该属性(就是说是个自有属性),该属性值就会被使用。如果对象实例上没有发现该属性,则搜索 [[Prototype]]。如果仍然没有发现,则继续搜索该原型对象的 [[Prototype]],直到继承链末端。末端通常是一个Object.prototype,其[[Prototype]]被置为null.    也可以通过Object.create()创建[[Prototype]]为null的对象,如下所示。    ````javascript  var nakedobject= Object.create (null);  console.log ("tostring" in nakedobject); // false   console.log("valueof" in nakedobject); // false  ````    本例中的nakedObject是一个没有原型对象链的对象。这意味着toString()和valueOf()等内建方法都不存在于该对象上。    实际上,**该对象完全就是一个没有任何预定义属性的白板**,这使得它成为一个完美的哈希容器,因为不会发生跟继承来的属性名字的冲突。除此之外这种对象也没有什么别的用处了,你不能把它当成一个其他继承自Object.prototype的对象一样使用。例如,无论何时当你对 nakedObject使用操作符时,你都会得到一个"Cannot convert object to primitive value."的错误。这只是一个有趣的JavaScript语言诡计,使你可以创建出一个没有原型对象的对象。    ### 5.3构造函数继承    JavaScript中的对象继承也是构造函数继承的基础。还记得第4章提到,几乎所有的函数都有prototype属性,它可以被修改或替换。该prototype属性被自动设置为一个新的继承自Object.prototype的泛用对象,该对象有一个自有属性constructor。实际上, JavaScript引擎为你做了下面的事情。    ````javascript  // 你的代码  function YourConstructor(){      // initialization  }    // JavaScript引擎在背后为你做的处理  YourConstructor.prototype = Object.create(Object.prototype, {      constructor: {          configurable: true,          enumerable: true,          value: YourConstructor,          writable: true      }  })  ````    由于 prototype 可写，你可以通过改变它来改变原型对象链。     ````javascript  function Rectangle(length, width){  \tthis.length = length;  \tthis.width = width  }    Rectangle.prototype.getArea = function(){  \treturn this.length * this.width  }    Rectangle.prototype.toString = function(){  \treturn "[Rectangle " + this.length + "x" + this.width + "]";  }      // inherits from Rectangle  function Square(size){  \tthis.length = size;  \tthis.width = size;  }    Square.prototype = new Rectangle(); // 尽管是 Square.prototype 是指向了 Rectangle 的对象实例，即Square的实例对象也能访问该实例的属性（如果你提前声明了该对象，且给该对象新增属性）。  // Square.prototype = Rectangle.prototype; // 这种实现没有上面这种好，因为Square.prototype 指向了 Rectangle.prototype，导致修改Square.prototype时，实际就是修改Rectangle.prototype。  console.log(Square.prototype.constructor); // 输出 Rectangle 构造函数    Square.prototype.constructor = Square; // 重置回 Square 构造函数  console.log(Square.prototype.constructor); // 输出 Square 构造函数    Square.prototype.toString = function(){  \treturn "[Square " + this.length + "x" + this.width + "]";  }    var rect = new Rectangle(5, 10);  var square = new Square(6);    console.log(rect.getArea()); // 50  console.log(square.getArea()); // 36    console.log(rect.toString()); // "[Rectangle 5 * 10]", 但如果是Square.prototype = Rectangle.prototype，则这里会"[Square 5 * 10]"  console.log(square.toString()); // "[Square 6 * 6]"    console.log(square instanceof Square); // true  console.log(square instanceof Rectangle); // true  console.log(square instanceof Object); // true  ````    这段代码里有两个构造函数: Rectangle和Square。    Square构造函数的prototype属性被改写为Rectangle的一个对象实例。此时不需要给Rectangle的调用提供参数,因为它们不需要被使用,而且如果提供了,那么所有的Square的对象实例都会共享同样的维度。用这种方式改变原型对象链时,你需要确保构造函数不会在参数缺失时抛出错误(很多构造函数包含的初始化逻辑会需要参数)且构造函数不会改变任何全局状态,比如追踪有多少对象实例被创建等。Square.prototype被改写后,其constructor属性会被重置为Square.    然后, rect作为Rectangle的对象实例被创建,而square则被作为Square的实例创建。两个对象都有getArea()方法,因为那继承自 Rectangle.prototype。 instanceof操作符认为变量square同时是Square、Rectangle和Object的对象实例。因为instanceof使用原型对象链检查对象类型。如图5-2所示。    ![](http://p8xb02d0d.bkt.clouddn.com/18-7-9/60734397.jpg)    Square.prototype并不真的需要被改写为一个Rectangle对象,毕竟Rectangle构造函数并没有真的为Square做什么必要的事情。事实上,唯一相关的部分是Square.prototype需要指向Rectangle.prototype,使得继承得以实现。这意味着你可以用Object.create()简化例子,代码如下。    ````javascript  // inherits from Rectangle  function Square(size){      this.length = size;      this.width = size;  }    Square.prototype= Object.create(Rectangle.prototype, {      constructor: {          configurable: true,          enumerable: true,          value: Square,          writable: true      }  });  Square.prototype.tostring= function() { return "[Square "+ this.length+ "x"+ this.width+ "]";  ````    在这个版本的代码中, Square.prototype被改写为一个新的继承自Rectangle.prototype的对象,而Rectangle构造函数没有被调用。这意味着,不再需要担心不加参数调用构造函数会导致的错误。,除此之外,这段代码和前面的代码行为完全一致。原型对象链完好无缺,所有的Square对象实例都继承自Rectangle.prototype且其 constructor属性也都在同样的地方被重置。    ## 5.4构造函数窃取    由于JavaScript中的继承是通过原型对象链来实现的,因此不需要调用对象的父类的构造函数。如果你确实需要在子类构造函数中调用父类构造函数,那你就需要利用JavaScript函数工作的特性。    call0)和apply()方法允许你在调用函数时提 , 供一个不同的this值。那正好是构造函数窃取的关键。只需要在子类的构造函数中用call()或者apply()调用父类的构造函数,并将新创建的对象传进去即可。实际上,就是用自己的对象窃取父类的构造函数,如下例。    ````javascript  function Rectangle(length, width){  \tthis.length = length;  \tthis.width = width  }    Rectangle.prototype.getArea = function(){  \treturn this.length * this.width  }    Rectangle.prototype.toString = function(){  \treturn "[Rectangle " + this.length + "x" + this.width + "]";  }    function Square(size){      Rectangle.call(this, size, size);           // optional: add new properties or override existing ones here  }  Square.prototype= Object.create (Rectangle.prototype, {       constructor: {           configurable: true,           enumerable: true,           value: Square,           writable: true      }  });  Square.prototype.tostring= function() {      return "[Square " + this.length+ "x" + this.width+ "]";  };  var square = new Square(6);  console.log(square.length); //6   console.log (square.width);// 6   console.log(square.getArea()); // 36  ````    Square构造函数调用了Rectangle构造函数,并传入了this和 size两次(一次作为length,另一次作为width)。这么做会在新对象上创建length和width属性并让它们等于size,这是一种避免在构造函数里重新定义你希望继承的属性的手段。你可以在调用完父类的构造函数后继续添加新属性或覆盖已有的属性。    这个分两步走的过程在你需要完成自定义类型之间的继承时比较有用。你经常需要修改一个构造函数的原型对象,你也经常需要在子类的构造函数中调用父类的构造函数。一般来说,需要修改 prototype来继承方法并用构造函数窃取来设置属性。由于这种做法模仿了那些基于类的语言的类继承,通常被称为伪类继承。    ### 5.5访问父类方法    在前面的例子中, Square类型有自己的toString()方法隐藏了其原型对象的toString()方法。子类提供新功能覆盖父类的方法十分常见,但如果你还想访问父类的方法该怎么办呢?在其他语言中,可以用super.toString(),但在JavaScript中没有类似的方式。代替的方法是在通过call()或apply()调用父类的原型对象的方法时传入一个子类的对象。如下例所示。    ````javascript  function Rectangle(length, width){  \tthis.length = length;  \tthis.width = width  }    Rectangle.prototype.getArea = function(){  \treturn this.length * this.width  }    Rectangle.prototype.toString = function(){  \treturn "[Rectangle " + this.length + "x" + this.width + "]";  }    // inherits from Rectangle   function Square(size) {      Rectangle.call(this, size, size);  }  Square.prototype= Object.create (Rectangle.prototype, {       constructor: {           configurable: true,           enumerable: true,           value: square,           writable: true      });// call the supertype method   Square.prototype.tostring= function() {       vartext = Rectangle.prototype.tostring.call(this);      return text.replace("Rectangle", "Square");  };  ````    在这个版本的代码中, Square.prototype.toString()通过call()调用 Rectangle.prototype.toString()。该方法只需在返回文本结果前用 "Square"替换"Rectangle",这种做法看上去可能有一点冗长,但这是唯一的访问父类方法的手段。    ## 5.6总结    1. JavaScript通过原型对象链支持继承。当将一个对象的[[Prototype]]设置为另一个对象时,就在这两个对象之间创建了一条原型对象链。所有的泛用对象都自动继承自Object.prototype。如果你想要创建个继承自其他对象的对象,你可以用Object.create()指定[[Prototype]]为一个新对象。  2. 可以在构造函数中创建原型对象链来完成自定义类型之间的继承。通过将构造函数的prototype属性设置为某一个对象,就建立了自定义类型对象和该对象的继承关系。构造函数的所有对象实例共享同一个原型对象,所以它们都继承自该对象。这个技术在继承其他对象的方法时工作得十分好,但你不能用原型对象继承自有属性。  3. 为了正确继承自有属性,可以使用构造函数窃取。只需以call()或apply()调用父类的构造函数,就可以在子类里完成各种初始化。结合构造函数窃取和原型对象链是JavaScript中最常见的继承手段。由于和基于类的继承相似,这个组合经常被称为 ,伪类继承。  4. 可以通过直接访问父类原型对象的方式访问父类的方法。当你这么做时,你必须以call()或apply()执行父类方法并传入一个子类的对象。    ## 6.对象模式    JavaScript有很多创建对象的模式,完成工作的方式也不只一种。可以随时定义自己的类型或自己的泛用对象。可以使用继承或混入等其他技术令对象间行为共享。也可以利用JavaScript高级 ,技巧来阻止对象结构被改变。下面讨论的模式赐予强大的管理和创建对象的能力,完全基于自己的用例。    ### 6.1私有成员和特权成员    JavaScript对象的所有属性都是公有的,且没有显式的方法指定,某个属性不能被外界某个对象访问。然而,有时你可能不希望数据公有。例如,当一个对象使用一个值来决定某种状态,在对象不知,情的情况下修改该值会让状态管理过程陷入混乱。一种避免它的方法是通过使用命名规则。例如,在不希望公有的属性名字前加上下划线(如this._name),还有很多其他方法不需要依赖命名规则,因此在阻止私有信息被修改方面也就更加“防弹”。    #### 6.1.1模块模式    模块模式是一种用于创建拥有私有数据的单件对象的模式    '},{title:"angular 核心概念： 组件、依赖注入、数据绑定",path:"/posts/component/angular%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html",strippedContent:" ### Angular 的概念模型    新版本的 Angular 的[核心概念](https://vsavkin.com/the-core-concepts-of-angular-2-c3d6cbe04d04#.7qmzqn2wd)是什么呢？    非常简单，一切都是围绕着“组件”（ Component ）的概念展开的：    ![enter image description here](http://images.gitbook.cn/e0c611d0-acb3-11e7-9ec8-4915d3122415)    - Component（组件）是整个框架的核心，也是终极目标。“组件化”的意义有2个：第一是分治，因为有了组件之后，我们可以把各种逻辑封装在组件内部，避免混在一起；第二是复用，封装成组件之后不仅可以在项目内部复用，而且可以沉淀下来跨项目复用。  - NgModule（模块）是组织业务代码的利器，按照你自己的业务场景，把组件、服务、路由打包到模块里面，形成一个个的积木块，然后再用这些积木块来搭建出高楼大厦。https://angular.cn/guide/ngmodules  - Router（路由）的角色也非常重要，它有3个重要的作用：第一是封装浏览器的 History 操作；第二是负责异步模块的加载；第三是管理组件的生命周期。    模块和路由是为了实现组件化，所以，Component、NgModule、Router 加起来会占据绝大部分篇幅。只要紧扣“组件化”这个主线，就能站在一个很高的角度统摄全局，从而掌握到这门框架的精髓。    \x3c!--more--\x3e     ### 架构特色    ####　1依赖注入    注射是通过constructor进行的    #### 2数据绑定    1. zone.js ： 时间回调、 定时器回调、 axjs回调、 运行时js对象改变三种情况，拦截即可    2. rxjs 异步及数据流         单向数据流：数据流从根组件流向子组件。    3. Immutable Data       [angular2 变更检测详解](http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html)    [Angular 2变更检测系统](https://vsavkin.com/change-detection-in-angular-2-4f216b855d4c)    - Angular 2应用程序是一个反应系统。  - 变化检测系统将绑定从根传播到叶子。  - 与Angular 1.x不同，更改检测图是有向树。结果，该系统更具性能和可预测性。  - 默认情况下，更改检测系统遍历整个树。但是如果使用不可变对象或可观察对象，只有当它们“真正改变”时，您才可以利用它们并检查树的某些部分。  - 这些优化构成并且不会破坏变更检测提供的保证。    [不同前端框架变更检测](http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html)    #### 命名约定    老版本使用 AngularJS 指代，所有新版本都叫做 Angular。原因很好理解，因为老版本是用 JS 开发的，所以带一个 JS 后缀，而新版本是基于 TypeScript 的，带 JS 后缀不合适。    #### 关于 TypeScript    TypeScript 可以非常有效地提升编码效率和程序可读性。    #### 关于版本号    根据官方的解释，Angular 从2.0之后会保证向下兼容，每隔半年会升级一个大版本，只有升级大版本的时候才会做一些 breaking change。    ### [VS code Debug Angular应用](http://www.ngfans.net/topic/17/post)        "},{title:"组件：生命周期钩子 angular、vue生命周期",path:"/posts/component/%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90.html",strippedContent:" - 什么是 UI 组件的生命周期？  - Angular 组件的生命周期有什么特别的地方？  - OnPush 策略的使用方式。  - 脏检查的实现原理。    ## UI 组件的生命周期    ![enter image description here](http://images.gitbook.cn/e4cf9d10-af2d-11e7-b111-4d6e630f480d)    无论使用什么样的前端框架，只要编写 UI 组件，生命周期都是必须要考虑的重要内容。请展开你的想象，如果让你来设计 UI 系统，组件有几个重要的阶段一定是绕不开的，比如：    - 初始化（ init ）阶段：在这个阶段你需要把组件 new 出来，把一些属性设置上去，等等这些操作。  - 渲染（ render ）阶段：在这个阶段需你要把组件的模板和数据结合起来，生成 HTML 标签结构，并且要整合到现有的 DOM 树里面去。  - 存活阶段：既然带有 UI，那么在组件的存活期内就一定会和用户进行交互。一般来说，带有 UI 的系统都是通过事件机制进行用户交互的。也就是说，这个阶段将会处理大量的用户事件：鼠标点击、键盘按键、手指触摸。  - 销毁（ destory ）阶段：最后，组件使用完了，需要把一些资源释放掉。最典型的操作：需要把组件上的所有事件全部清理干净，避免造成内存泄漏。    在组件生命的不同阶段，框架一般会暴露出一些“接口”，开发者可以利用这些接口来实现一些自己的业务逻辑。这种接口在有些框架里面叫做“事件”，在 Angular 里面叫做“钩子”，但其底层的本质都是一样的。    \x3c!--more--\x3e     ## Angular 组件生命周期钩子    ![enter image description here](http://images.gitbook.cn/f3fc8050-af2d-11e7-bdfa-890a7a50d411)    - Angular 一共暴露了8个“钩子”，构造函数不算。    - 并没有组件或者指令会实现全部钩子。    - 绿色的4个钩子可能会被执行很多次，紫色的只会执行一次。    - Content 和 View 相关的4个钩子只对组件有效，指令上不能使用。因为在新版本的 Angular 里面，指令不能带有 HTML 模板。指令没有自己的 UI，当然就没有 View 和 Content 相关的“钩子”了。    - 请不要在生命周期钩子里面实现复杂的业务逻辑，尤其是那4个会被反复执行的钩子，否则一定会造成界面卡顿。      ### 生命周期的顺序    当 Angular 使用构造函数新建一个组件或指令后，就会按下面的顺序在特定时刻调用这些生命周期钩子方法：    | 钩子                      | 用途及时机                                                   |  | ------------------------- | ------------------------------------------------------------ |  | `ngOnChanges()`           | 当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 `SimpleChanges` 对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在 `ngOnInit()` 之前。 |  | `ngOnInit()`              | 在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮 `ngOnChanges()` 完成之后调用，只调用**一次**。 |  | `ngDoCheck()`             | 检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。在每个 Angular 变更检测周期中调用，`ngOnChanges()` 和 `ngOnInit()`之后。 |  | `ngAfterContentInit()`    | 当把内容投影进组件之后调用。第一次 `ngDoCheck()` 之后调用，只调用一次。 |  | `ngAfterContentChecked()` | 每次完成被投影组件内容的变更检测之后调用。`ngAfterContentInit()` 和每次 `ngDoCheck()` 之后调用 |  | `ngAfterViewInit()`       | 初始化完组件视图及其子视图之后调用。第一次 `ngAfterContentChecked()` 之后调用，只调用一次。 |  | `ngAfterViewChecked()`    | 每次做完组件视图和子视图的变更检测之后调用。`ngAfterViewInit()` 和每次 `ngAfterContentChecked()` 之后调用。 |  | `ngOnDestroy()`           | 当 Angular 每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在 Angular 销毁指令/组件之前调用。 |                ### OnPush 策略    在真实的业务系统中，组件会构成 Tree 型结构，就像这样：    ![enter image description here](http://images.gitbook.cn/080f5b30-af2e-11e7-bdfa-890a7a50d411)    当某个叶子组件上的数据模型发生变化之后，就像这样：    ![enter image description here](http://images.gitbook.cn/2fbab0d0-af2e-11e7-a2ac-75e3e38b9209)    **这时候，Angular 将会从根组件开始，遍历整颗组件树，把所有组件上的 ngDoCheck() 方法都调用一遍：**    ![enter image description here](http://images.gitbook.cn/3fa12010-af2e-11e7-9203-4582e2e80f6b)    **请注意，默认情况下，无论哪个叶子组件上发生了变化，都会把整个组件树遍历一遍。**如果组件树非常庞大，嵌套非常深，很明显会有效率问题。在绝大部分时间里面，并不会出现每个组件都需要刷新的情况，根本没有必要每次都去全部遍历。所以 Angular 提供了一种叫做 OnPush 的策略，只要把某个组件上的检测策略设置为 OnPush，就可以忽略整个子树了，就像这样：    ![enter image description here](http://images.gitbook.cn/49c3bad0-af2e-11e7-b111-4d6e630f480d)    很明显，使用了 OnPush 策略之后，检查效率将会获得大幅度的提升，尤其在组件的数量非常多的情况下：        Angular 内置的两种变更检测策略：    - Default：无论哪个组件发生了变化，从根组件开始全局遍历，调用每个组件上的 ngDoCheck() 钩子。  - OnPush：只有当组件的 @Input 属性发生变化的时候才调用本组件的 ngDoCheck() 钩子。    有一些开发者建议 Angular 项目组把 OnPush 作为默认策略，但是目前还没有得到官方支持，或许在未来的某个版本里面会进行修改。    ### 了解一点点原理    如果你不想看到扯原理的内容，可以跳过这一小段。    ![enter image description here](http://images.gitbook.cn/881e4110-af2e-11e7-a2ac-75e3e38b9209)    大家都知道，AngularJS 是第一个把“双向数据绑定”这种设计带到前端领域来的框架，“双向数据绑定”最典型的场景就是对表单的处理。    双向数据绑定的目标很明确：数据模型发生变化之后，界面可以自动刷新；用户修改了界面上的内容之后，数据模型也会发生自动修改。    很明显，这里需要一种同步机制，在 Angular 里面这种同步机制叫做“变更检测”。    在老版本 AgnularJS 里面，变更检测机制实现得不太完善，经常会出现检测不到变更的情况，所以才有了让大家很厌烦的 $apply() 调用。    在新版本的 Angular 里面不再存在这个问题了，因为新版本的 Angular 使用 Zone.js 这个库，它会把所有可能导致数据模型发生变更的情况全部拦截掉，从而在数据发生变化的时候去通知 Angular 进行刷新。    有一些朋友可能会觉得奇怪，Zone.js 怎么这么牛叉？它内部到底是怎么玩的呢？    实际上要做到这一点并不复杂，因为在浏览器环境下，有可能导致数据模型发生变化的情况只有3种典型的回调：    - 事件回调：鼠标、键盘、触摸  - 定时器回调：setTimeout 和 setInterval  - Ajax 回调    Zone.js 覆盖了所有原生实现，当开发者在调用这些函数的时候，并不是调用的原生方法，而是调用的 Zone.js 自己的实现，所以 Zone.js 就可以做一些自己的处理了。    [Angular变更检测详解](https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html)    ## Vue组件生命周期钩子：    关于组件的生命周期，是时候放出这张图片了：        ![img](https://user-gold-cdn.xitu.io/2018/7/21/164bbf610b61f3cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)        这张图片已经讲得很清楚了，很多人这部分也很清楚了，大部分生命周期并不会用到，这里提一下几点：    1. **ajax请求最好放在created里面**，因为此时已经可以访问`this`了，请求到数据就可以直接放在`data`里面。       这里也碰到过几次，面试官问：ajax请求应该放在哪个生命周期。    2. **关于dom的操作要放在mounted里面**，在`mounted`前面访问dom会是`undefined`。    3. 每次进入/离开组件都要做一些事情，用什么钩子：    - 不缓存：      进入的时候可以用`created`和`mounted`钩子，离开的时候用`beforeDestory`和`destroyed`钩子,`beforeDestory`可以访问`this`，`destroyed`不可以访问`this`。    - 缓存了组件：      缓存了组件之后，再次进入组件不会触发`beforeCreate`、`created` 、`beforeMount`、 `mounted`，**如果你想每次进入组件都做一些事情的话，你可以放在activated进入缓存组件的钩子中**。      同理：离开缓存组件的时候，`beforeDestroy`和`destroyed`并不会触发，可以使用`deactivated`离开缓存组件的钩子来代替。    ------    ###  触发钩子的完整顺序：    将路由导航、`keep-alive`、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件：    1. `beforeRouteLeave`:路由组件的组件离开路由前钩子，可取消路由离开。  2. `beforeEach`: 路由全局前置守卫，可用于登录验证、全局路由loading等。  3. `beforeEnter`: 路由独享守卫  4. `beforeRouteEnter`: 路由组件的组件进入路由前钩子。  5. `beforeResolve`:[路由全局解析守卫](https://link.juejin.im?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fadvanced%2Fnavigation-guards.html%23%25E5%2585%25A8%25E5%25B1%2580%25E8%25A7%25A3%25E6%259E%2590%25E5%25AE%2588%25E5%258D%25AB)  6. `afterEach`:路由全局后置钩子  7. `beforeCreate`:组件生命周期，不能访问`this`。  8. `created`:组件生命周期，可以访问`this`，不能访问dom。  9. `beforeMount`:组件生命周期  10. `deactivated`: 离开缓存组件a，或者触发a的`beforeDestroy`和`destroyed`组件销毁钩子。  11. `mounted`:访问/操作dom。  12. `activated`:进入缓存组件，进入a的嵌套子组件(如果有的话)。  13. 执行beforeRouteEnter回调函数next。    "},{title:"基于类与原型的编程范式",path:"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",strippedContent:' ### 编程范式    编程范式的英语是 programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照“方法学”一词）。编程语言发展到今天，出现了好多不同的代码编写方式，但不同的方式解决的都是同一个问题 。    下面是一张编程范式的图        ![面向对象](http://p8xb02d0d.bkt.clouddn.com/18-7-26/31817390.jpg)        https://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.pdf    不过总体说来，我们可以简单地把这世界上纷乱的编程范式，分成这几类：声明式、命名式、逻辑的、函数式、面向对象的、面向过程的。     面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象[1][2]。    面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。        面向对象程序的特征：    #### 分享非面向对象程序前身语言    面向对象编程通常共享高阶编程语言的低级功能。可用于建构一个程序的基本工具包括：    - [变量](https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)) 能存储一些内置类型的信息如[整数](https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0)与[字符](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6)，也有些是[数据结构](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B)像是[字符串](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2)、[串列](https://zh.wikipedia.org/wiki/%E4%B8%B2%E5%88%97_(%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5))与[散列表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)等包含内置或复合的变量如指针。  - [程序](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F)：也称为函数、方法或例程，是指输入数据产生输出结果，现代语言还包含结构化编程结构如[程序循环](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%BF%B4%E5%9C%88)与[条件](https://zh.wikipedia.org/wiki/%E6%9D%A1%E4%BB%B6)。    #### 类与对象    支持面向对象编程语言通常利用继承其他类达到代码重用和可扩展性的特性。而类有两个主要的概念：    类（Class）：定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。  对象：是类的实例。  其中类（Class）定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。举例来说，“狗”这个类会包含狗的一切基础特征，即所有“狗”都共有的特征或行为，例如它的孕育、毛皮颜色和吠叫的能力。类可以为程序提供模版和结构。一个类的方法和属性被称为“成员”。 我们来看一段伪代码：    ````javascript  类狗  开始      公有成员:          吠叫():      私有成员:          毛皮颜色:          孕育:  结束  ````     在这串代码中，我们声明了一个类，这个类具有一些狗的基本特征。关于[公有成员](https://zh.wikipedia.org/w/index.php?title=%E5%85%AC%E6%9C%89%E6%88%90%E5%91%98&action=edit&redlink=1)和[私有成员](https://zh.wikipedia.org/w/index.php?title=%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98&action=edit&redlink=1)，请参见下面的继承性一节。    [对象](https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))（Object）是类的[实例](https://zh.wikipedia.org/wiki/%E5%AE%9E%E4%BE%8B)。对象有时会对应到现实世界中的事物，举例来说，一个图形程序可能有圆形、矩形与画面等对象，一个线上购物系统可能有购物车、顾客与产品等类。[[7\\]](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1#cite_note-7)。有时对象会表示更抽象的实体，比如一个被打开的文件或是一个提供美国惯用量测转换的服务。每个对象就是一个特定类的实例（例如，名称是“玛丽”的对象可能是类雇员的一个实例）。程序在面向对象编程当中被视为方法，变量被视为成员或属性。例如，“[狗](https://zh.wikipedia.org/wiki/%E7%8B%97)”这个类列举狗的特点，从而使这个类定义了世界上所有的狗。而莱丝这个对象则是一条具体的狗，它的属性也是具体的。狗有皮毛颜色，而莱丝的皮毛颜色是棕白色的。因此，莱丝就是狗这个类的一个实例。一个具体对象属性的值被称作它的“[状态](https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81)”。（系统给对象分配内存空间，而不会给类分配内存空间。这很好理解，类是抽象的，系统不可能给抽象的东西分配空间，而对象则是具体的。）    假设我们已经在上面定义了狗这个类，我们就可以用这个类来定义对象：     ````javascript  定义莱丝是狗  莱丝.毛皮颜色 : 棕白色  莱丝.吠叫()   ````         我们无法让狗这个类去吠叫，但是我们可以让对象“莱丝”去吠叫，正如狗可以吠叫，但没有具体的狗就无法吠叫。    #### 动态配置与消息传递机制    定义上动态配置是指方法会随着实例动态的改变。而消息传递机制（Message Passing）是指一个对象通过接受消息、处理消息、传出消息或使用其他类的方法来实现一定功能。如：莱丝可以通过吠叫引起人的注意，从而导致一系列的事发生。    #### 封装性     具备封装性（Encapsulation）的面向对象编程隐藏了某一方法的具体运行步骤，取而代之的是通过消息传递机制发送消息给它。封装是通过限制只有特定类的对象可以访问这一特定类的成员，而它们通常利用接口实现消息的传入传出。举个例子，接口能确保幼犬这一特征只能被赋予狗这一类。通常来说，成员会依它们的访问权限被分为3种：公有成员、私有成员以及保护成员。有些语言更进一步：Java可以限制同一包内不同类的访问；C#和VB.NET保留了为类的成员聚集准备的关键字：internal（C#）和Friend（VB.NET）；Eiffel语言则可以让用户指定哪个类可以访问所有成员。    **具备封装性（Encapsulation）的面向对象程序设计隐藏了某一方法的具体执行步骤，取而代之的是通过消息传递机制传送消息给它。**因此，举例来说，“狗”这个类有“吠叫()”的方法，这一方法定义了狗具体该通过什么方法吠叫。但是，莱丝的朋友并不知道它到底是如何吠叫的。    从实例来看：    ````js  /* 一个面向过程的程序会这样写： */  定义莱丝  莱丝.设置音调(5)  莱丝.吸气()  莱丝.吐气()    /* 而当狗的吠叫被封装到类中，任何人都可以简单地使用： */  定义莱丝是狗  莱丝.吠叫()  ````    #### 继承    继承性（Inheritance）是指，在某种情况下，一个类会有“子类”。子类比原本的类（称为父类）要更加具体化。例如，“狗”这个类可能会有它的子类“牧羊犬”和“吉娃娃犬”。在这种情况下，“莱丝”可能就是牧羊犬的一个实例。子类会继承父类的属性和行为，并且也可包含它们自己的。我们假设“狗”这个类有一个方法（行为）叫做“吠叫()”和一个属性叫做“毛皮颜色”。它的子类（前例中的牧羊犬和吉娃娃犬）会继承这些成员。这意味着程序员只需要将相同的代码写一次。    在伪代码中我们可以这样写：     ````js  类牧羊犬 : 继承狗    定义莱丝是牧羊犬  莱丝.吠叫()    /* 注意这里调用的是狗这个类的吠叫方法。*/  ````    回到前面的例子，“牧羊犬”这个类可以继承“毛皮颜色”这个属性，并指定其为棕白色。而“吉娃娃犬”则可以继承“吠叫()”这个方法，并指定它的音调高于平常。子类也可以加入新的成员，例如，“吉娃娃犬”这个类可以加入一个方法叫做“颤抖()”。设若用“牧羊犬”这个类定义了一个实例“莱丝”，那么莱丝就不会颤抖，因为这个方法是属于吉娃娃犬的，而非牧羊犬。事实上，我们可以把继承理解为“是”或“属于”。莱丝“是”牧羊犬，牧羊犬“属于”狗类。因此，莱丝既得到了牧羊犬的属性，又继承了狗的属性。 我们来看伪代码：     ````  类吉娃娃犬 : 继承狗  开始      公有成员:          颤抖()  结束  类牧羊犬 : 继承狗    定义莱丝是牧羊犬  莱丝.颤抖()    /* 错误：颤抖是吉娃娃犬的成员方法。 */  ````    当一个类从多个父类继承时，我们称之为“多重继承”。如一只狗既是吉娃娃犬又是牧羊犬（虽然事实上并不合逻辑）。多重继承并不总是被支持的，因为它很难理解，又很难被好好使用。    #### 多态    多态（Polymorphism）是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应[8]。例如，狗和鸡都有“叫()”这一方法，但是调用狗的“叫()”，狗会吠叫；调用鸡的“叫()”，鸡则会啼叫。 我们将它体现在伪代码上：    ````js  类狗  开始      公有成员:          叫()          开始              吠叫()          结束  结束    类鸡  开始      公有成员:          叫()          开始              啼叫()          结束  结束    定义莱丝是狗  定义鲁斯特是鸡  莱丝.叫()  鲁斯特.叫()  ````    这样，虽然同样是做出**叫**这一种行为，但莱丝和鲁斯特具体做出的表现方式将大不相同。多态性的概念可以用在[运算符重载](https://zh.wikipedia.org/wiki/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD)上，本文不再赘述。     #### 抽象性    抽象（Abstraction）是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。举例说明，莱丝在大多数时候都被当作一条狗，但是如果想要让它做牧羊犬做的事，你完全可以调用牧羊犬的方法。如果狗这个类还有动物的父类，那么你完全可以视莱丝为一个动物。    #### 优缺点    不过，我们也需要知道面向对象的优缺点。    优点    能和真实的世界交相辉映，符合人的直觉。    面向对象和数据库模型设计类型，更多地关注对象间的模型设计。    强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。    根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。    拥有大量非常优秀的设计原则和设计模式。    S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……    缺点    代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。         ### 基于原型的编程范式    基于原型（prototype）的编程其实也是面向对象编程的一种方式。没有 class 化的，直接使用对象。又叫，基于实例的编程。其主流的语言就是 JavaScript。与传统的面对象编程的比较如下。    #### 与基于类编程的比较    在基于类编程当中，对象总共有两种类型。类定义了对象的基本布局和函数特性，而接口是“可以使用的”对象，它基于特定类的样式。在此模型中，类表现为行为和结构的集合，就接口持有对象的数据而言，对所有接口来说是相同的。区分规则因而首先是基于结构和行为，而后是状态。    原型编程的主张者经常争论说基于类的语言提倡使用一个关注分类和类之间关系开发模型。与此相对，原型编程看起来提倡程序员关注一系列对象实例的行为，而之后才关心如何将这些对象划分到最近的使用方式相似的原型对象，而不是分成类。因为如此，很多基于原型的系统提倡运行时原型的修改，而只有极少数基于类的面向对象系统（比如第一个动态面向对象的系统 Smalltalk）允许类在程序运行时被修改。    原型编程常与认知心理学的特定思想流派有关，同样强调prototypes 和 exemplars 作为学习过程中的关键词。    考虑到绝大多数基于原型的系统是基于解释性的和动态类型程序语言，这里要重点指出的是静态类型语言实现基于原型从技术上是可行的。用基于原型编程描述的 Omega 语言就是这样系统的一个例子。尽管根据 Omega 网站所述，Omega 也不是完全的静态，但是可能的时候，它的编译器有时会使用静态绑定来改进程序的效率。    #### 对象构造    **在基于原型的系统中构造对象有两种方法，通过复制已有的对象或者通过扩展空对象创建。**    在基于类的语言中，一个新的实例通过类构造器和构造器可选的参数来构造，结果实例由类选定的行为和布局创建模型。在基于原型的系统中构造对象有两种方法，通过复制已有的对象 或者通过扩展 nihilo（空的）对象创建，因为大多数系统提供了不同的复制方法，扩展 nihilo 对象的方式鲜为人知。    提供扩展 nihilo 对象创建的系统允许对象从空白中创建而无需从已有的原型中复制。这样的系统提供特殊的文法用以指定新对象的行为和属性，无须参考已存在的对象。在很多原型语言中，通常有一个 Object 原型，其中有普遍需要的方法。它被用作所有其它对象的最终原型。扩展 nihilo 对象创建可以保证新对象不会被顶级对象的名字空间污染。(在JavaScript中，可以利用null原型来做到, i.e. Object.create(null))。    Cloning 指一个新对象通过复制一个已经存在的对象（就是他的原型）来构造自己的过程。于是新的对象拥有原来对象的所有属性，从这一点出发新对象的属性可以被修改。在某些系统中，子对象持有一个到它原型的直接链接（经由授权或类似方式）。并且原型的改变同样会导致它的副本的变化。其他系统中，如类 [Forth](https://zh.wikipedia.org/wiki/Forth) 的程序语言，[Kevo](https://zh.wikipedia.org/w/index.php?title=Kevo&action=edit&redlink=1) 在此情况下不传播原型的改变，而遵循一个更加连续的模型，其中被复制的对象改变不会通过他的副本传播。    ####  JavaScript的原型概念    由于JavaScript缺乏类,它用构造函数和原型对象来给对象带来与类相似的功能。但是,这些相似的功能并不一定 "表现的跟类完全一致。在本章中,你会详细看到JavaScript如何使用构造函数和原型对象来创建对象。    我们先来看一个示例。     ````js  var foo = {name: "foo", one: 1, two: 2};    var bar = {three: 3};  ````    每个对象都有一个 __proto__ 的属性，这个就是“原型”。对于上面的两个对象，如果我们把 foo 赋值给 bar.__proto__，那就意味着，bar 的原型就成了 foo的。     ````js  bar.__proto__ = foo; // foo is now the prototype of bar.  ````    于是，我们就可以在 bar 里面访问 foo 的属性了。     ````js  // If we try to access foo\'s properties from bar  // from now on, we\'ll succeed.  bar.one // Resolves to 1.    // The child object\'s properties are also accessible.  bar.three // Resolves to 3.    // Own properties shadow prototype properties  bar.name = "bar";  foo.name; // unaffected, resolves to "foo"  bar.name; // Resolves to "bar"  ````    需要解释一下 JavaScript 的两个东西，一个是 __proto__，另一个是 prototype，这两个东西很容易混淆。    这里说明一下：    _proto__ 主要是安放在一个实际的对象中，用它来产生一个链接，一个原型链连，用于寻找方法名或属性，等等。    prototype 是用 new 来创建一个对象时构造 __proto__ 用的。它是构造函数的一个属性。    在 JavaScript 中，对象有两种表现形式， 一种是 Object ([ES5 关于 Object 的文档](http://www.ecma-international.org/ecma-262/5.1/#sec-15.2))，一种是 Function （[ES5 关于 Function 的文档](http://www.ecma-international.org/ecma-262/5.1/#sec-15.2)）。我们可以简单地认为，__proto__ 是所有对象用于链接原型的一个指针，而 prototype 则是 Function 对象的属性，其主要是用来当需要 new 一个对象时让 __proto__ 指针所指向的地方。 对于超级对象 Function 而言， Function.__proto__ 就是 Function.prototype。     比如我们有如下的代码：     ````js  var a = {  x: 10,  calculate: function (z) {  return this.x + this.y + z;  }  };    var b = {  y: 20,  __proto__: a  };    var c = {  y: 30,  __proto__: a  };    // call the inherited method  b.calculate(30); // 60  c.calculate(40); // 80  ````    其中的“原型链”如下所示：     ![](http://p8xb02d0d.bkt.clouddn.com/18-7-26/7703965.jpg)    注意：ES5 中，规定原型继承需要使用 Object.create() 函数。如下所示：     ````js  var b = Object.create(a, {y: {value: 20}});  var c = Object.create(a, {y: {value: 30}});  ````    好了，我们再来看一段代码：     ````js  // 一种构造函数写法  function Foo(y) {  this.y = y;  }    // 修改 Foo 的 prototype，加入一个成员变量 x  Foo.prototype.x = 10;    // 修改 Foo 的 prototype，加入一个成员函数 calculate  Foo.prototype.calculate = function (z) {  return this.x + this.y + z;  };    // 现在，我们用 Foo 这个原型来创建 b 和 c  var b = new Foo(20);  var c = new Foo(30);    // 调用原型中的方法，可以得到正确的值  b.calculate(30); // 60  c.calculate(40); // 80  ````    那么，在内存中的布局是怎么样的呢？大概是下面这个样子。     ![](http://p8xb02d0d.bkt.clouddn.com/18-7-26/17024251.jpg)        这个图应该可以让你很好地看明白 __proto__ 和 prototype 的差别了。     我们可以测试一下：     ````js  b.__proto__ === Foo.prototype, // true  c.__proto__ === Foo.prototype, // true    b.constructor === Foo, // true  c.constructor === Foo, // true  Foo.prototype.constructor === Foo, // true    b.calculate === b.__proto__.calculate, // true  b.__proto__.calculate === Foo.prototype.calculate // true  ````    这里需要说明的是——    Foo.prototype 自动创建了一个属性 constructor，这是一个指向函数自己的一个 reference。    这样一来，对于实例 b 或 c 来说，就能访问到这个继承的 constructor 了。有了这些基本概念，我们就可以讲一下 JavaScript 的面向对象编程了。    注： 上面示例和图示来源于 [JavaScript, The Core](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/) 一文。JavaScript 原型编程的面向对象我们再来重温一下上面讲述的内容：     ````js  function Person(){}  var p = new Person();    Person.prototype.name = "Hao Chen";  Person.prototype.sayHello = function(){  console.log("Hi, I am " + this.name);  }    console.log(p.name); // "Hao Chen"  p.sayHello(); // "Hi, I am Hao Chen"  ````    在上面这个例子中：    我们先生成了一个空的函数对象 Person()；    然后将这个空的函数对象 new 出另一个对象，存在 p 中；    这时再改变 Person.prototype，让其有一个 name 的属性和一个 sayHello() 的方法；    我们发现，另外那个 p 的对象也跟着一起改变了。    注意一下，    当创建 function Person(){} 时，Person.__proto__ 指向 Function.prototype;    当创建 var p = new Person() 时，p.__proto__ 指向 Person.prototype;    当修改了 Person.prototype 的内容后，p.__proto__ 的内容也就被改变了。好了，我们再来看一下“原型编程”中面向对象的编程玩法。首先，我们定义一个 Person 类。     ````js  //Define human class  var Person = function (fullName, email) {  this.fullName = fullName;  this.email = email;    this.speak = function(){  console.log("I speak English!");  };  this.introduction = function(){  console.log("Hi, I am " + this.fullName);  };  }  ````    上面这个对象中，    包含了：    属性： fullName 和 email；    方法： speak() 和 introduction()。    其实，所谓的方法也是属性。然后，我们可以定义一个 Student 对象。     ````js  //Define Student class  var Student = function(fullName, email, school, courses) {    Person.call(this, fullName, email);    // Initialize our Student properties  this.school = school;  this.courses = courses;    // override the "introduction" method  this.introduction= function(){  console.log("Hi, I am " + this.fullName +  ". I am a student of " + this.school +  ", I study "+ this.courses +".");  };    // Add a "exams" method  this.takeExams = function(){  console.log("This is my exams time!");  };  };  ````    在上面的代码中：    使用了 Person.call(this, fullName, email)，call() 或 apply() 都是为了动态改变 this 所指向的对象的内容而出现的。这里的 this 就是 Student。    上面的例子中，我们重载了 introduction() 方法，并新增加了一个 takeExams()的方法。    虽然，我们这样定义了 Student，但是它还没有和 Person 发生继承关系。    为了要让它们发生关系，我们就需要修改 Student 的原型。我们可以简单粗暴地做赋值：Student.__proto__ = Person.prototype ，但是，这太粗暴了。    我们还是使用比较规范的方式：    先用 Object.create() 来将Person.prototype 和 Student.prototype 关联上。    然后，修改一下构造函数 Student.prototype.constructor = Student;。     ````js  // Create a Student.prototype object that inherits  // from Person.prototype.  Student.prototype = Object.create(Person.prototype);    // Set the "constructor" property to refer to Student  Student.prototype.constructor = Student;  ````    这样，我们就可以这样使用了。     ````js  var student = new Student("Hao Chen",  "haoel@hotmail.com",  "XYZ University",  "Computer Science");  student.introduction();  student.speak();  student.takeExams();    // Check that instanceof works correctly  console.log(student instanceof Person); // true  console.log(student instanceof Student); // true  ````    上述就是基于原型的面向对象编程的玩法了。注：在 ECMAScript 标准的第四版开始寻求使 JavaScript 提供基于类的构造，且 ECMAScript 第六版有提供 "class"(类) 作为原有的原型架构之上的语法糖，提供构建对象与处理继承时的另一种语法。    小结    我们可以看到，这种玩法就是一种委托的方式。在使用委托的基于原型的语言中，运行时语言可以仅仅通过循着一个序列的指针直到找到匹配这样的方式来定位属性或者寻找正确的数据。所有这些创建行为共享的行为需要的是委托指针。    不像是基于类的面向对象语言中类和接口的关系，原型和它的分支之间的关系并不要求子对象有相似的内存结构，因为如此，子对象可以继续修改而无需像基于类的系统那样整理结构。还有一个要提到的地方是，不仅仅是数据，方法也能被修改。因为这个原因，大多数基于原型的语言把数据和方法提作“slots”。    这种在对象里面直接修改的玩法，虽然这个特性可以带来运行时的灵活性，我们可以在运行时修改一个 prototype，给它增加甚至删除属性和方法。但是其带来了执行的不确定性，也有安全性的问题，而代码还变得不可预测，这有点黑科技的味道了。因为这些不像静态类型系统，没有一个不可变的契约对代码的确定性有保证，所以，需要使用者来自己保证。     '},{title:"解构赋值",path:"/posts/es6+/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html",strippedContent:' ## 一、背景知识：    对象与数组的字面量在 JS 中是最常用的两种表示法，并且感谢流行的 JSON 数据格式，它  们已成为这门语言中的格外重要的部分。定义对象与数组非常普遍，定义之后就能有条不紊  地从这些结构中提取出相关信息。为了简化提取信息的任务， ES6 新增了解构（  destructuring ），这是将一个数据结构分解为更小的部分的过程。本文介绍如何在对象与数  组上利用解构。    ## 二、知识剖析    ### 解构为何有用？    在 ES5 及更早版本中，从对象或数组中获取信息、并将特定数据存入本地变量，需要书写许  多并且相似的代码。例如：    ```js  let options = {         repeat: true,         save: false     };  // 从对象中提取数据  let repeat = options.repea      save = options.save;  ```    此代码提取了 options 对象的 repeat 与 save 值，并将其存在同名的本地变量上。虽然  这段代码看起来简单，但想象一下若有大量变量需要处理，你就必须逐个为其赋值；并且若  有一个嵌套的数据结构需要遍历以寻找信息，你可能会为了一点数据而挖掘整个结构。  这就是 ES6 为何要给对象与数组添加解构。当把数据结构分解为更小的部分时，从中提取你  要的数据会变得容易许多。很多语言都能用精简的语法来实现解构，让它更易使用。 ES6 的  解构实际使用的语法其实你早已熟悉，那就是对象与数组的字面量语法。    \x3c!--more--\x3e     ### 对象解构    对象解构语法在赋值语句的左侧使用了对象字面量，例如：    ```js  let node = {  type: "Identifier",  name: "foo"  };  let { type, name } = node;  console.log(type); // "Identifier"  console.log(name); // "foo"  ```    在此代码中， node.type 的值被存储到 type 本地变量中， node.name 的值则存储到  name 变量中。此语法相同于第四章介绍的简写的属性初始化器。 type 与 name 标识符既  声明了本地变量，也读取了对象的相应属性值。    #### 解构赋值    以上对象解构示例都用于变量声明。不过，也可以在赋值的时候使用解构。例如，你可能想  在变量声明之后改变它们的值，如下所示：    ```js  let node = {  type: "Identifier",  name: "foo"  },  type = "Literal",  name = 5;  // 使用解构来分配不同的值  ({ type, name } = node);  console.log(type); // "Identifier"  console.log(name); // "foo"  ```    在本例中， type 与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不  同的值。接下来一行使用了解构表达式，通过读取 node 对象来更改这两个变量的值。注意  你必须用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语  句不允许在赋值操作符（即等号）左侧出现。圆括号标示了里面的花括号并不是块语句、而  应该被解释为表达式，从而允许完成赋值操作。  解构赋值表达式的值为表达式右侧（在 = 之后）的值。也就是说在任何期望有个值的位置都  可以使用解构赋值表达式。    #### 默认值    当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量  会被赋值为 undefined 。    #### 赋值给不同的本地变量名    ```js  let node = {  type: "Identifier",  name: "foo"  };  let { type: localType, name: localName } = node;  console.log(localType); // "Identifier"  console.log(localName); // "foo"  ```    #### 嵌套的对象解构    ```js  let node = {      type: "Identifier",      name: "foo",      loc: {          start: {              line: 1,              column: 1          },          end: {              line: 1,              column: 4          }      }  };  let { loc: { start }} = node;  console.log(start.line); // 1  console.log(start.column); // 1    ```    ## 三、常见问题    如何使用数组解构？     ## 四、解决方案    ### 数组解构    数组解构的语法看起来与对象解构非常相似，只是将对象字面量替换成了数组字面量。数组  解构时，解构作用在数组内部的位置上，而不是作用在对象的具名属性上，例如：    ```js  let colors = [ "red", "green", "blue" ];  let [ firstColor, secondColor ] = colors;  console.log(firstColor); // "red"  console.log(secondColor); // "green"  ```    此处数组解构从  colors  数组中取出了  "red"  与  "green"  ，并将它们赋值给  fristColor  与  secondColor  变量。这些值被选择，是由于它们在数组中的位置，实际的变量名称是任意  的（与位置无关）。任何没有在解构模式中明确指定的项都会被忽略。记住，数组本身并没  有以任何方式被改变。    #### 解构赋值    你可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号  内，例如：    ```js  let colors = [ "red", "green", "blue" ],  firstColor = "black",  secondColor = "purple";  [ firstColor, secondColor ] = colors;  console.log(firstColor); // "red"  console.log(secondColor); // "green"  ```        #### 默认值    数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为  undefined  ，那么该默认值就会被使用    #### 嵌套的解构    与解构嵌套的对象相似，可以用类似的方式来解构嵌套的数组。在整个解构模式中插入另一  个数组模式，解构操作就会下行到嵌套的数组中，就像这样：    ```js  let colors = [ "red", [ "green", "lightgreen" ], "blue" ];  // 随后  let [ firstColor, [ secondColor ] ] = colors;  console.log(firstColor); // "red"  console.log(secondColor); // "green"  ```    此处的  secondColor  变量指向了  colors  数组中的  "green"  值，该项被包含在第二个数组  中，因此解构模式就要把  secondColor  包裹上方括号。与对象解构相似，你也能使用任意深  度的数组嵌套。    #### 剩余项    数组解构有个名为剩余项（ rest items ）的概  念，它使用  ...  语法来将剩余的项目赋值给一个指定的变量，此处有个范例：    ```js  let colors = [ "red", "green", "blue" ];  let [ firstColor, ...restColors ] = colors;  console.log(firstColor); // "red"  console.log(restColors.length); // 2  console.log(restColors[0]); // "green"  console.log(restColors[1]); // "blue"  ```        ## 五、编码实战    以上    ## 六、拓展思考    解构使得在 JS 中操作对象与数组变得更容易。使用熟悉的对象字面量与数组字面量语法，可  以将数据结构分离并只获取你感兴趣的信息。对象解构模式允许你从对象中进行提取，而数  组模式则能用于数组。  对象与数组解构都能在属性或项未定义时为其提供默认值；在赋值表达式右侧的值为  null  或  undefined  时，两种模式都会抛出错误。你也可以在深层嵌套的数据结构中使用对象与数  组解构，下行到该结构的任意深度。  使用  var  、  let  或  const  的解构声明来创建变量，就必须提供初始化器。解构赋值能替  代其他赋值，并且允许你把值解构到对象属性或已存在的变量上。  参数解构使用解构语法作为函数的参数，让“选项”（ options ）对象更加透明。你实际感兴趣  的数据可以与具名参数一并列出。解构的参数可以是对象模式、数组模式或混合模式，并且  你能使用它们的所有特性。        ## 七、参考文献    《深入了解es6》    ### 八、更多讨论    #### 1.如何**交换变量的值**：    ```  [x, y] = [y, x];  ```    上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。    #### 2.**从函数返回多个值**    ```js  function example() {    return [1, 2, 3];  }  var [a, b, c] = example();    // 返回一个对象    function example() {    return {      foo: 1,      bar: 2    };  }  var { foo, bar } = example();  ```    #### 3.**提取 JSON 数据**    解构赋值对提取 JSON 对象中的数据，尤其有用。    ```  var jsonData = {    id: 42,    status: "OK",    data: [867, 5309]  }    let { id, status, data: number } = jsonData;    console.log(id, status, number)  // 42, OK, [867, 5309]  ```    '},{title:"敏捷开发流程",path:"/posts/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91.html",strippedContent:" 一.需求讲解        1.理解需求背景      2.确认需求明确，无逻辑遗漏      3.确认所有的需求都有实现方案      4.合理预估时间      5.需求不明确或者是不清晰的点，可以当场提出来 ，或者是稍后整理      6.快速整理出未实现过功能，逻辑，技术点，可以和leader一起讨论交流方案      7.确认验收标准是否完善      8.确认Story优先级和粒度有无疑问，有问题反馈给leader         二. 方案评审            1.前后端快速整理出来多少个接口，哪些可复用，哪些需要合并      2.接口遵循Rest风格，考虑扩展性      3.参数和返回值都清晰明确，遵循接口定义规范      4.关键业务逻辑画业务流程图      5.DB设计完备，Sql语句完善，索引完整，常量标注清晰，表名和字段名符合规范      6.DB设计中预估数据量和增长速度      7.制作出架构图      8.后端预估并发数      9.前端给出公共组件     10.前端给出浏览器兼容版本     11.确定是前后端分离还是不分离     12.明确开发，测试，线上三个环境的IP，内存，域名等资源分配     13.给出多种解决方案和推荐方案     14.方案应该在两天之内完成     15.评审通过之后，Task在两个小时之内拆解完成，Task的粒度不超过2小时，Task无遗漏     三.日常任务       1.3次Todo List     2.下班前提交代码，部署开发环境，测试当天完成的内容     3.寻找影响Story完成的阻碍点     4.晨会演示昨天完成的内容     5.测试正常数据和边界数据     6.晨会审核燃尽图，更新Demo时间，找出延期的原因，给出解决办法     7.每天随时测试完成的结果，遵循测试方法       四.性能测试     1.明确结论，通过或不通过      五.CodeReview      1.是否符合编码规范      2.是否和方案设计一致      3.是否有逻辑漏洞和潜在风险      六.Demo      1.确保所有的关键业务逻辑全部走通      2.确保异常数据处理正常      3.确保各种兼容性      4.确保最终研发出来的产品符合用户的使用逻辑，没有反人类的设计    ## 一、story讲解    ​      1.1 制作竞品分析PPT，UE全组参与。（用时：根据产品复杂度，0.5-2小时之内）  ​      1.2 制作产品原型，交由客户看，客户看没问题组织内评，内评通过后约需求评审；    ​      1.3产品需求评审，以禅道，PPT，原型三个为准。所有的Story都是要在禅道写清楚，验收标准写好。直接交付开工，不允许再出现需求评审之后还在补禅道的情况 。    ​       需求评审通过后，后续开发根据优先级进行开发    ​      1.4 由产品讲解story，前端和后端都参与。（用时：根据产品的复杂度，1-3小时之内）    \x3c!--more--\x3e     ## 二、人员划分    ​      2.1 新建wiki项目主业，把PPT和产品原型（HTML文件）上传到wiki    ​      2.2 根据产品原型，按照模块划分相关负责人，前端和后端都是，并放到wiki。（由项目负责人新建）    ​      命名：xxx项目人员分工（前（后）端）     ## 三、定义接口文档（2-3天）    ​       3.1 前端后端相关人员一起，对照原型，根据模块及页面大概定义出接口    ​             3.1.1 一个页面中有几个接口，每个接口入参与出参是什么    ​       3.2 后端每个模块的负责人，根据开会讨论的结果，在wiki上生成标准的接口文档    ​       3.3 将后端做好的接口文档发给前端模块负责人过目，有问题继续修改；没问题开始后续的步骤 。    ​        ## 四、方案设计（1小时-1天左右，根据模块大小定义时间）     4.1 后端开发人员，根据原型以及定义的接口，做好方案设计    ​            4.1.1 对有难度或者有疑点的接口，做出方案，尽量给出多个合理方案    ​            4.1.2 每个方案写清楚优点缺点    ## 五、方案评审（2-3小时）    ​       5.1 对做出的方案设计，做方案评审，建议全体人员参与（无论做不做该项目）    ## 六、禅道拆分（1-2小时）    ​      6.1 相关负责人按照优先级顺序，在禅道拆分自己的任务，单个任务最多不要超过4小时，即拆分要详细         ​            \\1. 拆分一个task时，以具体写的代码为一个task，并在任务名称中写出该类/方法的名称在任务描述中写出该task的代码块具体有的功能    ​            \\2. 当拆完task后，这几个task所完成功能的代码已经过了一遍    ​            \\3. 如果有不了解的功能，在方案评审前先写出一个demo，以方便拆分task的估时    ​            \\4. 一个task用时应在0.5-2之间，最大最大4个小时         ​            以文件上传功能为例，分成3个task    ​               (1) 任务名称：公共模块-文件上传-上传文件controller的方法fileUpload  ​                    任务描述：通过网页获取文件，文件判空，判断文件的归属类型（用户/教材/课时/步骤/咨询）  ​                    工时：1    ​               (2) 任务名称：公共模块-文件上传-添加文件FileUtil 和FileUtilOssImpl  ​                    任务描述：util处理上传的文件，判断文件类型，大小，设置文件上传的路径，返回的url  ​                    工时：1.5    ​               (3) 任务名称：公共模块-文件上传-文件接口spring-fileOss.xml 配置文件  ​                    任务描述：oss的文件上传， 调用的spring.xml配置文件（密匙，ID,bucket等）    ​                   工时：0.5    ## 七、开发    ​      7.1 搭建开发服务器    ​      7.2 开发人员根据禅道上的任务，按时完成自己的开发工作，具体体现到日报上    ​      7.3 每天上午开10分钟左右进度会议，如果有延迟现象出现，拿出解决方案，保证项目按照禅道上的时间点完成    ​      7.4 数据库索引：    两种索引：1.经常查询的，数据散列度比较高的，做一般索引，不需要建联合索引。2.数据必须保持唯一的，建唯一索引。    ​        1、要有文档，文档表明哪些字段要建索引。发邮件。    ## 八、阶段测试    ​       与开发并行    ​       8.1 每天至少发布一次代码到开发环境，并且保证发布完之后程序没问题    ## 九、性能测试和coderevivew（1天）    ​     9.1 对每个接口做好性能测试    ​            9.1.1 每个接口的响应时间不超过200ms，如果有超过的，做优化，尽量缩小到200ms内    ​      9.2 完成codereview，根据codereview结论完成修改    ## 十、压力测试    ​     10.1做好压测报告    ## 十一、 Demo    1、发demo申请邮件，收件人包括产品、测试同学、前后端相关开发人员    ​      主题：XX项目demo通知    ​      内容：时间 地点  参会人员    2、开demo会议：主讲人：某个开发人员    ​     会议途中产品和测试提出问题    3、发demo结果通知邮件(由产品同学发)    ​     内容包括：1、demo结果  2、如果不通过，有哪些问题    4、如果不通过，召集第二次Demo会议，知道通过为止。第二次会议只需演示之前不通过的部分         11.2 测试    1、demo通过之后，1：开发人员对代码打tag，参考文档  [如何打tag](http://new.wiki.jnshu.com/pages/viewpage.action?pageId=1183585)  2.开发人员部署测试环境，部署完成之后发邮件，写明域名；3：交给测试人员进行测试，测试人员发送全体测试周期邮件    2、测试期间，如果有测试发现bug，会在禅道上面提出bug，禅道会发送邮件到各自开发人员的邮箱，开发人员要关注BUG邮件 ，及时确认BUG，及时修改    3、修改BUG之后，开发环境前端代码由前端同学自己部署，后端代码由后端同学自己部署    ​                               测试环境每天的下午6点由后端同学统一部署前后端代码    4、测试完成之后，测试或产品发送上线通知    具体参看：[测试Bug划分及处理流程](http://my.wiki.ptteng.com/pages/createpage.action?spaceKey=art&title=%E6%B5%8B%E8%AF%95Bug%E5%88%92%E5%88%86%E5%8F%8A%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B&linkCreation=true&fromPageId=8257825)    测试和线上环境发布流程：[测试及线上环境发布流程](http://new.wiki.jnshu.com/pages/viewpage.action?pageId=1182458)         ## 十二、 发布测试环境、集成测试（2-3天）    ​      12.1 禅道上建立bug，测试出bug，指派给相关人员修改         ## 十三、发布线上环境，同时停止开发环境和测试环境        ## 十四、线上监控    ​       错误报告         敏捷开发相关资料：[PPT](http://my.wiki.ptteng.com/pages/viewpage.action?pageId=15048710)  [视频](http://pan.baidu.com/s/1gfMiH3d)    PS：每个项目的入口页面，需要有如下内容：    一、        | 文档                 | wiki地址 |  | -------------------- | -------- |  | 模块负责人文档       |          |  | xx模块接口文档       |          |  | xx模块方案设计文档   |          |  | 项目禅道地址         |          |  | 接口性能测试报告文档 |          |         二、项目进度        | 序号 | 阶段 | 节点     | 开始时间 | 结束时间 | 用时  | 备注                                                         |  | ---- | ---- | -------- | -------- | -------- | ----- | ------------------------------------------------------------ |  | 1    | 产品 | 需求提出 | 4月27日  | 5月11日  | 15day | 5月11日之前主要是在做其他项目，从5月11日开始正式魔镜产品的相关工作； |  |      |      | 需求评审 | 5月11日  | 5月13日  | 2day  |                                                              |  |      |      | 需求讲解 | 5月13日  | 5月13日  | 1day  | 主要是进行了魔镜整体思路、结构架构、story讲解等              |        三、燃尽图         四、地址        | 系统   | 开发环境 ip    | 测试环境ip     | 线上环境ip | 测试地址 | 登陆用户名 | 密码 |  | ------ | -------------- | -------------- | ---------- | -------- | ---------- | ---- |  | xx系统 | 12120.92.4.210 | 120.132.71.211 |            |          |            |      |         五、前端hosts及nginx配置             ## 【视频】    链接：<http://pan.baidu.com/s/1nv4vAbf> 密码：g9xn    链接：<https://pan.baidu.com/s/1zXlM6wGPOhswV5hkYNA6ag> 密码：3cxj    知乎：<https://www.zhihu.com/question/39757751>        ## 【其他】    1. 前后端如何协作  <https://www.zhihu.com/question/27226086/answer/246446191>            "},{title:"country of blind 盲人国",path:"/posts/reprint/country%20of%20blind.html",strippedContent:" 从前有一段时间，因为世界全面战争，到处都在打战，这时有一批人就躲到一个山谷，他们在那儿定居下来，这地方山明水秀，简直在像世外桃源，与世隔绝，他们种菜和畜养猪、养牛，自立更生，完全不和外地来往。可是可怕的事却发生了。\x3c!--more--\x3e     这儿的人，眼睛慢慢地看不见，尤其是刚出生的小婴儿，几乎都看不见，他们也不知道为什么会这样。他们不知道怎么发生，以为是上天要惩罚他们，于是，他们便把金银财宝拿出，派人外出买最好的神坛祭祖，他们以为神坛祭祖可以让上天听到人们的声音，不要惩罚他们，派出去的人刚出山谷没多久，那地方却发生了大地震，好像和九二一大小，山崩地裂，唯一的道路，被土石流堵死了。派出去的人们再也没有回来，后来都病死在外地，但盲人国的存在一直在人间流传，世间也有这么一句话：One eye man is the king of country blind.     几百年后，一个登山队来到盲人国附近的高山，突然一个大风雪，把他们的领队吹散，这位领队在大堆雪中掉落千尺。他摔得很重，却连一根骨头都没折断，一个人滚到一个较不陡峭的山坡上，埋在白皑皑的雪堆里。他从雪堆中挣扎出来，看到下面另一处陡峭的悬崖有一道狭窄岩缝，一个陷于绝境的人只能冒险从那里爬下去。他的名字叫努涅斯，一直往下，也不过半个多小时的时间，就走出了山洞，来到一片美丽的山谷。放眼望去，谷底有嫩绿的新草，小河也欢快的流动着，天上有阳光暖暖的照耀，还有野鸟在枝头嬉戏。    「原来这洞是下山的捷径啊，我竟然已经下山了！我得救了！」努涅斯兴奋的想。    果然没走多久，便找到了一条小径，通往远处的一座小城。    走到小城外，他开始觉得有些奇怪。城外的道路相当干净，但不是平的，上面满是微微凸起的直条纹，像导盲砖横铺。城外有座农家，房子远看还算普通，但走近一看，却发现这房子竟是没有窗户的，除了门之外就只有几个通风孔之类的东西，勉强点缀在墙面上。    「好奇怪的地方啊！」他想。    远远看见一个大概二十刚出头的女孩子，穿着一件亚麻色的洋装，坐在阳光下用手抚摸着什么东西。努涅斯走近一看，发现这女孩应该是他见过最美的女人了。她长得艳丽，妆扮得朴素而高雅，五官与四肢都像是古典大师雕刻一般，线条柔和而优美，微微带着点神秘感。这不是那种见了就让人想一亲芳泽的美，却是那种光是看着她就可以把人的灵魂都洗净的，那种高洁灵性的美，有如女神一般，让人一见难忘。    这样美丽的女人，却正在『读』一本点字书。她的双眼看来很正常，却偏偏没有半点神气，想是已经瞎了。努涅斯心里一边大呼可惜，一边又暗暗庆幸刚才目瞪口呆的蠢像没有让她看见。    「小姐请问一下，这里是什么地方？我遭到山难了，搞不清楚方向，刚刚才下山来。」在贪婪的又看了她很久之后，努涅斯才问。    那位小姐似乎非常惊讶。「你是谁？听你的口音很陌生，确实是个外地人，但你一个外地人，又还没走近，怎么能知道我是小姐？」    「老远就看见的啊。妳不过二十几岁吧，当然叫小姐啦。」努涅斯觉得莫名奇妙。    「『看见』？你这人讲话真奇怪，啊，你是说听见吧。」她露出恍然大悟的表情。「你很幸运，你听起来很累的样子，受伤了吗？我送你到医院？我叫美丽。」    　　近在咫尺之处，三个用扁担挑着桶的人沿着一条小路走来。努涅斯和美丽的讲话声，让那三个人停下脚步，把脸朝这边转动。但是他们似乎没看见努涅斯。    　　那三个人并排站着，用耳朵对着他们。努涅斯看见他们的眼睑都闭着而且凹陷，好像里面的眼球已完全萎缩。“是一个人，”其中一个用几乎听不懂的西班牙语说道，“这个人，从岩石上面下来了。” 努涅斯迈着很有自信的脚步走上前去。他立刻想到关于那个湮没无闻的盲人国的所有古老故事，也想起了那一句古老谚语：在盲人国里，有一只眼睛的人就是王。他跟他们打了招呼。“你是从哪里来的？”一个人问道。“我从山那边来，”努涅斯说，“我来自埔里附近，那里有五万居民、市区很广大，在视力之内看不见尽头。” “视力？”其中一个人喃喃低声说。那三个人同时朝他逼近，令他大为吃惊。他向后倒退。躲避他们伸出的手指，但他们很俐落地把他抓住。然后在他浑身上下摸了一阵。他们认为他那两只眼睛和眨动的眼睑是很怪的东西。他们想，“一个奇怪的器官。”另一个说道，“我们领他去酋长那里。” “我看得见，”努涅斯说。“看见？”。“对，看见。”努涅斯转过身去，被一个人的水桶绊倒了。“他的感官还有缺点，”第三个盲人说，“他被绊倒了，又说些没有意义的话。 你牵着他的手走。” “随你们的便，”努涅斯说，他由人牵着走，不禁纵声大笑。美丽也跟大家到村子里。    那些人把他上一个门口推入一间漆黑的房间。几位比较年老的人开始诘问他，努涅斯向他们描述他从其中跌落下来的那个伟大世界。但他所说的，他们既不信，也听不懂。这些人和眼睛所看见的世界已经隔绝十几代了，外间世界的故事和那些看得见的东西的名称都已经从他们的心中消失。努涅斯觉察到这种情形，就静下来倾听。最年长的盲人向他说明，这个世界（指他们的山谷）最初只是岩石中一个空洞。然后出现了无生命、没有触摸能力的东西；然后出现了羊、猪和其他几种野主动物；后来出现了天使，人可以听到天使歌唱和拍翅声，却摸不到它。努涅斯对他所描述的天使大惑不解，后来才想到是乌儿。那些长辈继续向努涅斯说明他们如何把时间分为温暖和寒冷两部分，温暖的时间宜于睡觉，寒冷的时间宜于工作。他们给他拿来一碗羊奶和一些粗糙的堿面包，然后离开，让他睡觉，直到晚问的寒冷把他们唤醒，又开始另一天。但是努涅斯根本没有睡。“喂，埔里大哥！”一个声音从村子那一边喊他，“到这里来。”他听到就站起来，走到外边。他要一劳永逸地向他们表明有视力的人能做多少事情。他偷偷地离开小路，向旁边走了两步。“不要践踏草地，埔里大哥，”那个声音说，“那是不准的。”努涅斯停住脚步，大吃一惊。发出那声音的人沿着小路朝着他跑过来了。“你是要人把你像个小孩子似地牵着走吗？你走路的时候难道听不见路努涅斯笑了。“我看得见路，”他说。 “没有'看'这个字，”那个盲人踌躇了一会儿说，“不要再说这种傻话了，跟着我脚步的声音走。”努涅斯跟在后面，有些儿气恼。“我的机会会来的，”他说，“难道没有人告诉过你们，在盲人国里，一只眼睛的人就是王？”       “什么是盲？”那个盲人漫不经意地回过头来间道。四天过去了。到了第五天，这位“盲人之王”仍被他的子民认为是一个又笨又无用的外人。他们过着简单而辛劳的生活。他们衣食无缺，很注重音乐和歌唱，他们也有爱情和小孩。在他们那个有秩序的世界里，一切东西都适合他们的需要。他们的感官已经变得非常敏锐，可以在十二步之外听到一个人的心跳；他们能像狗那样轻易凭气息分辨人。一天早晨，两个育人和努涅斯在一起坐着，他想向他们表明视力的实际价值。他看见一个女孩朝他们走来，当时还距离很远，听不到声音，也嗅不出气味。“过一会儿，”他告诉他们说，“一个女孩就要来到这里。”刚说完，那个女生就转过身朝围墙走去。彼德并没有来到，他们都嘲笑努涅斯。他打算把他们之中的一个打倒地上，借着公平的格斗来表明眼睛的功用，他拿起锄头。他们都站着戒备，耳朵朝着他听。他感觉到无可奈何的恐怖，连忙逃出村子。他斜穿过一片草地，留下一条践踏的痕迹，然后坐在小路旁。有些人拿着锄头和棍子，朝他走来，他们一路上时常停下，用鼻子嗅闻，并且倾听。“    埔里大哥！”一个人喊道，“埔里大哥！你在哪里？” 他大声回答：“瞧，我在这山谷里要做什么就做什么。” 他们摸索着前进，可是走得很快。那情形很像玩捉迷阐，除了一个人之外，所有的人都蒙住眼。忽然间，他发觉自己置身在追逐者所构成的一个大弧形阵线内。\" “我要伤害你们了，”他说，由于情绪激动而抽搐着喘气。“老天在上，我真要伤害你们了。” 他开始朝着那个包围圈的一个缺口跑去。盲人们也挥舞着锄头和棍子在跑。他听到身后有脚步声，发现一个大个子向前冲来，对他发出声音处挥击。他胆怯了，急忙转身，在惊慌中朝围墙的一个小门口逃去。到了墙外，他绊倒在岩石上。他在那里躺下，抽噎地喘气。这场政变就此结束。他在外面待了两天两夜，没东西吃，也没遮蔽。最后，他爬到墙边大声喊叫，直至两个盲人从门里出来。“我疯了，”他说，“但是我的感官有缺点。”他们说这样就比较像话了。他们间他能不能“看见”。“不能，”他哭了——因为现在他身体很虚弱，而且病了。“那是傻话。看见那两个字是毫无意义！”     于是努涅斯变成了盲人国的公民，那些人都慢慢和他熟了。他住在一个主人叫叶考的家，在不生气的时候是个和蔼可亲的人。叶考家的隔壁就是那个叫美丽的女子。在努涅斯看来，美丽的眼睛好像随时都可以再张开；她的睫毛很长，大家却认为是一种破相。努涅斯却认为她很美丽，名副其实。努涅斯常偷偷地看她，而她也知道他常常对着他发呆。    有一次，在一个休息日的集会里，他们两人并肩坐在朦胧的星光之下，他的手落在她手上，大胆地把那只手握住，她也紧握回报。从那次以后，他每有机会就和她谈话。不久他就向长辈们要求娶她为妻。这件事情最初遭遇到激烈反对。青年男子都很愤怒，认为这会败坏他们的种族。后来一位长辈想出一个办法。他说：“埔里大哥的眼睛有毛病影响了他的头脑。他的眼睛鼓胀，眼睑能眨动。因此他的头脑经常在烦躁激动。动一次手术就可以除去那些有刺激作用的物体。” “你总不会要我丧失视力吧？”他问她，“我整个的世界都是视觉的赐与。美丽的东西……花、夕阳……和你。单是为了看见你那可爱的脸，就应有上天给的视觉才行。” 她说，“你不要这么讲。我知道我的面容很秀美──但是现在……”“你的意思是说——你希望我丧失视力。”他回答。她伸开双臂搂着他；大哭起来。“噢，我希望我们以后都在一起，你也是，对不对？”她呜咽着说。    在进行手术前那一星期，努涅斯一点都睡不着。在他享有视为的最后一天开始的时候，他和美丽单独在一起几分钟。“明天，”他说，“我就看不见了。” 她紧握着他的手。“他们不会使你多痛的。而且，我的爱人，你是为了我而受这痛苦的。”他的最后一次看着她那可爱的脸。“再见，”他低声地说。    他前往一个地方，青草地上开着白花，真美，他要将待在那里，直到牺牲的时刻来临。但当他抬起头来，看见早晨像个身披金甲的天使，于是他继续前行，往上走，出了墙垣，到达那些岩石山面。他开始往上爬。日落时，他已经爬到很远很高的地方。衣服撕破了，四肢血迹斑斑，他身上有多处瘀伤，但他怡然躺在那里。夕阳的红光逐渐消逝，黑夜来临，他仍然在寒星下怡然自得地躺在那里，面露笑容，感到欣慰。    因为也已经逃出了本想在那里称王的盲人山谷。"}]}}]);