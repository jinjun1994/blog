---
{
title: 前端跨域问题各种解决方案（开发环境中）,
date: 2018-07-01 23:14:23,
tags: [开发环境, 跨域]
}
---



### 什么是跨域

  域（Domain）是网络中独立运行的单位，域之间相互访问则需要建立信任关系（即Trust Relation）。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配资源，使不同的域之间实现网络资源的共享与管理。跨域访问是指，没有建立信任关系的两个域之间通讯，但是由于安全原因，跨域访问是被各大浏览器所默认禁止的。

### 哪些属于跨域

  浏览器遵循同源次略，非同源即为跨域，非同源分为三种。

- host不一致。
- 端口不一致。
- 协议不一致。

  上面三种，任意满足一种都是跨域，在请求的时候就会报错。根据上面的原理，我们可以发现在开发中，我们在浏览器打开的我们本地页面地址和请求地址不在一个源中，所以产生了跨域。

下表给出了相对 <http://store.company.com/dir/page.html> 同源检测的示例:

| URL                                               | 结果 | 原因                 |
| ------------------------------------------------- | ---- | -------------------- |
| <http://store.company.com/dir/inner/another.html> | 成功 | 同一域名             |
| <http://store.company.com/dir2/other.html>        | 成功 | 同一域名下不同文件夹 |
| <https://store.company.com/secure.html>           | 失败 | 不同的协议 ( https ) |
| <http://store.company.com:81/dir/etc.html>        | 失败 | 不同的端口 ( 81 )    |
| <http://news.company.com/dir/other.html>          | 失败 | 不同的主机 ( news )  |



### 解决跨域的方法和原理

<!--more--> 

  我们知道了跨域的原理，那么开发中，应该如何解决这个问题呢？

#### 反向代理

前面我们了解了，跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制，反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收internet上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给internet上请求链接的客户端。比如，我们常用的gulp、grunt、webpack这些脚手架都是通过这种原理解决的跨域。

具体实现：

**1.使用gulp脚手架解决跨域**

gulp中有两个解决跨域的包有gulp-connect-proxy、http-proxy-middleware，拿http-proxy-middleware为例，需要与gulp-connect一起使用：

```js
    var gulp = require('gulp');        
    var proxy = require('http-proxy-middleware');
        var connect = require('gulp-connect');
        gulp.task('server', function() {
            connect.server({
                 root: 'app',
                 livereload: true,
                 host: 'localhost',
                 port: "8080",
                 middleware: function(req, res, next) {
                   return [
                             proxy('/', {
                             target: 'targeturl',
                             changeOrigin: true
                                })
                            ];
                        }
                    });
                });
    gulp.task('default', ['server'], function() {

                });
```

**2.使用grunt脚手架解决跨域**

grunt和gulp其实是类似的，都是需要先连接本地服务，然后设置代理，grunt使用的的跨域插件是grunt-connect-proxy，需要与grunt-contrib-connect一起使用：

```js
    connect: {
    options: {
               port: ‘8080‘,
               hostname: ‘localhost‘,
               protocol: ‘http‘,
               open: true,
               base: {
               path: ‘./‘,
                options: {
                index: ‘html/index.html‘
                        }
                    },
                    livereload: true
                },
                proxies: [
                    {
                        context: ‘/‘ + API_NAME,
                        host: ‘localhost‘,
                        port: ‘8080‘,
                        https: false,
                        changeOrigin: true,
                        rewrite: proxyRewrite
                    }
                ],
                default: {},
                proxy: {
                    options: {
                        middleware: function (connect, options) {
                        if (!Array.isArray(options.base)) {
                                options.base = [options.base];
                            }
            // Setup the proxy
            var middlewares = [require(‘grunt-connect-proxy/lib/utils‘).proxyRequest];
            // Serve static files.
            options.base.forEach(function (base) {
                middlewares.push(serveStatic(base.path, base.options));
            });
            // Make directory browse-able.
            /*var directory = options.directory || options.base[options.base.length - 1];
             middlewares.push(connect.directory(directory));
             */
            return middlewares;
         }
       }
     }
    }           
```

**3.使用grunt脚手架解决跨域**

webpack如今在前端的三大框架中使用的比较广泛，我们以vue为例子，vue-cli中config/index.js中是这样配置代理的：

```js
port: 8090,    
proxyTable: {
                '/': {
                 target: targeturl,
                 changeOrigin: true,
                 pathRewrite: {
                      '^/': '/'
                      },
                   }
         }js
```

我们可以看到，这三种方式都是需要本地先开启服务的，target配置请求服务器的地址， Rewrite配置代理规则， changeOrigin设为true意思是同意将主机头的来源更改为目标URL。

这种代理解决跨域，前端正常写ajax就行。

#### Jsonp

Jsonp是通过web页面所有拥有src属性的标签都拥有跨域能力的属性，使客户端通过像调用脚本一样的方式，调用跨域服务器生成的js格式文件来获取数据。

具体实现如下。

服务端代码：

```js
    router.get('/jsonp', function(req, res, next) {
    var userName = req.query.uname;
    var password = req.query.pwd;
    var data = {
        code: 200,
        user: userName,
        password: password
    }
    res.jsonp(data);
    });
```

前端端代码：

```js
    $.ajax({
    async: true,
    url: "http://localhost:3000/jsonp",
    type: "GET",
    dataType: "jsonp", // 返回的数据类型，设置为JSONP方式
    jsonp: 'callback', //指定一个查询参数名称来覆盖默认的 jsonp 回调参数名 callback
    jsonpCallback: 'xxx', //设置回调函数名
    data: {
        "uname": 'jsonp',
        "pwd": "456"
    },
    success: function(response, status, xhr) {
        console.log(response);
    },
    });
```

#### Cors

Cross-Origin Rseouce Sharing（cors）跨域资源共享是W3C定义的通过使用自定义的http请求头，实现跨域访问资源时，浏览器和服务器之间的正常通讯，相比jsonp，cors更加先进方便可靠。

具体实现如下。

服务端代码：

```js
    router.get('/cors', function(req, res, next) {
    var userName = req.query.uname;
    var password = req.query.pwd;
    var data = {
        code: 200,
        user: userName,
        password: password
    }
    res.header("Access-Control-Allow-Origin", "*"); // *代表接受任何域名跨域,可使用指定ip替换*
    res.header('Access-Control-Allow-Methods', 'GET, POST');//用来列出浏览器的cors请求还会用到那些http方法.
    res.header('Access-Control-Allow-Headers', 'X-Requested-With,content-type, Authorization');//用来指定浏览器cors请求发送的头信息字段,可不写
    res.send(data);
});
```

前端端代码：

```js
    $.ajax({
    url: "http://localhost:3000/cors",
    type: "get",
    data: {
        "uname": 'cors',
        "pwd": "123"
    },
    success: function(data) {
        console.log(data);
    },
    error: function() {
        console.log('fail');
    }
    });
```

#### 端口转发映射

端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为，其使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。当我们把端口转发到与请求服务器相同的时候，就同源了，也不会出现跨域。

具体实现：

过程:

（1）启动网卡的转发功能：1 > /proc/sys/net/ipv4/ip_forward

（2）增加转发规则

```js
   iptables -t nat -A PREROUTING -p tcp -i eth0 --dport 本机端口 -j DNAT --to 需转发的ip:端口
   iptables -t nat -A POSTROUTING -j MASQUERADE
   for example: 我们当前ip为123.0.0.1我们想通过1230.0.0.1访问2340.0.0.1:90的服务
   iptables -t nat -A PREROUTING -p tcp -i eth0 --dport 80 -j DNAT --to 2340.0.0.1:90
   iptables -t nat -A POSTROUTING -j MASQUERADE
```

（3）查询本机转发规则

```js
   iptables -t nat -L -n  | grep 80
   这会出现所有80端口转发的规则
```

（4）删除规则

```js
   iptables -t nat -D PREROUTING -p tcp -i eth0 --dport 本机端口 -j DNAT --to 需转发的ip:端口
```

另外，做本机端口转发，需要配置output链本机访问外网的端口会转发到本地，导致访不到外网，如访问woniuchiyum.top，实际上是访问到本地，建议不做80端口的转发或者指定目的 -d localhost)：

```js
   iptables -t nat -A OUTPUT -d localhost -p tcp --dport 80 -j REDIRECT --to-ports 8080
```

> PS：同一端口可以转发至多个ip，优先访问的是规则第一条，如果找不到会找下一个，全部找不到才会爆404。

如本机端口在转发时已被使用，那么域名解析时，优先指向本机ip，然后才是被转发ip，但是使用IP访问的时候，是转发ip的服务。

#### 内网穿透

内网穿透其实就是高性能的反向代理服务器是一样的。但是是想方式和gulp，Grunt等等不同，配置更为简单方便。

具体实现：

（1）在frp官网下载源码，[中文网址详见这里](http://getfrp.yzxx-soft.com/)。

（2）我们将 frps 及 frps.ini 放到具有公网 IP 的服务器上，修改frps.ini 文件：

```js
[common]
bind_port = 7000   //绑定端口,自定义,需要与 frp.ini 中server_port保持一致
vhost_http_port = 8080  //访问端口,自定义
```

（3）启动frps，Windows 直接点击 frps.exe 运行，mac 根目录下终端运行./frps -c ./frps.ini。

（4）将frp 及 frpc.ini 放到本地，修改frpc.ini 文件：

```js
[common]
server_addr = xxxx //服务器公网ip
server_port =  7000 //需要与 frps.ini 中server_port保持一致
[web]
type = http  
local_port = 8080   //本地服务端口
local_addr = 10.10.50.37  //本机的ip windows cmd运行ipconfig mac 终端运行 ifconfig查看本机ip
custom_domains = 服务器域名
```

（5）本地启动frp，windows直接点击frp.exe运行，mac 根目录下终端运行./frpc -c ./frpc.ini。

（6）浏览器输入 frp.ini中设置的服务器域名：frps.ini中设置的访问端口，即可访问。

附：

- 本地启动frp之前，需要先启动本地的web服务。
- frp官网中frp.ini文件没有设置 local_addr，但是不设置这个运行frps.ini 会报错get hostname error，这个大家自己测试。

#### 修改浏览器配置

除了上述的代码修改意外，有个超级简单，但是不怎么推荐大家使用的方法，就是修改浏览器配置，关闭安全策略。前面说了跨域访问是被各大浏览器所默认禁止的，但是如果我们在开发的时候不禁止也是可以的。

chrome是前端开发中很好的调试浏览器，里面就有关闭安全策略，允许访问的设置。

注意，设置关闭安全策略之前，请先关掉chrome。

mac:

打开终端输入命令行

```js
//chrome 浏览器
open -a "Google Chrome" --args --disable-web-security  --user-data-dir
//safari mac电脑safari也可以设置
open -a '/Applications/Safari.app' --args --disable-web-security --user-data-dir 
```

windows下：

**1.命令行打开**

首先找到chrome.exe图标，查看当前路径，粘贴保存路径，然后在cmd输入

chrome.exe路径 --disable-web-security --user-data-dir

**2.配置快捷方式打开**

新建桌面快捷方式，快捷方式后面空一格加上下面这句话 --disable-web-security --user-data-dir 然后就ok了。

注意：除了jsonp ，端口映射，cors这三种方式外，别的跨域解决方式只是在我们开发环境中解决了跨域，发布环境如果存在某一种非同源条件还是有跨域问题的。所以，需要根据不同场景，选择适合我们的跨域解决方案。那么如何选择适合我们的跨域方式呢？

- 普通html页面开发，代码部署路径和后端服务在同一服务器下面。 荐使用gulp，理由：简单容易搭建，gulp还可扩展打包，压缩等等服务。第二推荐grunt，grunt和gulp本来就相同，但是相对写gulp的server和watch操作更简单。
- 使用vue angular react框架，代码部署路径和后端服务在同一服务器下面。

建议使用webpack，框架中一般vue-cli angular-cli都带已经有webpack的配置了，我们只用配置代理路径就可以。

- 微信公众号的开发，代码部署路径和后端服务在同一服务器下面。

建议使用内网穿透，微信公众号的开发相对来说比较麻烦，因为我们除了要解决前后端分离的跨域问题，我们调试微信jdk的时候，必须在微信开发工具中调试，也就是说，每次更改代码都需要部署到服务器，然后才可以调试，使用内网穿透可以很好解决这个问题。因为内网穿透直接把我们本地代码映射到了服务器。

- sso等等后端服务和前端服务不在同一台服务器上

建议使用cors，当多个在不同服务器的前端系统共用一个接口，或者别的前后端在不同服务器上时候，cors是一劳永逸的最便捷的方式。