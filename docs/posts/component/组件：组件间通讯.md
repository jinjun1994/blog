---

{
title: 组件：通信 angular、vue组件间通信,
date: 2018-06-04 23:35:45,
tags: [vue,angular,组件]
}
---



## 组件：组件间通讯

![enter image description here](http://images.gitbook.cn/08a931a0-ae67-11e7-8003-dd1d9d56caa7)

组件就像零散的积木，我们需要把这些积木按照一定的规则拼装起来，而且要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。

在真实的应用中，组件最终会构成树形结构，就像人类社会中的家族树一样：

![enter image description here](http://images.gitbook.cn/891636a0-af23-11e7-b111-4d6e630f480d)

在树形结构里面，组件之间有几种典型的关系：父子关系、兄弟关系、没有直接关系。

相应地，组件之间有以下几种典型的通讯方案：

- 直接的父子关系：父组件直接访问子组件的 public 属性和方法。
- 直接的父子关系：借助于 @Input 和 @Output 进行通讯
- 没有直接关系：借助于 Service 单例进行通讯。
- 利用 cookie 和 localstorage 进行通讯。
- 利用 session 进行通讯。

无论你使用什么前端框架，组件之间的通讯都离开不以上几种方案，这些方案与具体框架无关。

<!--more--> 

## Angular组件间通讯

### 直接调用

对于有直接父子关系的组件，父组件可以直接访问子组件里面 public 型的属性和方法，示例代码片段如下：

```
<child #child></child>
<button (click)="child.childFn()" class="btn btn-success">调用子组件方法</button>
```

显然，子组件里面必须暴露一个 public 型的 childFn 方法，就像这样：

```
public childFn():void{
    console.log("子组件的名字是>"+this.panelTitle);
}
```

以上是通过在模板里面定义局部变量的方式来直接调用子组件里面的 public 型方法。在父组件的内部也可以访问到子组件的实例，需要利用到 @ViewChild 装饰器，示例如下：

```
@ViewChild(ChildComponent)
private childComponent: ChildComponent;
```

关于 @ViewChild 在后面的内容里面会有更详细的解释。

很明显，如果父组件直接访问子组件，那么两个组件之间的关系就被固定死了。父子两个组件紧密依赖，谁也离不开谁，也就都不能单独使用了。所以，除非你知道自己在做什么，最好不要直接在父组件里面直接访问子组件上的属性和方法，以免未来一改一大片。

### @Input 和 @Output

我们可以利用 @Input 装饰器，让父组件直接给子组件传递参数，子组件上这样写：

```
@Input()
public panelTitle:string;
```

父组件上可以这样设置 panelTitle 这个参数：

```
<child panelTitle="一个新的标题"></child>
```

@Output 的本质是事件机制，我们可以利用它来监听子组件上派发的事件，子组件上这样写：

```
@Output()
public follow=new EventEmitter<string>();
```

触发 follow 事件的方式如下：

```
this.follow.emit("follow");
```

父组件上可以这样监听 follow 事件：

```
<child (follow)="doSomething()"></child>
```

我们可以利用 @Output 来自定义事件，监听自定义事件的方式也是通过小圆括号，与监听 HTML 原生事件的方式一模一样。

### 利用 Service 单例进行通讯

![enter image description here](http://images.gitbook.cn/d2615600-af23-11e7-9203-4582e2e80f6b)

如果你在根模块（一般是 app.module.ts）的 providers 里面注册一个 Service，那么这个 Service 就是全局单例的，这样一来我们就可以利用这个单例的 Service 在不同的组件之间进行通讯了。

- 比较粗暴的方式：我们可以在 Service 里面定义 public 型的共享变量，然后让不同的组件都来访问这块变量，从而达到共享数据的目的。
- 优雅一点的方式：利用 RxJS，在 Service 里面定义一个 public 型的 Subject（主题），然后让所有组件都来subscribe（订阅）这个主题，类似于一种“事件总线”的效果。

实例代码片段：

```
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';

/**
 * 用来充当事件总线的Service
 */
@Injectable()
export class EventBusService {
  public eventBus:Subject<string> = new Subject<string>();

  constructor() { }

}
import { Component, OnInit } from '@angular/core';
import { EventBusService } from '../service/event-bus.service';

@Component({
  selector: 'child-1',
  templateUrl: './child-1.component.html',
  styleUrls: ['./child-1.component.css']
})
export class Child1Component implements OnInit {

  constructor(public eventBusService:EventBusService) { }

  ngOnInit() {
  }

  public triggerEventBus():void{
    this.eventBusService.eventBus.next("第一个组件触发的事件");
  }
}
import { Component, OnInit } from '@angular/core';
import { EventBusService } from '../service/event-bus.service';

@Component({
  selector: 'child-2',
  templateUrl: './child-2.component.html',
  styleUrls: ['./child-2.component.css']
})
export class Child2Component implements OnInit {
  public events:Array<any>=[];

  constructor(public eventBusService:EventBusService) {

  }

  ngOnInit() {
    this.eventBusService.eventBus.subscribe((value)=>{
      this.events.push(value+"-"+new Date());
    });
  }
}
```

### 利用 cookie 或者 localstorage 进行通讯

![enter image description here](http://images.gitbook.cn/e9aaf1e0-af23-11e7-b111-4d6e630f480d)

示例代码片段：

```
public writeData():void{
    window.localStorage.setItem("json",JSON.stringify({name:'jinjun',age:18}));
}
var json=window.localStorage.getItem("json");
// window.localStorage.removeItem("json");
var obj=JSON.parse(json);
console.log(obj.name);
console.log(obj.age);
```

**很多朋友写 Angular 代码的时候出现了思维定势，总感觉 Angular 会封装所有东西，实际上并非如此。比如 cookie、localstorage 这些东西都可以直接用原生的 API 进行操作的。千万别忘记原生的那些 API 啊，都能用的！**

### 利用 session 进行通讯

![enter image description here](http://images.gitbook.cn/79246040-af24-11e7-b111-4d6e630f480d)

## Vue组件间通讯

###  现代通信方式: FLUX VUEX

**FLUX将一个应用分成四个部分**:[文档](https://link.juejin.im/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F01%2Fflux.html)

1. View： 视图层
2. Action（动作）：视图层发出的消息（比如mouseClick）
3. Dispatcher（派发器）：用来接收Actions、执行回调函数
4. Store（数据层Model）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面

flux最大的特性是“单向数据流”，具体流程：

1. 用户访问 View,
2. View 发出用户的 Action,
3. Dispatcher 收到 Action，要求 Store 进行相应的更新
4. Store 更新后，发出一个”change”事件
5. View 收到”change”事件后，更新页面
   [![img](https://user-gold-cdn.xitu.io/2017/10/23/37363e31f10108cfbebdd300193fe6dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)](https://link.juejin.im/?target=http%3A%2F%2Fzhentaoo.com%2Fimg%2Fflux.png)

**VUEX**:[官方文档](https://link.juejin.im/?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh-cn%2Fintro.html)
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
我们把组件的共享状态抽取出来，以一个全局单例模式管理,在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！
注：action可以是异步的，但mutations一定是同步的

对于一个的VUEX应用来说,FLUX的概念被具化成：

1. VUE: 视图层
2. Action（动作）：视图层发出的消息（比如mouseClick）
3. Mutations（派发器）：用来接收Actions、执行回调函数
4. State（数据层Model）：用来存放应用的状态，一旦发生变动，就提醒Vue要更新页面
   [![vuex](https://user-gold-cdn.xitu.io/2017/10/23/45f2d7c2f94cfdc3fe3c72041319ce85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)](https://link.juejin.im/?target=http%3A%2F%2Fzhentaoo.com%2Fimg%2Fvuex.png)vuex

### 父子组件通信:props，events

**父->子**: 父组件使用 props 把数据传给子组件,文档如下
[cn.vuejs.org/v2/guide/co…](https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html%23%E4%BD%BF%E7%94%A8-Prop-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE)

```
<child message="hello!"></child>
```

```
Vue.component('child', {
  // 声明 props
  props: ['message'],
  // 就像 data 一样，prop 可以用在模板内
  // 同样也可以在 vm 实例中像 “this.message” 这样使用
  template: '<span>{{ message }}</span>'
})
```

需要**注意**的是，子组件不能修改父组件的props
因为一个父组件下可能有多个子组件，如果某个子组件修改了父组件传递的props，
很可能导致其他子组件也就跟着变化，最终导致整个应用的状态难以管理和维护
所以不允许子组件修改props

**子->父**: 子组件自定义事件，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件

```
<div id="counter-event-example">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
```

```
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})
new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
```

### 非父子组件通信: event bus

官方文档：[cn.vuejs.org/v2/guide/co…](https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html%23%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1)
有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线
在这两个组件之间引入这个中央事件总线，然后emit，on相应的事件

```
var bus = new Vue()
// 触发组件 A 中的事件
bus.$emit('id-selected', 1)
// 在组件 B 创建的钩子中监听事件
bus.$on('id-selected', function (id) {
  // ...
})
```

### 小结

组件间的通讯方案是通用的，无论你使用什么样的前端框架，都会面临这个问题，而解决的方案无外乎本文所列出的几种。